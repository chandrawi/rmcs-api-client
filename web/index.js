import { pb_api, pb_role, pb_user, pb_token, pb_auth } from 'rmcs-auth-api';
import { pb_model, pb_device, pb_group, pb_set, pb_data, pb_buffer, pb_slice, pb_log } from 'rmcs-resource-api';

/**
 * Construct request metadata
 * @param {{address:string,token:string}} server 
 * @returns {Object.<string,string>}
 */
function metadata(server) {
    if (server.token) {
        return { "Authorization": "Bearer " + server.token };
    }
    return {};
}

/**
 * Convert base64 string to UUID hex representation
 * @param {string} str 
 * @returns {string}
 */
function base64_to_uuid_hex(str) {
    const raw = atob(str);
    let result = '';
    let dashPos = [3, 5, 7, 9];
    for (let i = 0; i < raw.length; i++) {
      const hex = raw.charCodeAt(i).toString(16);
      result += (hex.length === 2 ? hex : '0' + hex);
      if (dashPos.includes(i)) {
        result += '-';
      }
    }
    return result;
}

/**
 * Convert UUID hex representation to base64 string
 * @param {string} uuid 
 * @returns {string}
 */
function uuid_hex_to_base64(uuid) {
    if (typeof uuid == "string") {
        uuid = uuid.replace(/-/g, '');
        if (/^[0-9a-fA-F]{32}$/.test(uuid)) {
            return btoa(uuid.match(/\w{2}/g).map((a) => {
                return String.fromCharCode(parseInt(a, 16));
            }).join(""));
        }
    }
    return "";
}

/**
 * Generate random bytes
 * @param {number} number number of generated bytes (integer) 
 */
function random_binary(number) {
    const buffer = new Uint8Array(number);
    buffer.forEach((value, index, array) => {
        array[index] = Math.floor(Math.random() * 256);
    });
    return buffer;
}

/**
 * Generate random base64 string
 * @param {number} number number of generated base64 string (integer) 
 * @returns {string}
 */
function random_base64(number) {
    const base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    let str = "";
    for (let i=0; i<number; i++) {
        str += base64.charAt(Math.floor(Math.random() * 64));
    }
    return str;
}

/**
 * Generate random UUID version 4 in hex format
 * @returns {string}
 */
function uuid_v4_hex() {
    const buffer = random_binary(16);
    let result = '';
    let dashPos = [3, 5, 7, 9];
    for (let i = 0; i < buffer.length; i++) {
        let hex = buffer[i].toString(16);
        hex = hex.length === 2 ? hex : '0' + hex;
        if (i === 6) {
            hex = '4' + hex.charAt(1);
        }
        result += hex;
        if (dashPos.includes(i)) {
            result += '-';
        }
    }
    return result;
}

/**
 * Convert a string into an ArrayBuffer
 * @param {string} str 
 * @returns {ArrayBuffer}
 */
function string_to_array_buffer(str) {
    const buf = new ArrayBuffer(str.length);
    const bufView = new Uint8Array(buf);
    for (let i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }
    return buf;
}

/**
 * Convert base64 string to bytes (number[])
 * @param {string} base64 
 * @returns {number[]}
 */
function base64_to_bytes(base64) {
    return atob(base64).split("").map((v) => {
        return v.charCodeAt();
    });
}

/**
 * Convert bytes (Uint8Array, number[]) to base64 string
 * @param {Uint8Array|number[]} bytes 
 * @returns {string}
 */
function bytes_to_base64(bytes) {
    return btoa(Array.from(bytes).map((v) => {
        return String.fromCharCode(v);
    }).join(""));
}

var utility = /*#__PURE__*/Object.freeze({
    __proto__: null,
    base64_to_bytes: base64_to_bytes,
    base64_to_uuid_hex: base64_to_uuid_hex,
    bytes_to_base64: bytes_to_base64,
    metadata: metadata,
    random_base64: random_base64,
    random_binary: random_binary,
    string_to_array_buffer: string_to_array_buffer,
    uuid_hex_to_base64: uuid_hex_to_base64,
    uuid_v4_hex: uuid_v4_hex
});

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} ApiId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} ApiIds
 * @property {Uuid[]} ids
 */

/**
 * @param {*} r 
 * @returns {ApiId}
 */
function getApiId(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
 * @typedef {Object} ApiName
 * @property {string} name
 */

/**
 * @typedef {Object} ApiCategory
 * @property {string} category
 */

/**
 * @typedef {Object} ApiOption
 * @property {?string} name
 * @property {?string} category
 */

/**
 * @typedef {Object} ApiSchema
 * @property {Uuid} id
 * @property {string} name
 * @property {string} address
 * @property {string} category
 * @property {string} description
 * @property {string} password
 * @property {string} access_key
 * @property {ProcedureSchema[]} procedures
 */

/**
 * @param {*} r 
 * @returns {ApiSchema}
 */
function get_api_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        name: r.name,
        address: r.address,
        category: r.category,
        description: r.description,
        password: r.password,
        access_key: r.accessKey,
        procedures: get_procedure_schema_vec(r.proceduresList)
    };
}

/**
 * @param {*} r 
 * @returns {ApiSchema[]}
 */
function get_api_schema_vec(r) {
    return r.map((v) => {return get_api_schema(v)});
}

/**
 * @typedef {Object} ApiUpdate
 * @property {Uuid} id
 * @property {?string} name
 * @property {?string} address
 * @property {?string} category
 * @property {?string} description
 * @property {?string} password
 * @property {?string} access_key
 */

/**
 * @typedef {Object} ProcedureId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} ProcedureIds
 * @property {Uuid[]} ids
 */

/**
 * @param {*} r 
 * @returns {ProcedureId}
 */
function get_procedure_id(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
 * @typedef {Object} ProcedureName
 * @property {Uuid} api_id
 * @property {string} name
 */

/**
 * @typedef {Object} ProcedureOption
 * @property {?Uuid} api_id
 * @property {?string} name
 */

/**
 * @typedef {Object} ProcedureSchema
 * @property {Uuid} id
 * @property {string} api_id
 * @property {string} name
 * @property {string} description
 * @property {string[]} roles
 */

/**
 * @param {*} r 
 * @returns {ProcedureSchema}
 */
function get_procedure_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        api_id: base64_to_uuid_hex(r.apiId),
        name: r.name,
        description: r.description,
        roles: r.rolesList
    };
}

/**
 * @param {*} r 
 * @returns {ProcedureSchema[]}
 */
function get_procedure_schema_vec(r) {
    return r.map((v) => {return get_procedure_schema(v)});
}

/**
 * @typedef {Object} ProcedureUpdate
 * @property {Uuid} id
 * @property {?string} name
 * @property {?string} description
 */


/**
 * Read an api by uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {ApiId} request api uuid: id
 * @returns {Promise<ApiSchema>} api schema: id, name, address, category, description, password, access_key, procedures
 */
async function read_api(server, request) {
    const client = new pb_api.ApiServicePromiseClient(server.address, null, null);
    const apiId = new pb_api.ApiId();
    apiId.setId(uuid_hex_to_base64(request.id));
    return client.readApi(apiId, metadata(server))
        .then(response => response.toObject().result);
}

/**
 * Read an api by name
 * @param {ServerConfig} server server configuration: address, token
 * @param {ApiName} request api name: name
 * @returns {Promise<ApiSchema>} api schema: id, name, address, category, description, password, access_key, procedures
 */
async function read_api_by_name(server, request) {
    const client = new pb_api.ApiServicePromiseClient(server.address, null, null);
    const apiName = new pb_api.ApiName();
    apiName.setName(request.name);
    return client.readApiByName(apiName, metadata(server))
        .then(response => get_api_schema(response.toObject().result));
}

/**
 * Read apis by uuid list
 * @param {ServerConfig} server server configuration: address, token
 * @param {ApiIds} request api uuid list: ids
 * @returns {Promise<ApiSchema[]>} api schema: id, name, address, category, description, password, access_key, procedures
 */
async function list_api_by_ids(server, request) {
    const client = new pb_api.ApiServicePromiseClient(server.address, null, null);
    const apiIds = new pb_api.ApiIds();
    apiIds.setIdsList(request.ids.map((id) => uuid_hex_to_base64(id)));
    return client.listApiByIds(apiIds, metadata(server))
        .then(response => get_api_schema_vec(response.toObject().resultsList));
}

/**
 * Read apis by name
 * @param {ServerConfig} server server configuration: address, token
 * @param {ApiName} request api name: name
 * @returns {Promise<ApiSchema[]>} api schema: id, name, address, category, description, password, access_key, procedures
 */
async function list_api_by_name(server, request) {
    const client = new pb_api.ApiServicePromiseClient(server.address, null, null);
    const apiName = new pb_api.ApiName();
    apiName.setName(request.name);
    return client.listApiByName(apiName, metadata(server))
        .then(response => get_api_schema_vec(response.toObject().resultsList));
}

/**
 * Read apis by category
 * @param {ServerConfig} server server configuration: address, token
 * @param {ApiCategory} request api category: category
 * @returns {Promise<ApiSchema[]>} api schema: id, name, address, category, description, password, access_key, procedures
 */
async function list_api_by_category(server, request) {
    const client = new pb_api.ApiServicePromiseClient(server.address, null, null);
    const apiCategory = new pb_api.ApiCategory();
    apiCategory.setCategory(request.category);
    return client.listApiByCategory(apiCategory, metadata(server))
        .then(response => get_api_schema_vec(response.toObject().resultsList));
}

/**
 * Read apis with options
 * @param {ServerConfig} server server configuration: address, token
 * @param {ApiOption} request api option: name, category
 * @returns {Promise<ApiSchema[]>} api schema: id, name, address, category, description, password, access_key, procedures
 */
async function list_api_option(server, request) {
    const client = new pb_api.ApiServicePromiseClient(server.address, null, null);
    const apiOption = new pb_api.ApiOption();
    apiOption.setName(request.name);
    apiOption.setCategory(request.category);
    return client.listApiOption(apiOption, metadata(server))
        .then(response => get_api_schema_vec(response.toObject().resultsList));
}

/**
 * Create an api
 * @param {ServerConfig} server server configuration: address, token
 * @param {ApiSchema} request api schema: id, name, address, category, description, password, access_key
 * @returns {Promise<ApiId>} api id: id
 */
async function create_api(server, request) {
    const client = new pb_api.ApiServicePromiseClient(server.address, null, null);
    const apiSchema = new pb_api.ApiSchema();
    apiSchema.setId(uuid_hex_to_base64(request.id));
    apiSchema.setName(request.name);
    apiSchema.setAddress(request.address);
    apiSchema.setCategory(request.category);
    apiSchema.setDescription(request.description);
    apiSchema.setPassword(request.password);
    apiSchema.setAccessKey(request.access_key);
    return client.createApi(apiSchema, metadata(server))
        .then(response => getApiId(response.toObject()));
}

/**
 * Update an api
 * @param {ServerConfig} server server configuration: address, token
 * @param {ApiUpdate} request api update: id, name, address, category, description, password, access_key
 * @returns {Promise<{}>} update response
 */
async function update_api(server, request) {
    const client = new pb_api.ApiServicePromiseClient(server.address, null, null);
    const apiUpdate = new pb_api.ApiUpdate();
    apiUpdate.setId(uuid_hex_to_base64(request.id));
    apiUpdate.setName(request.name);
    apiUpdate.setAddress(request.address);
    apiUpdate.setCategory(request.category);
    apiUpdate.setDescription(request.description);
    apiUpdate.setPassword(request.password);
    apiUpdate.setAccessKey(request.access_key);
    return client.updateApi(apiUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete an api
 * @param {ServerConfig} server server configuration: address, token
 * @param {ApiId} request api uuid: id
 * @returns {Promise<{}>} delete response
 */
async function delete_api(server, request) {
    const client = new pb_api.ApiServicePromiseClient(server.address, null, null);
    const apiId = new pb_api.ApiId();
    apiId.setId(uuid_hex_to_base64(request.id));
    return client.deleteApi(apiId, metadata(server))
        .then(response => response.toObject());
}

/**
 * Read an procedure by uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {ProcedureId} request procedure uuid: id
 * @returns {Promise<ProcedureSchema>} procedure schema: id, api_id, name, description, roles
 */
async function read_procedure(server, request) {
    const client = new pb_api.ApiServicePromiseClient(server.address, null, null);
    const procedureId = new pb_api.ProcedureId();
    procedureId.setId(uuid_hex_to_base64(request.id));
    return client.readProcedure(procedureId, metadata(server))
        .then(response => response.toObject().result);
}

/**
 * Read an procedure by name
 * @param {ServerConfig} server server configuration: address, token
 * @param {ProcedureName} request procedure name: api_id, name
 * @returns {Promise<ProcedureSchema>} procedure schema: id, api_id, name, description, roles
 */
async function read_procedure_by_name(server, request) {
    const client = new pb_api.ApiServicePromiseClient(server.address, null, null);
    const procedureName = new pb_api.ProcedureName();
    procedureName.setApiId(uuid_hex_to_base64(request.api_id));
    procedureName.setName(request.name);
    return client.readProcedureByName(procedureName, metadata(server))
        .then(response => get_procedure_schema(response.toObject().result));
}

/**
 * Read procedures by uuid list
 * @param {ServerConfig} server server configuration: address, token
 * @param {ProcedureIds} request procedure uuid list: ids
 * @returns {Promise<ProcedureSchema[]>} procedure schema: id, api_id, name, description, roles
 */
async function list_procedure_by_ids(server, request) {
    const client = new pb_api.ApiServicePromiseClient(server.address, null, null);
    const procedureIds = new pb_api.ProcedureIds();
    procedureIds.setIdsList(request.ids.map((id) => uuid_hex_to_base64(id)));
    return client.listProcedureByIds(procedureIds, metadata(server))
        .then(response => get_procedure_schema_vec(response.toObject().resultsList));
}

/**
 * Read procedures by api uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {ApiId} request api uuid: id
 * @returns {Promise<ProcedureSchema[]>} procedure schema: id, api_id, name, description, roles
 */
async function list_procedure_by_api(server, request) {
    const client = new pb_api.ApiServicePromiseClient(server.address, null, null);
    const apiId = new pb_api.ApiId();
    apiId.setId(uuid_hex_to_base64(request.id));
    return client.listProcedureByApi(apiId, metadata(server))
        .then(response => get_procedure_schema_vec(response.toObject().resultsList));
}

/**
 * Read procedures by name
 * @param {ServerConfig} server server configuration: address, token
 * @param {ProcedureName} request procedure name: name
 * @returns {Promise<ProcedureSchema[]>} procedure schema: id, api_id, name, description, roles
 */
async function list_procedure_by_name(server, request) {
    const client = new pb_api.ApiServicePromiseClient(server.address, null, null);
    const procedureName = new pb_api.ProcedureName();
    procedureName.setName(request.name);
    return client.listProcedureByName(procedureName, metadata(server))
        .then(response => get_procedure_schema_vec(response.toObject().resultsList));
}

/**
 * Read procedures with options
 * @param {ServerConfig} server server configuration: address, token
 * @param {ProcedureOption} request procedure option: api_id, name
 * @returns {Promise<ProcedureSchema[]>} procedure schema: id, api_id, name, description, roles
 */
async function list_procedure_option(server, request) {
    const client = new pb_api.ApiServicePromiseClient(server.address, null, null);
    const procedureOption = new pb_api.ProcedureOption();
    if (request.api_id) {
        procedureOption.setApiId(uuid_hex_to_base64(request.api_id));
    }
    procedureOption.setName(request.name);
    return client.listProcedureOption(procedureOption, metadata(server))
        .then(response => get_procedure_schema_vec(response.toObject().resultsList));
}

/**
 * Create a procedure
 * @param {ServerConfig} server server configuration: address, token
 * @param {ProcedureSchema} request procedure schema: id, api_id, name, description
 * @returns {Promise<ProcedureId>} procedure id: id
 */
async function create_procedure(server, request) {
    const client = new pb_api.ApiServicePromiseClient(server.address, null, null);
    const procedureSchema = new pb_api.ProcedureSchema();
    procedureSchema.setId(uuid_hex_to_base64(request.id));
    procedureSchema.setApiId(uuid_hex_to_base64(request.api_id));
    procedureSchema.setName(request.name);
    procedureSchema.setDescription(request.description);
    return client.createProcedure(procedureSchema, metadata(server))
        .then(response => get_procedure_id(response.toObject()));
}

/**
 * Update a procedure
 * @param {ServerConfig} server server configuration: address, token
 * @param {ProcedureUpdate} request procedure update: id, name, description
 * @returns {Promise<{}>} update response
 */
async function update_procedure(server, request) {
    const client = new pb_api.ApiServicePromiseClient(server.address, null, null);
    const procedureUpdate = new pb_api.ProcedureUpdate();
    procedureUpdate.setId(uuid_hex_to_base64(request.id));
    procedureUpdate.setName(request.name);
    procedureUpdate.setDescription(request.description);
    return client.updateProcedure(procedureUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete a procedure
 * @param {ServerConfig} server server configuration: address, token
 * @param {ProcedureId} request procedure uuid: id
 * @returns {Promise<{}>} update response
 */
async function delete_procedure(server, request) {
    const client = new pb_api.ApiServicePromiseClient(server.address, null, null);
    const procedureId = new pb_api.ProcedureId();
    procedureId.setId(uuid_hex_to_base64(request.id));
    return client.deleteProcedure(procedureId, metadata(server))
        .then(response => response.toObject());
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} RoleId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} RoleIds
 * @property {Uuid[]} ids
 */

/**
 * @param {*} r 
 * @returns {RoleId}
 */
function get_role_id(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
 * @typedef {Object} RoleName
 * @property {Uuid} api_id
 * @property {string} name
 */

/**
 * @typedef {Object} ApiId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} UserId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} RoleOption
 * @property {?Uuid} api_id
 * @property {?Uuid} user_id
 * @property {?string} name
 */

/**
 * @typedef {Object} RoleSchema
 * @property {Uuid} id
 * @property {Uuid} api_id
 * @property {string} name
 * @property {boolean} multi
 * @property {boolean} ip_lock
 * @property {number} access_duration
 * @property {number} refresh_duration
 * @property {string} access_key
 * @property {string[]} procedures
 */

/**
 * @param {*} r 
 * @returns {RoleSchema}
 */
function get_role_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        api_id: base64_to_uuid_hex(r.apiId),
        name: r.name,
        multi: r.multi,
        ip_lock: r.ipLock,
        access_duration: r.accessDuration,
        refresh_duration: r.refreshDuration,
        access_key: r.accessKey,
        procedures: r.proceduresList.map((v) => {return base64_to_uuid_hex(v)})
    };
}

/**
 * @param {*} r 
 * @returns {RoleSchema[]}
 */
function get_role_schema_vec(r) {
    return r.map((v) => {return get_role_schema(v)});
}

/**
 * @typedef {Object} RoleUpdate
 * @property {Uuid} id
 * @property {?string} name
 * @property {?boolean} multi
 * @property {?boolean} ip_lock
 * @property {?number} access_duration
 * @property {?number} refresh_duration
 */

/**
 * @typedef {Object} RoleAccess
 * @property {Uuid} id
 * @property {Uuid} procedure_id
 */


/**
 * Read a role by uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {RoleId} request role uuid: id
 * @returns {Promise<RoleSchema>} role schema: id, api_id, name, multi, ip_lock, access_duration, refresh_duration, access_key, procedures
 */
async function read_role(server, request) {
    const client = new pb_role.RoleServicePromiseClient(server.address, null, null);
    const roleId = new pb_role.RoleId();
    roleId.setId(uuid_hex_to_base64(request.id));
    return client.readRole(roleId, metadata(server))
        .then(response => get_role_schema(response.toObject().result));
}

/**
 * Read a role by name
 * @param {ServerConfig} server server configuration: address, token
 * @param {RoleName} request role name: api_id, name
 * @returns {Promise<RoleSchema>} role schema: id, api_id, name, multi, ip_lock, access_duration, refresh_duration, access_key, procedures
 */
async function read_role_by_name(server, request) {
    const client = new pb_role.RoleServicePromiseClient(server.address, null, null);
    const roleName = new pb_role.RoleName();
    roleName.setApiId(uuid_hex_to_base64(request.api_id));
    roleName.setName(request.name);
    return client.readRoleByName(roleName, metadata(server))
        .then(response => get_role_schema(response.toObject().result));
}

/**
 * Read roles by uuid list
 * @param {ServerConfig} server server configuration: address, token
 * @param {RoleIds} request role uuid list: ids
 * @returns {Promise<RoleSchema[]>} role schema: id, api_id, name, multi, ip_lock, access_duration, refresh_duration, access_key, procedures
 */
async function list_role_by_ids(server, request) {
    const client = new pb_role.RoleServicePromiseClient(server.address, null, null);
    const roleIds = new pb_role.RoleIds();
    roleIds.setIdsList(request.ids.map((id) => uuid_hex_to_base64(id)));
    return client.listRoleByIds(roleIds, metadata(server))
        .then(response => get_role_schema_vec(response.toObject().resultsList));
}

/**
 * Read roles by api uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {ApiId} request api uuid: id
 * @returns {Promise<RoleSchema[]>} role schema: id, api_id, name, multi, ip_lock, access_duration, refresh_duration, access_key, procedures
 */
async function list_role_by_api(server, request) {
    const client = new pb_role.RoleServicePromiseClient(server.address, null, null);
    const apiId = new pb_role.ApiId();
    apiId.setApiId(uuid_hex_to_base64(request.id));
    return client.listRoleByApi(apiId, metadata(server))
        .then(response => get_role_schema_vec(response.toObject().resultsList));
}

/**
 * Read roles by user uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {UserId} request user uuid: id
 * @returns {Promise<RoleSchema[]>} role schema: id, api_id, name, multi, ip_lock, access_duration, refresh_duration, access_key, procedures
 */
async function list_role_by_user(server, request) {
    const client = new pb_role.RoleServicePromiseClient(server.address, null, null);
    const userId = new pb_role.UserId();
    userId.setUserId(uuid_hex_to_base64(request.id));
    return client.listRoleByUser(userId, metadata(server))
        .then(response => get_role_schema_vec(response.toObject().resultsList));
}

/**
 * Read roles by name
 * @param {ServerConfig} server server configuration: address, token
 * @param {RoleName} request role name: name
 * @returns {Promise<RoleSchema[]>} role schema: id, api_id, name, multi, ip_lock, access_duration, refresh_duration, access_key, procedures
 */
async function list_role_by_name(server, request) {
    const client = new pb_role.RoleServicePromiseClient(server.address, null, null);
    const roleName = new pb_role.RoleName();
    roleName.setName(request.name);
    return client.listRoleByName(roleName, metadata(server))
        .then(response => get_role_schema_vec(response.toObject().resultsList));
}

/**
 * Read roles with options
 * @param {ServerConfig} server server configuration: address, token
 * @param {RoleOption} request role option: api_id, user_id, name
 * @returns {Promise<RoleSchema[]>} role schema: id, api_id, name, multi, ip_lock, access_duration, refresh_duration, access_key, procedures
 */
async function list_role_option(server, request) {
    const client = new pb_role.RoleServicePromiseClient(server.address, null, null);
    const roleOption = new pb_role.RoleOption();
    if (request.api_id) {
        roleOption.setApiId(uuid_hex_to_base64(request.api_id));
    }
    if (request.user_id) {
        roleOption.setUserId(uuid_hex_to_base64(request.user_id));
    }
    roleOption.setName(request.name);
    return client.listRoleOption(roleOption, metadata(server))
        .then(response => get_role_schema_vec(response.toObject().resultsList));
}

/**
 * Create a role
 * @param {ServerConfig} server server configuration: address, token
 * @param {RoleSchema} request role schema: id, api_id, name, multi, ip_lock, access_duration, refresh_duration, access_key
 * @returns {Promise<RoleId>} role id: id
 */
async function create_role(server, request) {
    const client = new pb_role.RoleServicePromiseClient(server.address, null, null);
    const roleSchema = new pb_role.RoleSchema();
    roleSchema.setId(uuid_hex_to_base64(request.id));
    roleSchema.setApiId(uuid_hex_to_base64(request.api_id));
    roleSchema.setName(request.name);
    roleSchema.setMulti(request.multi);
    roleSchema.setIpLock(request.ip_lock);
    roleSchema.setAccessDuration(request.access_duration);
    roleSchema.setRefreshDuration(request.refresh_duration);
    roleSchema.setAccessKey(request.access_key);
    return client.createRole(roleSchema, metadata(server))
        .then(response => get_role_id(response.toObject()));
}

/**
 * Update a role
 * @param {ServerConfig} server server configuration: address, token
 * @param {RoleUpdate} request role update: id, name, multi, ip_lock, access_duration, refresh_duration
 * @returns {Promise<{}>} update response
 */
async function update_role(server, request) {
    const client = new pb_role.RoleServicePromiseClient(server.address, null, null);
    const roleUpdate = new pb_role.RoleUpdate();
    roleUpdate.setId(uuid_hex_to_base64(request.id));
    roleUpdate.setName(request.name);
    roleUpdate.setMulti(request.multi);
    roleUpdate.setIpLock(request.ip_lock);
    roleUpdate.setAccessDuration(request.access_duration);
    roleUpdate.setRefreshDuration(request.refresh_duration);
    return client.updateRole(roleUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete a role
 * @param {ServerConfig} server server configuration: address, token
 * @param {RoleId} request role uuid: id
 * @returns {Promise<{}>} delete response
 */
async function delete_role(server, request) {
    const client = new pb_role.RoleServicePromiseClient(server.address, null, null);
    const roleId = new pb_role.RoleId();
    roleId.setId(uuid_hex_to_base64(request.id));
    return client.deleteRole(roleId, metadata(server))
        .then(response => response.toObject());
}

/**
 * Add a role access
 * @param {ServerConfig} server server configuration: address, token
 * @param {RoleAccess} request role access: id, procedure_id
 * @returns {Promise<{}>} change response
 */
async function add_role_access(server, request) {
    const client = new pb_role.RoleServicePromiseClient(server.address, null, null);
    const roleAccess = new pb_role.RoleAccess();
    roleAccess.setId(uuid_hex_to_base64(request.id));
    roleAccess.setProcedureId(uuid_hex_to_base64(request.procedure_id));
    return client.addRoleAccess(roleAccess, metadata(server))
        .then(response => response.toObject());
}

/**
 * Remove a role access
 * @param {ServerConfig} server server configuration: address, token
 * @param {RoleAccess} request role access: id, procedure_id
 * @returns {Promise<{}>} change response
 */
async function remove_role_access(server, request) {
    const client = new pb_role.RoleServicePromiseClient(server.address, null, null);
    const roleAccess = new pb_role.RoleAccess();
    roleAccess.setId(uuid_hex_to_base64(request.id));
    roleAccess.setProcedureId(uuid_hex_to_base64(request.procedure_id));
    return client.removeRoleAccess(roleAccess, metadata(server))
        .then(response => response.toObject());
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} ApiId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} UserId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} UserIds
 * @property {Uuid[]} ids
 */

/**
 * @param {*} r 
 * @returns {UserId}
 */
function get_user_id(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
 * @typedef {Object} UserName
 * @property {string} name
 */

/**
 * @typedef {Object} RoleId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} UserOption
 * @property {?Uuid} api_id
 * @property {?Uuid} role_id
 * @property {?name} name
 */

/**
 * @typedef {Object} UserRoleSchema
 * @property {Uuid} api_id
 * @property {string} role
 * @property {boolean} multi
 * @property {boolean} ip_lock
 * @property {number} access_duration
 * @property {number} refresh_duration
 * @property {string} access_key
 */

/**
 * @typedef {Object} UserSchema
 * @property {Uuid} id
 * @property {string} name
 * @property {string} email
 * @property {string} phone
 * @property {string} password
 * @property {UserRoleSchema[]} roles
 */

/**
 * @param {*} r 
 * @returns {UserRoleSchema}
 */
function get_user_role_schema(r) {
    return {
        api_id: base64_to_uuid_hex(r.apiId),
        role: r.role,
        multi: r.multi,
        ip_lock: r.ipLock,
        access_duration: r.accessDuration,
        refresh_duration: r.refreshDuration,
        access_key: r.accessKey
    };
}

/**
 * @param {*} r 
 * @returns {UserSchema}
 */
function get_user_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        name: r.name,
        email: r.email,
        phone: r.phone,
        password: r.password,
        roles: r.rolesList.map((v) => {return get_user_role_schema(v)})
    };
}

/**
 * @param {*} r 
 * @returns {UserSchema[]}
 */
function get_user_schema_vec(r) {
    return r.map((v) => {return get_user_schema(v)});
}

/**
 * @typedef {Object} UserUpdate
 * @property {Uuid} id
 * @property {?string} name
 * @property {?string} email
 * @property {?string} phone
 * @property {?string} password
 */

/**
 * @typedef {Object} UserRole
 * @property {Uuid} user_id
 * @property {Uuid} role_id
 */


/**
 * Read a user by uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {UserId} request user uuid: id
 * @returns {Promise<UserSchema>} user schema: id, name, email, phone, password, roles
 */
async function read_user(server, request) {
    const client = new pb_user.UserServicePromiseClient(server.address, null, null);
    const userId = new pb_user.UserId();
    userId.setId(uuid_hex_to_base64(request.id));
    return client.readUser(userId, metadata(server))
        .then(response => get_user_schema(response.toObject().result));
}

/**
 * Read a user by name
 * @param {ServerConfig} server server configuration: address, token
 * @param {UserName} request user name: name
 * @returns {Promise<UserSchema>} user schema: id, name, email, phone, password, roles
 */
async function read_user_by_name(server, request) {
    const client = new pb_user.UserServicePromiseClient(server.address, null, null);
    const userName = new pb_user.UserName();
    userName.setName(request.name);
    return client.readUserByName(userName, metadata(server))
        .then(response => get_user_schema(response.toObject().result));
}

/**
 * Read users by uuid list
 * @param {ServerConfig} server server configuration: address, token
 * @param {UserIds} request user uuid list: ids
 * @returns {Promise<UserSchema[]>} user schema: id, name, email, phone, password, roles
 */
async function list_user_by_ids(server, request) {
    const client = new pb_user.UserServicePromiseClient(server.address, null, null);
    const userIds = new pb_user.UserIds();
    userIds.setIdsList(request.ids.map((id) => uuid_hex_to_base64(id)));
    return client.listUserByIds(userIds, metadata(server))
        .then(response => get_user_schema_vec(response.toObject().resultsList));
}

/**
 * Read users by api uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {ApiId} request api uuid: id
 * @returns {Promise<UserSchema[]>} user schema: id, name, email, phone, password, roles
 */
async function list_user_by_api(server, request) {
    const client = new pb_user.UserServicePromiseClient(server.address, null, null);
    const apiId = new pb_user.ApiId();
    apiId.setId(uuid_hex_to_base64(request.id));
    return client.listUserByApi(apiId, metadata(server))
        .then(response => get_user_schema_vec(response.toObject().resultsList));
}

/**
 * Read users by role uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {RoleId} request role uuid: id
 * @returns {Promise<UserSchema[]>} user schema: id, name, email, phone, password, roles
 */
async function list_user_by_role(server, request) {
    const client = new pb_user.UserServicePromiseClient(server.address, null, null);
    const roleId = new pb_user.RoleId();
    roleId.setId(uuid_hex_to_base64(request.id));
    return client.listUserByRole(roleId, metadata(server))
        .then(response => get_user_schema_vec(response.toObject().resultsList));
}

/**
 * Read users by name
 * @param {ServerConfig} server server configuration: address, token
 * @param {UserName} request user name: name
 * @returns {Promise<UserSchema[]>} user schema: id, name, email, phone, password, roles
 */
async function list_user_by_name(server, request) {
    const client = new pb_user.UserServicePromiseClient(server.address, null, null);
    const userName = new pb_user.UserName();
    userName.setName(request.name);
    return client.listUserByName(userName, metadata(server))
        .then(response => get_user_schema_vec(response.toObject().resultsList));
}

/**
 * Read users with options
 * @param {ServerConfig} server server configuration: address, token
 * @param {UserOption} request user option: api_id, role_id, name
 * @returns {Promise<UserSchema[]>} user schema: id, name, email, phone, password, roles
 */
async function list_user_option(server, request) {
    const client = new pb_user.UserServicePromiseClient(server.address, null, null);
    const userOption = new pb_user.UserOption();
    if (request.api_id) {
        userOption.setApiId(uuid_hex_to_base64(request.api_id));
    }
    if (request.role_id) {
        userOption.setApiId(uuid_hex_to_base64(request.role_id));
    }
    userOption.setName(request.name);
    return client.listUserOption(userOption, metadata(server))
        .then(response => get_user_schema_vec(response.toObject().resultsList));
}

/**
 * Create an user
 * @param {ServerConfig} server server configuration: address, token
 * @param {UserSchema} request user schema: id, name, email, phone, password
 * @returns {Promise<UserId>} user id: id
 */
async function create_user(server, request) {
    const client = new pb_user.UserServicePromiseClient(server.address, null, null);
    const userSchema = new pb_user.UserSchema();
    userSchema.setId(uuid_hex_to_base64(request.id));
    userSchema.setName(request.name);
    userSchema.setEmail(request.email);
    userSchema.setPhone(request.phone);
    userSchema.setPassword(request.password);
    return client.createUser(userSchema, metadata(server))
        .then(response => get_user_id(response.toObject()));
}

/**
 * Update an user
 * @param {ServerConfig} server server configuration: address, token
 * @param {UserUpdate} request user update: id, name, email, phone, password
 * @returns {Promise<{}>} update response
 */
async function update_user(server, request) {
    const client = new pb_user.UserServicePromiseClient(server.address, null, null);
    const userUpdate = new pb_user.UserUpdate();
    userUpdate.setId(uuid_hex_to_base64(request.id));
    userUpdate.setName(request.name);
    userUpdate.setEmail(request.email);
    userUpdate.setPhone(request.phone);
    userUpdate.setPassword(request.password);
    return client.updateUser(userUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete an user
 * @param {ServerConfig} server server configuration: address, token
 * @param {UserId} request user uuid: id
 * @returns {Promise<{}>} delete response
 */
async function delete_user(server, request) {
    const client = new pb_user.UserServicePromiseClient(server.address, null, null);
    const userId = new pb_user.UserId();
    userId.setId(uuid_hex_to_base64(request.id));
    return client.deleteUser(userId, metadata(server))
        .then(response => response.toObject());
}

/**
 * Add a role to user
 * @param {ServerConfig} server server configuration: address, token
 * @param {UserRole} request user role: user_id, role_id
 * @returns {Promise<{}>} change response
 */
async function add_user_role(server, request) {
    const client = new pb_user.UserServicePromiseClient(server.address, null, null);
    const userRole = new pb_user.UserRole();
    userRole.setUserId(uuid_hex_to_base64(request.user_id));
    userRole.setRoleId(uuid_hex_to_base64(request.role_id));
    return client.addUserRole(userRole, metadata(server))
        .then(response => response.toObject());
}

/**
 * Remove a role from user
 * @param {ServerConfig} server server configuration: address, token
 * @param {UserRole} request user role: user_id, role_id
 * @returns {Promise<{}>} change response
 */
async function remove_user_role(server, request) {
    const client = new pb_user.UserServicePromiseClient(server.address, null, null);
    const userRole = new pb_user.UserRole();
    userRole.setUserId(uuid_hex_to_base64(request.user_id));
    userRole.setRoleId(uuid_hex_to_base64(request.role_id));
    return client.removeUserRole(userRole, metadata(server))
        .then(response => response.toObject());
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} AccessId
 * @property {number} access_id
 */

/**
 * @typedef {Object} AuthToken
 * @property {string} auth_token
 */

/**
 * @typedef {Object} UserId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} TokenSchema
 * @property {number} access_id
 * @property {Uuid} user_id
 * @property {string} refresh_token
 * @property {string} auth_token
 * @property {Date} expire
 * @property {number[]|Uint8Array} ip
 */

/**
 * @param {*} r 
 * @returns {TokenSchema}
 */
function get_token_schema(r) {
    return {
        access_id: r.accessId,
        user_id: base64_to_uuid_hex(r.userId),
        refresh_token: r.refreshToken,
        auth_token: r.authToken,
        expire: new Date(r.expire / 1000),
        ip: base64_to_bytes(r.ip)
    };
}

/**
 * @param {*} r 
 * @returns {TokenSchema[]}
 */
function get_token_schema_vec(r) {
    return r.map((v) => {return get_token_schema(v)});
}

/**
 * @typedef {Object} AuthTokenCreate
 * @property {Uuid} user_id
 * @property {Date} expire
 * @property {number[]|Uint8Array} ip
 * @property {number} number
 */

/**
 * @typedef {Object} TokenUpdate
 * @property {?number} access_id
 * @property {?string} refresh_token
 * @property {?string} auth_token
 * @property {?Date} expire
 * @property {?number[]|Uint8Array} ip
 */

/**
 * @typedef {Object} TokenCreateResponse
 * @property {number} access_id
 * @property {string} refresh_token
 * @property {string} auth_token
 */

/**
 * @param {*} r 
 * @returns {TokenCreateResponse}
 */
function get_token_create_response(r) {
    return {
        access_id: r.accessId,
        refresh_token: r.refreshToken,
        auth_token: r.authToken,
    };
}

/**
 * @param {*} r 
 * @returns {TokenCreateResponse[]}
 */
function get_token_create_response_vec(r) {
    return r.map((v) => {return get_token_create_response(v)});
}

/**
 * @typedef {Object} TokenUpdateResponse
 * @property {string} refresh_token
 * @property {string} auth_token
 */

/**
 * @param {*} r 
 * @returns {TokenUpdateResponse}
 */
function get_token_update_response(r) {
    return {
        refresh_token: r.refreshToken,
        auth_token: r.authToken,
    };
}


/**
 * Read an access token by access id
 * @param {ServerConfig} server server configuration: address, token
 * @param {AccessId} request access id: access_id
 * @returns {Promise<TokenSchema>} token schema: access_id, user_id, refresh_token, auth_token, expire, ip
 */
async function read_access_token(server, request) {
    const client = new pb_token.TokenServicePromiseClient(server.address, null, null);
    const accessId = new pb_token.AccessId();
    accessId.setAccessId(request.access_id);
    return client.readAccessToken(accessId, metadata(server))
        .then(response => get_token_schema(response.toObject().result));
}

/**
 * Read tokens by auth token
 * @param {ServerConfig} server server configuration: address, token
 * @param {AuthToken} request auth token: auth_token
 * @returns {Promise<TokenSchema[]>} token schema: access_id, user_id, refresh_token, auth_token, expire, ip
 */
async function list_auth_token(server, request) {
    const client = new pb_token.TokenServicePromiseClient(server.address, null, null);
    const authToken = new pb_token.AuthToken();
    authToken.setAuthToken(request.auth_token);
    return client.listAuthToken(authToken, metadata(server))
        .then(response => get_token_schema_vec(response.toObject().resultsList));
}

/**
 * Read tokens by user id
 * @param {ServerConfig} server server configuration: address, token
 * @param {UserId} request user id: id
 * @returns {Promise<TokenSchema[]>} token schema: access_id, user_id, refresh_token, auth_token, expire, ip
 */
async function list_token_by_user(server, request) {
    const client = new pb_token.TokenServicePromiseClient(server.address, null, null);
    const userId = new pb_token.UserId();
    userId.setUserId(uuid_hex_to_base64(request.id));
    return client.listTokenByUser(userId, metadata(server))
        .then(response => get_token_schema_vec(response.toObject().resultsList));
}

/**
 * Create an access token
 * @param {ServerConfig} server server configuration: address, token
 * @param {TokenSchema} request token schema: user_id, auth_token, expire, ip
 * @returns {Promise<TokenCreateResponse>} create response: access_id, refresh_token, auth_token
 */
async function create_access_token(server, request) {
    const client = new pb_token.TokenServicePromiseClient(server.address, null, null);
    const tokenSchema = new pb_token.TokenSchema();
    tokenSchema.setUserId(uuid_hex_to_base64(request.user_id));
    tokenSchema.setAuthToken(request.auth_token);
    tokenSchema.setExpire(request.expire.valueOf() * 1000);
    tokenSchema.setIp(bytes_to_base64(request.ip));
    return client.createAccessToken(tokenSchema, metadata(server))
        .then(response => get_token_create_response(response.toObject()));
}

/**
 * Create tokens with shared auth token
 * @param {ServerConfig} server server configuration: address, token
 * @param {AuthTokenCreate} request token schema: user_id, expire, ip, number
 * @returns {Promise<TokenCreateResponse[]>} create response: access_id, refresh_token, auth_token
 */
async function create_auth_token(server, request) {
    const client = new pb_token.TokenServicePromiseClient(server.address, null, null);
    const authTokenCreate = new pb_token.AuthTokenCreate();
    authTokenCreate.setUserId(uuid_hex_to_base64(request.user_id));
    authTokenCreate.setExpire(request.expire.valueOf() * 1000);
    authTokenCreate.setIp(bytes_to_base64(request.ip));
    authTokenCreate.setNumber(request.number);
    return client.createAuthToken(authTokenCreate, metadata(server))
        .then(response => get_token_create_response_vec(response.toObject().tokensList));
}

/**
 * Update an access token
 * @param {ServerConfig} server server configuration: address, token
 * @param {TokenUpdate} request token update: access_id, expire, ip
 * @returns {Promise<TokenUpdateResponse>} update response: refresh_token, auth_token
 */
async function update_access_token(server, request) {
    const client = new pb_token.TokenServicePromiseClient(server.address, null, null);
    const tokenUpdate = new pb_token.TokenUpdate();
    tokenUpdate.setAccessId(request.access_id);
    if (request.expire instanceof Date) {
        tokenUpdate.setExpire(request.expire.valueOf() * 1000);
    }
    if (request.ip) {
        tokenUpdate.setIp(bytes_to_base64(request.ip));
    }
    return client.updateAccessToken(tokenUpdate, metadata(server))
        .then(response => get_token_update_response(response.toObject()));
}

/**
 * Update all tokens with shared auth token
 * @param {ServerConfig} server server configuration: address, token
 * @param {TokenUpdate} request token update: auth_token, expire, ip
 * @returns {Promise<TokenUpdateResponse>} update response: refresh_token, auth_token
 */
async function update_auth_token(server, request) {
    const client = new pb_token.TokenServicePromiseClient(server.address, null, null);
    const tokenUpdate = new pb_token.TokenUpdate();
    tokenUpdate.setAuthToken(request.auth_token);
    if (request.expire instanceof Date) {
        tokenUpdate.setExpire(request.expire.valueOf() * 1000);
    }
    if (request.ip) {
        tokenUpdate.setIp(bytes_to_base64(request.ip));
    }
    return client.updateAuthToken(tokenUpdate, metadata(server))
        .then(response => get_token_update_response(response.toObject()));
}

/**
 * Delete an access token by access id
 * @param {ServerConfig} server server configuration: address, token
 * @param {AccessId} request access id: access_id
 * @returns {Promise<{}>} delete response
 */
async function delete_access_token(server, request) {
    const client = new pb_token.TokenServicePromiseClient(server.address, null, null);
    const accessId = new pb_token.AccessId();
    accessId.setAccessId(request.access_id);
    return client.deleteAccessToken(accessId, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete tokens by auth token
 * @param {ServerConfig} server server configuration: address, token
 * @param {AuthToken} request auth token: auth_token
 * @returns {Promise<{}>} delete response
 */
async function delete_auth_token(server, request) {
    const client = new pb_token.TokenServicePromiseClient(server.address, null, null);
    const authToken = new pb_token.AuthToken();
    authToken.setAuthToken(request.auth_token);
    return client.deleteAuthToken(authToken, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete tokens by user id
 * @param {ServerConfig} server server configuration: address, token
 * @param {UserId} request user id: id
 * @returns {Promise<{}>} delete response
 */
async function delete_token_by_user(server, request) {
    const client = new pb_token.TokenServicePromiseClient(server.address, null, null);
    const userId = new pb_token.UserId();
    userId.setUserId(uuid_hex_to_base64(request.id));
    return client.deleteTokenByUser(userId, metadata(server))
        .then(response => response.toObject());
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} UserKeyResponse
 * @property {string} public_key
 */

/**
 * @typedef {Object} UserLoginRequest
 * @property {string} username
 * @property {string} password
 */

/**
 * @typedef {Object} AccessTokenMap
 * @property {Uuid} api_id
 * @property {string} access_token
 * @property {string} refresh_token
 */

/**
 * @param {*} r 
 * @returns {AccessTokenMap}
 */
function get_access_token(r) {
    return {
        api_id: base64_to_uuid_hex(r.apiId),
        access_token: r.accessToken,
        refresh_token: r.refreshToken
    };
}

/**
 * @typedef {Object} UserLoginResponse
 * @property {Uuid} user_id
 * @property {string} auth_token
 * @property {AccessTokenMap[]} access_tokens
 */

/**
 * @param {*} r 
 * @returns {UserLoginResponse}
 */
function get_login_response(r) {
    return {
        user_id: base64_to_uuid_hex(r.userId),
        auth_token: r.authToken,
        access_tokens: r.accessTokensList.map((v) => {return get_access_token(v)})
    };
}

/**
 * @typedef {Object} UserRefreshRequest
 * @property {Uuid} api_id
 * @property {string} access_token
 * @property {string} refresh_token
 */

/**
 * @typedef {Object} UserRefreshResponse
 * @property {string} access_token
 * @property {string} refresh_token
 */

/**
 * @param {*} r 
 * @returns {UserRefreshResponse}
 */
function get_refresh_response(r) {
    return {
        access_token: r.accessToken,
        refresh_token: r.refreshToken
    };
}

/**
 * @typedef {Object} UserLogoutRequest
 * @property {Uuid} user_id
 * @property {string} auth_token
 */

/**
 * Import a PEM encoded RSA public key, to use for RSA-OAEP / RSASSA-PKCS1-v1_5 encryption
 * @param {string} pem 
 * @returns 
 */
function importKey(pem) {
    try {
        const binaryDerString = window.atob(pem);
        const binaryDer = string_to_array_buffer(binaryDerString);
        return window.crypto.subtle.importKey(
            "spki",
            binaryDer,
            {
                name: "RSA-OAEP",
                hash: "SHA-256"
            },
            true,
            ["encrypt"]
        );
    } catch {
        return null;
    }
}

/**
 * Get the encoded message, encrypt it and display a representation of the ciphertext
 * @param {string} message 
 * @param {CryptoKey} encryptionKey 
 * @returns 
 */
async function encryptMessage(message, encryptionKey)
{
    try {
        const enc = new TextEncoder();
        const encoded = enc.encode(message);
        const buf = await window.crypto.subtle.encrypt(
            {
                name: "RSA-OAEP"
            },
            encryptionKey,
            encoded
        );
        const chars = String.fromCharCode.apply(null, new Uint8Array(buf));
        return btoa(chars);
    } catch {
        return null;
    }
}


/**
 * Get user login key
 * @param {ServerConfig} server server configuration: address, token
 * @param {} request empty object
 * @return {Promise<UserKeyResponse>} user key: public_key
 */
async function user_login_key(server, request) {
    const client = new pb_auth.AuthServicePromiseClient(server.address, null, null);
    const userKeyRequest = new pb_auth.UserKeyRequest();
    return client.userLoginKey(userKeyRequest, metadata(server))
        .then(response => response.toObject());
}

/**
 * User login
 * @param {ServerConfig} server server configuration: address, token
 * @param {UserLoginRequest} request user login request: username, password
 * @return {Promise<UserLoginResponse>} user login response: user_id, auth_token, access_tokens
 */
async function user_login(server, request) {
    const client = new pb_auth.AuthServicePromiseClient(server.address, null, null);
    const userKeyRequest = new pb_auth.UserKeyRequest();
    const userLoginRequest = new pb_auth.UserLoginRequest();
    userLoginRequest.setUsername(request.username);
    const key = await client.userLoginKey(userKeyRequest, metadata(server))
        .then(response => response.toObject().publicKey);
    const pubkey = await importKey(key);
    const ciphertext = await encryptMessage(request.password, pubkey);
    userLoginRequest.setPassword(ciphertext);
    return client.userLogin(userLoginRequest, metadata(server))
        .then(response => get_login_response(response.toObject()));
}

/**
 * Refresh user token
 * @param {ServerConfig} server server configuration: address, token
 * @param {UserRefreshRequest} request user refresh request: api_id, access_token, refresh_token
 * @return {Promise<UserRefreshResponse>} user refresh response: access_token, refresh_token
 */
async function user_refresh(server, request) {
    const client = new pb_auth.AuthServicePromiseClient(server.address, null, null);
    const userRefreshRequest = new pb_auth.UserRefreshRequest();
    userRefreshRequest.setApiId(uuid_hex_to_base64(request.api_id));
    userRefreshRequest.setAccessToken(request.access_token);
    userRefreshRequest.setRefreshToken(request.refresh_token);
    return client.userRefresh(userRefreshRequest, metadata(server))
        .then(response => get_refresh_response(response.toObject()));
}

/**
 * User logout
 * @param {ServerConfig} server server configuration: address, token
 * @param {UserLogoutRequest} request user logout request: user_id, auth_token
 * @return {Promise<{}>} user logout response
 */
async function user_logout(server, request) {
    const client = new pb_auth.AuthServicePromiseClient(server.address, null, null);
    const userLogoutRequest = new pb_auth.UserLogoutRequest();
    userLogoutRequest.setUserId(uuid_hex_to_base64(request.user_id));
    userLogoutRequest.setAuthToken(request.auth_token);
    return client.userLogout(userLogoutRequest, metadata(server))
        .then(response => response.toObject());
}

var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    add_role_access: add_role_access,
    add_user_role: add_user_role,
    create_access_token: create_access_token,
    create_api: create_api,
    create_auth_token: create_auth_token,
    create_procedure: create_procedure,
    create_role: create_role,
    create_user: create_user,
    delete_access_token: delete_access_token,
    delete_api: delete_api,
    delete_auth_token: delete_auth_token,
    delete_procedure: delete_procedure,
    delete_role: delete_role,
    delete_token_by_user: delete_token_by_user,
    delete_user: delete_user,
    list_api_by_category: list_api_by_category,
    list_api_by_ids: list_api_by_ids,
    list_api_by_name: list_api_by_name,
    list_api_option: list_api_option,
    list_auth_token: list_auth_token,
    list_procedure_by_api: list_procedure_by_api,
    list_procedure_by_ids: list_procedure_by_ids,
    list_procedure_by_name: list_procedure_by_name,
    list_procedure_option: list_procedure_option,
    list_role_by_api: list_role_by_api,
    list_role_by_ids: list_role_by_ids,
    list_role_by_name: list_role_by_name,
    list_role_by_user: list_role_by_user,
    list_role_option: list_role_option,
    list_token_by_user: list_token_by_user,
    list_user_by_api: list_user_by_api,
    list_user_by_ids: list_user_by_ids,
    list_user_by_name: list_user_by_name,
    list_user_by_role: list_user_by_role,
    list_user_option: list_user_option,
    read_access_token: read_access_token,
    read_api: read_api,
    read_api_by_name: read_api_by_name,
    read_procedure: read_procedure,
    read_procedure_by_name: read_procedure_by_name,
    read_role: read_role,
    read_role_by_name: read_role_by_name,
    read_user: read_user,
    read_user_by_name: read_user_by_name,
    remove_role_access: remove_role_access,
    remove_user_role: remove_user_role,
    update_access_token: update_access_token,
    update_api: update_api,
    update_auth_token: update_auth_token,
    update_procedure: update_procedure,
    update_role: update_role,
    update_user: update_user,
    user_login: user_login,
    user_login_key: user_login_key,
    user_logout: user_logout,
    user_refresh: user_refresh
});

/**
 * @enum {number}
 */
const DataType = {
    NULL: 0,
    I8: 1,
    I16: 2,
    I32: 3,
    I64: 4,
    I128: 5,
    U8: 6,
    U16: 7,
    U32: 8,
    U64: 9,
    U128: 10,
    F32: 12,
    F64: 13,
    BOOL: 15,
    CHAR: 16,
    STRING: 17,
    BYTES: 18
};

/**
 * @param {number|string} type
 * @returns {number}
 */
function set_data_type(type) {
    if (typeof type === "number") {
        if (type >= 0 && type <= 12) {
            return type;
        }
    }
    else if (typeof type === "string") {
        switch (type.toUpperCase()) {
            case "I8": return DataType.I8;
            case "I16": return DataType.I16;
            case "I32": return DataType.I32;
            case "I64": return DataType.I64;
            case "I128": return DataType.I128;
            case "U8": return DataType.U8;
            case "U16": return DataType.U16;
            case "U32": return DataType.U32;
            case "U64": return DataType.U64;
            case "U128": return DataType.U128;
            case "F32": return DataType.F32;
            case "F64": return DataType.F64;
            case "BOOL": return DataType.BOOL;
            case "CHAR": return DataType.CHAR;
            case "STRING": return DataType.STRING;
            case "BYTES": return DataType.BYTES;
        }
    }
    return DataType.NULL;
}

/**
 * @param {number} type 
 * @returns {string}
 */
function get_data_type(type) {
    switch (type) {
        case DataType.I8: return "I8";
        case DataType.I16: return "I16";
        case DataType.I32: return "I32";
        case DataType.I64: return "I64";
        case DataType.I128: return "I128";
        case DataType.U8: return "U8";
        case DataType.U16: return "U16";
        case DataType.U32: return "U32";
        case DataType.U64: return "U64";
        case DataType.U128: return "U128";
        case DataType.F32: return "F32";
        case DataType.F64: return "F64";
        case DataType.BOOL: return "BOOL";
        case DataType.CHAR: return "CHAR";
        case DataType.STRING: return "STRING";
        case DataType.BYTES: return "BYTES";
    }
    return "NULL";
}

/**
 * @param {string} base64 
 * @returns {ArrayBufferLike}
 */
function base64_to_array_buffer(base64) {
    let binaryString = atob(base64);
    let bytes = new Uint8Array(binaryString.length);
    for (let i=0; i<binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
}

/**
 * @param {ArrayBufferLike} buffer 
 * @returns {string}
 */
function array_buffer_to_base64(buffer) {
    let bytes = new Uint8Array(buffer);
    let binaryString = String.fromCharCode.apply(null, bytes);
    return btoa(binaryString);
}

/**
 * @param {string|ArrayBufferLike} base64 
 * @param {number} type 
 * @returns {number|bigint|string|Uint8Array|boolean|null}
 */
function get_data_value(base64, type) {
    const buffer = base64_to_array_buffer(base64);
    const array = new Uint8Array(buffer);
    const view = new DataView(buffer);
    switch (type) {
        case DataType.I8: 
            if (view.byteLength >= 1) return view.getInt8();
        case DataType.I16: 
            if (view.byteLength >= 2) return view.getInt16();
        case DataType.I32: 
            if (view.byteLength >= 4) return view.getInt32();
        case DataType.I64: 
            if (view.byteLength >= 8) return view.getBigInt64();
        case DataType.I128: 
            if (view.byteLength >= 8) return view.getBigInt64();
        case DataType.U8: 
            if (view.byteLength >= 1) return view.getUint8();
        case DataType.U16: 
            if (view.byteLength >= 2) return view.getUint16();
        case DataType.U32: 
            if (view.byteLength >= 4) return view.getUint32();
        case DataType.U64: 
            if (view.byteLength >= 8) return view.getBigUint64();
        case DataType.U128: 
            if (view.byteLength >= 8) return view.getBigUint64();
        case DataType.F32:
            if (view.byteLength >= 4) return view.getFloat32();
        case DataType.F64:
            if (view.byteLength >= 8) return view.getFloat64();
        case DataType.BOOL:
            if (view.byteLength >= 1) return Boolean(view.getUint8(offset));
        case DataType.CHAR:
            if (view.byteLength >= 1) return String.fromCharCode(view.getUint8(offset));
        case DataType.STRING:
            return new TextDecoder("utf-8").decode(array);
        case DataType.BYTES:
            return array;
    }
    return null;
}

/**
 * @param {string} base64 
 * @param {number[]} types 
 * @returns {(number|bigint|string|Uint8Array|boolean|null)[]}
 */
function get_data_values(base64, types) {
    const buffer = base64_to_array_buffer(base64);
    let index = 0;
    let values = [];
    for (const type of types) {
        let length = 0;
        if (type == DataType.I8 || type == DataType.U8 || type == DataType.CHAR || type == DataType.BOOL) {
            length = 1;
        }
        else if (type == DataType.I16 || type == DataType.U16) {
            length = 2;
        }
        else if (type == DataType.I32 || type == DataType.U32 || type == DataType.F32) {
            length = 4;
        }
        else if (type == DataType.I64 || type == DataType.U64 || type == DataType.F64) {
            length = 8;
        }
        else if (type == DataType.I128 || type == DataType.U128) {
            length = 16;
        }
        else if (type == DataType.STRING || type == DataType.BYTES) {
            length = 1;
            if (index < buffer.byteLength) {
                const view = new DataView(buffer.slice(index));
                length = view.getUint8();
                index += 1;
            }
        }
        if (index + length > buffer.byteLength) break;
        const value = get_data_value(array_buffer_to_base64(buffer.slice(index, index + length)), type);
        values.push(value);
        index += length;
    }
    return values;
}

/**
 * @param {number|bigint|string|Uint8Array|boolean} value
 */
function set_data_value(value) {
    let base64 = "";
    let type = DataType.NULL;
    if (typeof value == "number") {
        if (Number.isInteger(value)) {
            const buffer = new ArrayBuffer(4);
            const view = new DataView(buffer);
            view.setInt32(0, value);
            type = DataType.I32;
            base64 += array_buffer_to_base64(view.buffer);
        } else {
            const buffer = new ArrayBuffer(8);
            const view = new DataView(buffer);
            view.setFloat64(0, value);
            type = DataType.F64;
            base64 += array_buffer_to_base64(view.buffer);
        }
    }
    if (typeof value == "bigint") {
        const buffer = new ArrayBuffer(8);
        const view = new DataView(buffer);
        view.setBigInt64(0, value);
        type = DataType.I64;
        base64 += array_buffer_to_base64(view.buffer);
    }
    else if (typeof value == "string") {
        if (value.length == 1) {
            type = DataType.CHAR;
            base64 += btoa(value);
        }
        else {
            type = DataType.STRING;
            let array = new Uint8Array(value.length);
            array.set(new TextEncoder("utf-8").encode(value));
            base64 += array_buffer_to_base64(array.buffer);
        }
    }
    else if (value instanceof Uint8Array) {
        type = DataType.BYTES;
        base64 += array_buffer_to_base64(value.buffer);
    }
    else if (typeof value == "boolean") {
        type = DataType.BOOL;
        base64 += btoa(String.fromCharCode(value));
    }
    return {
        bytes: base64,
        type: type
    }
}

/**
 * @param {(number|bigint|string|Uint8Array|boolean)[]} values
 */
function set_data_values(values) {
    if (values === undefined) {
        return {
            bytes: "",
            types: []
        };
    }
    let arrays = new Uint8Array();
    let types = [];
    for (const value of values) {
        let data_value = set_data_value(value);
        if ((typeof value == "string" && value.length != 1) || value instanceof Uint8Array) {
            let len = new Uint8Array([value.length % 256]);
            let combine = new Uint8Array(arrays.byteLength + 1);
            combine.set(arrays);
            combine.set(len, arrays.byteLength);
            arrays = combine;
        }
        let array = new Uint8Array(base64_to_array_buffer(data_value.bytes));
        let combine = new Uint8Array(arrays.byteLength + array.byteLength);
        combine.set(arrays);
        combine.set(array, arrays.byteLength);
        arrays = combine;
        types.push(data_value.type);
    }
    return {
        bytes: array_buffer_to_base64(arrays.buffer),
        types: types
    };
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} ModelId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} ModelIds
 * @property {Uuid[]} ids
 */

/**
 * @param {*} r 
 * @returns {ModelId}
 */
function get_model_id(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
 * @typedef {Object} ModelName
 * @property {string} name
 */

/**
 * @typedef {Object} ModelCategory
 * @property {string} category
 */

/**
 * @typedef {Object} ModelOption
 * @property {?Uuid} type_id
 * @property {?string} name
 * @property {?string} category
 */

/**
 * @typedef {Object} TypeId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} ModelSchema
 * @property {Uuid} id
 * @property {string} category
 * @property {string} name
 * @property {string} description
 * @property {number[]|string[]} data_type
 * @property {ModelConfigSchema[][]} configs
 */

/**
 * @param {*} r 
 * @returns {ModelSchema}
 */
function get_model_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        category: r.category,
        name: r.name,
        description: r.description,
        data_type: r.dataTypeList.map((v) => { return get_data_type(v) }),
        configs: r.configsList.map((v) => { return get_model_config_schema_vec(v.configsList) })
    };
}

/**
 * @param {*} r 
 * @returns {ModelSchema[]}
 */
function get_model_schema_vec(r) {
    return r.map((v) => {return get_model_schema(v)});
}

/**
 * @typedef {Object} ModelUpdate
 * @property {Uuid} id
 * @property {?string} category
 * @property {?string} name
 * @property {?string} description
 * @property {?number[]|string[]} data_type
 */

/**
 * @typedef {Object} ModelConfigId
 * @property {number} id
 */

/**
 * @param {*} r 
 * @returns {ModelConfigId}
 */
function get_model_config_id(r) {
    return {
        id: r.id
    };
}

/**
 * @typedef {Object} ModelConfigSchema
 * @property {number} id
 * @property {Uuid} model_id
 * @property {number} index
 * @property {string} name
 * @property {number|bigint|string|Uint8Array|boolean} value
 * @property {string} category
 */

/**
 * @param {*} r 
 * @returns {ModelConfigSchema}
 */
function get_model_config_schema(r) {
    return {
        id: r.id,
        model_id: base64_to_uuid_hex(r.modelId),
        index: r.index,
        name: r.name,
        value: get_data_value(r.configBytes, r.configType),
        category: r.category
    };
}

/**
 * @param {*} r 
 * @returns {ModelConfigSchema[]}
 */
function get_model_config_schema_vec(r) {
    return r.map((v) => {return get_model_config_schema(v)});
}

/**
 * @typedef {Object} ModelConfigUpdate
 * @property {number} id
 * @property {?string} name
 * @property {?number|string} value
 * @property {?string} category
 */


/**
 * Read a model by uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {ModelId} request model uuid: id
 * @returns {Promise<ModelSchema>} model schema: id, category, name, description, data_type, configs
 */
async function read_model(server, request) {
    const client = new pb_model.ModelServicePromiseClient(server.address, null, null);
    const modelId = new pb_model.ModelId();
    modelId.setId(uuid_hex_to_base64(request.id));
    return client.readModel(modelId, metadata(server))
        .then(response => get_model_schema(response.toObject().result));
}

/**
 * Read models by uuid list
 * @param {ServerConfig} server server configuration: address, token
 * @param {ModelIds} request model uuid list: ids
 * @returns {Promise<ModelSchema[]>} model schema: id, category, name, description, data_type, configs
 */
async function list_model_by_ids(server, request) {
    const client = new pb_model.ModelServicePromiseClient(server.address, null, null);
    const modelIds = new pb_model.ModelIds();
    modelIds.setIdsList(request.ids.map((id) => uuid_hex_to_base64(id)));
    return client.listModelByIds(modelIds, metadata(server))
        .then(response => get_model_schema_vec(response.toObject().resultsList));
}

/**
 * Read models by name
 * @param {ServerConfig} server server configuration: address, token
 * @param {ModelName} request model name: name
 * @returns {Promise<ModelSchema[]>} model schema: id, category, name, description, data_type, configs
 */
async function list_model_by_name(server, request) {
    const client = new pb_model.ModelServicePromiseClient(server.address, null, null);
    const modelName = new pb_model.ModelName();
    modelName.setName(request.name);
    return client.listModelByName(modelName, metadata(server))
        .then(response => get_model_schema_vec(response.toObject().resultsList));
}

/**
 * Read models by category
 * @param {ServerConfig} server server configuration: address, token
 * @param {ModelCategory} request model category: category
 * @returns {Promise<ModelSchema[]>} model schema: id, category, name, description, data_type, configs
 */
async function list_model_by_category(server, request) {
    const client = new pb_model.ModelServicePromiseClient(server.address, null, null);
    const modelCategory = new pb_model.ModelCategory();
    modelCategory.setCategory(request.category);
    return client.listModelByCategory(modelCategory, metadata(server))
        .then(response => get_model_schema_vec(response.toObject().resultsList));
}

/**
 * Read models with select options
 * @param {ServerConfig} server server configuration: address, token
 * @param {ModelOption} request model select option: type_id, name, category
 * @returns {Promise<ModelSchema[]>} model schema: id, category, name, description, data_type, configs
 */
async function list_model_option(server, request) {
    const client = new pb_model.ModelServicePromiseClient(server.address, null, null);
    const modelOption = new pb_model.ModelOption();
    if (request.type_id) {
        modelOption.setTypeId(uuid_hex_to_base64(request.type_id));
    }
    modelOption.setName(request.name);
    modelOption.setCategory(request.category);
    return client.listModelOption(modelOption, metadata(server))
        .then(response => get_model_schema_vec(response.toObject().resultsList));
}

/**
 * Read models by type
 * @param {ServerConfig} server server configuration: address, token
 * @param {TypeId} request type uuid: id
 * @returns {Promise<ModelSchema[]>} model schema: id, category, name, description, data_type, configs
 */
async function list_model_by_type(server, request) {
    const client = new pb_model.ModelServicePromiseClient(server.address, null, null);
    const typeId = new pb_model.TypeId();
    typeId.setId(uuid_hex_to_base64(request.id));
    return client.listModelByType(modelNameCategory, metadata(server))
        .then(response => get_model_schema_vec(response.toObject().resultsList));
}

/**
 * Create a model
 * @param {ServerConfig} server server configuration: address, token
 * @param {ModelSchema} request model schema: id, data_type, category, name, description
 * @returns {Promise<ModelId>} model id: id
 */
async function create_model(server, request) {
    const client = new pb_model.ModelServicePromiseClient(server.address, null, null);
    const modelSchema = new pb_model.ModelSchema();
    modelSchema.setId(uuid_hex_to_base64(request.id));
    modelSchema.setDataTypeList(request.data_type.map((v) => {return set_data_type(v)}));
    modelSchema.setCategory(request.category);
    modelSchema.setName(request.name);
    modelSchema.setDescription(request.description);
    return client.createModel(modelSchema, metadata(server))
        .then(response => get_model_id(response.toObject()));
}

/**
 * Update a model
 * @param {ServerConfig} server server configuration: address, token
 * @param {ModelUpdate} request model update: id, data_type, category, name, description
 * @returns {Promise<{}>} update response
 */
async function update_model(server, request) {
    const client = new pb_model.ModelServicePromiseClient(server.address, null, null);
    const modelUpdate = new pb_model.ModelUpdate();
    modelUpdate.setId(uuid_hex_to_base64(request.id));
    if (request.data_type) {
        modelUpdate.setDataTypeList(request.data_type.map((v) => {return set_data_type(v)}));
        modelUpdate.setDataTypeFlag(true);
    } else {
        modelUpdate.setDataTypeFlag(false);
    }
    modelUpdate.setCategory(request.category);
    modelUpdate.setName(request.name);
    modelUpdate.setDescription(request.description);
    return client.updateModel(modelUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete a model
 * @param {ServerConfig} server server configuration: address, token
 * @param {ModelId} request model uuid: id
 * @returns {Promise<{}>} delete response
 */
async function delete_model(server, request) {
    const client = new pb_model.ModelServicePromiseClient(server.address, null, null);
    const modelId = new pb_model.ModelId();
    modelId.setId(uuid_hex_to_base64(request.id));
    return client.deleteModel(modelId, metadata(server))
        .then(response => response.toObject());
}

/**
 * Read a model configuration by uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {ModelConfigId} request model config uuid: id
 * @returns {Promise<ModelConfigSchema>} model config schema: model_id, index, name, value, category
 */
async function read_model_config(server, request) {
    const client = new pb_model.ModelServicePromiseClient(server.address, null, null);
    const configId = new pb_model.ConfigId();
    configId.setId(request.id);
    return client.readModelConfig(configId, metadata(server))
        .then(response => get_model_config_schema(response.toObject().result));
}

/**
 * Read model configurations by model uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {ModelId} request model uuid: id
 * @returns {Promise<ModelConfigSchema[]>} model config schema: model_id, index, name, value, category
 */
async function list_model_config_by_model(server, request) {
    const client = new pb_model.ModelServicePromiseClient(server.address, null, null);
    const modelId = new pb_model.ModelId();
    modelId.setId(uuid_hex_to_base64(request.id));
    return client.listModelConfig(modelId, metadata(server))
        .then(response => get_model_config_schema_vec(response.toObject().resultsList));
}

/**
 * Create a model configuration
 * @param {ServerConfig} server server configuration: address, token
 * @param {ModelConfigSchema} request model config schema: model_id, index, name, value, category
 * @returns {Promise<ModelConfigId>} model config uuid: id
 */
async function create_model_config(server, request) {
    const client = new pb_model.ModelServicePromiseClient(server.address, null, null);
    const configSchema = new pb_model.ConfigSchema();
    configSchema.setModelId(uuid_hex_to_base64(request.model_id));
    configSchema.setIndex(request.index);
    configSchema.setName(request.name);
    const value = set_data_value(request.value);
    configSchema.setConfigBytes(value.bytes);
    configSchema.setConfigType(value.type);
    configSchema.setCategory(request.category);
    return client.createModelConfig(configSchema, metadata(server))
        .then(response => get_model_config_id(response.toObject()));
}

/**
 * Update a model configuration
 * @param {ServerConfig} server server configuration: address, token
 * @param {ModelConfigUpdate} request model config update: id, name, value, category
 * @returns {Promise<{}>} update response 
 */
async function update_model_config(server, request) {
    const client = new pb_model.ModelServicePromiseClient(server.address, null, null);
    const configUpdate = new pb_model.ConfigUpdate();
    configUpdate.setId(request.id);
    configUpdate.setName(request.name);
    const value = set_data_value(request.value);
    configUpdate.setConfigBytes(value.bytes);
    configUpdate.setConfigType(value.type);
    configUpdate.setCategory(request.category);
    return client.updateModelConfig(configUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete a model configuration
 * @param {ServerConfig} server server configuration: address, token
 * @param {ModelConfigId} request model config uuid: id
 * @returns {Promise<{}>} delete response 
 */
async function delete_model_config(server, request) {
    const client = new pb_model.ModelServicePromiseClient(server.address, null, null);
    const configId = new pb_model.ConfigId();
    configId.setId(request.id);
    return client.deleteModelConfig(configId, metadata(server))
        .then(response => response.toObject());
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} TypeId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} TypeIds
 * @property {Uuid[]} ids
 */

/**
 * @typedef {Object} TypeName
 * @property {string} name
 */

/**
 * @typedef {Object} TypeOption
 * @property {?string} name
 */

/**
 * @param {*} r 
 * @returns {TypeId}
 */
function get_type_id(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
 * @typedef {Object} TypeSchema
 * @property {Uuid} id
 * @property {string} name
 * @property {string} description
 * @property {Uuid[]} models
 */

/**
 * @param {*} r 
 * @returns {TypeSchema}
 */
function get_type_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        name: r.name,
        description: r.description,
        models: r.modelsList.map((v) => {return base64_to_uuid_hex(v)})
    };
}

/**
 * @param {*} r 
 * @returns {TypeSchema[]}
 */
function get_type_schema_vec(r) {
    return r.map((v) => {return get_type_schema(v)});
}

/**
 * @typedef {Object} TypeUpdate
 * @property {Uuid} id
 * @property {?string} name
 * @property {?string} description
 */

/**
 * @typedef {Object} TypeModel
 * @property {Uuid} id
 * @property {Uuid} model_id
 */


/**
 * Read a device type by uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {TypeId} request type uuid: id
 * @returns {Promise<TypeSchema>} type schema: id, name, description, models
 */
async function read_type(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const typeId = new pb_device.TypeId();
    typeId.setId(uuid_hex_to_base64(request.id));
    return client.readType(typeId, metadata(server))
        .then(response => get_type_schema(response.toObject().result));
}

/**
 * Read device types by uuid list
 * @param {ServerConfig} server server configuration: address, token
 * @param {TypeIds} request type uuid list: ids
 * @returns {Promise<TypeSchema[]>} type schema: id, name, description, models
 */
async function list_type_by_ids(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const typeIds = new pb_device.TypeIds();
    typeIds.setIdsList(request.ids.map((id) => uuid_hex_to_base64(id)));
    return client.listTypeByIds(typeIds, metadata(server))
        .then(response => get_type_schema_vec(response.toObject().resultsList));
}

/**
 * Read device types by name
 * @param {ServerConfig} server server configuration: address, token
 * @param {TypeName} request type name: name
 * @returns {Promise<TypeSchema[]>} type schema: id, name, description, models
 */
async function list_type_by_name(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const typeName = new pb_device.TypeName();
    typeName.setName(request.name);
    return client.listTypeByName(typeName, metadata(server))
        .then(response => get_type_schema_vec(response.toObject().resultsList));
}

/**
 * Read device types with select options
 * @param {ServerConfig} server server configuration: address, token
 * @param {TypeOption} request type select option: name
 * @returns {Promise<TypeSchema[]>} type schema: id, name, description, models
 */
async function list_type_option(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const typeOption = new pb_device.TypeOption();
    typeOption.setName(request.name);
    return client.listTypeOption(typeOption, metadata(server))
        .then(response => get_type_schema_vec(response.toObject().resultsList));
}

/**
 * Create a device type
 * @param {ServerConfig} server server configuration: address, token
 * @param {TypeSchema} request type schema: id, name, description
 * @returns {Promise<TypeId>} type uuid: id
 */
async function create_type(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const typeSchema = new pb_device.TypeSchema();
    typeSchema.setId(uuid_hex_to_base64(request.id));
    typeSchema.setName(request.name);
    typeSchema.setDescription(request.description);
    return client.createType(typeSchema, metadata(server))
        .then(response => get_type_id(response.toObject()));
}

/**
 * Update a device type
 * @param {ServerConfig} server server configuration: address, token
 * @param {TypeUpdate} request type update: id, name, description
 * @returns {Promise<{}>} update response
 */
async function update_type(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const typeUpdate = new pb_device.TypeUpdate();
    typeUpdate.setId(uuid_hex_to_base64(request.id));
    typeUpdate.setName(request.name);
    typeUpdate.setDescription(request.description);
    return client.updateType(typeUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete a device type
 * @param {ServerConfig} server server configuration: address, token
 * @param {TypeId} request type id: id
 * @returns {Promise<{}>} delete response
 */
async function delete_type(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const typeId = new pb_device.TypeId();
    typeId.setId(uuid_hex_to_base64(request.id));
    return client.deleteType(typeId, metadata(server))
        .then(response => response.toObject());
}

/**
 * Add model to a device type
 * @param {ServerConfig} server server configuration: address, token
 * @param {TypeModel} request type id: id, model_id
 * @returns {Promise<{}>} change response
 */
async function add_type_model(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const typeModel = new pb_device.TypeModel();
    typeModel.setId(uuid_hex_to_base64(request.id));
    typeModel.setModelId(uuid_hex_to_base64(request.model_id));
    return client.addTypeModel(typeModel, metadata(server))
        .then(response => response.toObject());
}

/**
 * Remove model from a device type
 * @param {ServerConfig} server server configuration: address, token
 * @param {TypeModel} request type id: id, model_id
 * @returns {Promise<{}>} change response
 */
async function remove_type_model(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const typeModel = new pb_device.TypeModel();
    typeModel.setId(uuid_hex_to_base64(request.id));
    typeModel.setModelId(uuid_hex_to_base64(request.model_id));
    return client.removeTypeModel(typeModel, metadata(server))
        .then(response => response.toObject());
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} DeviceId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} DeviceIds
 * @property {Uuid[]} ids
 */

/**
 * @param {*} r 
 * @returns {DeviceId}
 */
function get_device_id(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
 * @typedef {Object} SerialNumber
 * @property {string} serial_number
 */

/**
 * @typedef {Object} TypeId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} TypeSchema
 * @property {Uuid} id
 * @property {string} name
 * @property {string} description
 * @property {Uuid[]} models
 */

/**
 * @typedef {Object} DeviceName
 * @property {string} name
 */

/**
 * @typedef {Object} DeviceOption
 * @property {?Uuid} gateway_id
 * @property {?Uuid} type_id
 * @property {?string} name
 */

/**
 * @typedef {Object} DeviceSchema
 * @property {Uuid} id
 * @property {Uuid} gateway_id
 * @property {string} serial_number
 * @property {string} name
 * @property {string} description
 * @property {TypeSchema} device_type
 * @property {DeviceConfigSchema[]} configs
 */

/**
 * @param {*} r 
 * @returns {DeviceSchema}
 */
function get_device_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        gateway_id: base64_to_uuid_hex(r.gatewayId),
        serial_number: r.serialNumber,
        name: r.name,
        description: r.description,
        device_type: get_type_schema(r.deviceType),
        configs: get_device_config_schema_vec(r.configsList)
    };
}

/**
 * @param {*} r 
 * @returns {DeviceSchema[]}
 */
function get_device_schema_vec(r) {
    return r.map((v) => {return get_device_schema(v)});
}

/**
 * @typedef {Object} DeviceCreate
 * @property {Uuid} id
 * @property {Uuid} gateway_id
 * @property {string} serial_number
 * @property {string} name
 * @property {string} description
 * @property {Uuid} type_id
 */

/**
 * @typedef {Object} DeviceUpdate
 * @property {Uuid} id
 * @property {?Uuid} gateway_id
 * @property {?string} serial_number
 * @property {?string} name
 * @property {?string} description
 * @property {?Uuid} type_id
 */

/**
 * @typedef {Object} GatewayId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} GatewayIds
 * @property {Uuid[]} ids
 */

/**
 * @param {*} r 
 * @returns {GatewayId}
 */
function get_gateway_id(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
 * @typedef {Object} GatewayName
 * @property {string} name
 */

/**
 * @typedef {Object} GatewayOption
 * @property {?Uuid} type_id
 * @property {?string} name
 */

/**
 * @typedef {Object} GatewaySchema
 * @property {Uuid} id
 * @property {string} serial_number
 * @property {string} name
 * @property {string} description
 * @property {TypeSchema} gateway_type
 * @property {GatewayConfigSchema[]} configs
 */

/**
 * @param {*} r 
 * @returns {GatewaySchema}
 */
function get_gateway_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        serial_number: r.serialNumber,
        name: r.name,
        description: r.description,
        gateway_type: get_type_schema(r.gatewayType),
        configs: get_device_config_schema_vec(r.configsList)
    };
}

/**
 * @param {*} r 
 * @returns {GatewaySchema[]}
 */
function get_gateway_schema_vec(r) {
    return r.map((v) => {return get_gateway_schema(v)});
}

/**
 * @typedef {Object} GatewayCreate
 * @property {Uuid} id
 * @property {string} serial_number
 * @property {string} name
 * @property {string} description
 * @property {?Uuid} type_id
 */

/**
 * @typedef {Object} GatewayUpdate
 * @property {Uuid} id
 * @property {?string} serial_number
 * @property {?string} name
 * @property {?string} description
 * @property {?Uuid} type_id
 */

/**
 * @typedef {Object} ConfigId
 * @property {number} id
 */

/**
 * @param {*} r 
 * @returns {ConfigId}
 */
function get_config_id(r) {
    return {
        id: r.id
    };
}

/**
 * @typedef {Object} DeviceConfigSchema
 * @property {number} id
 * @property {Uuid} device_id
 * @property {string} name
 * @property {number|string} value
 * @property {string} category
 */

/**
 * @typedef {Object} GatewayConfigSchema
 * @property {number} id
 * @property {Uuid} gateway_id
 * @property {string} name
 * @property {number|string} value
 * @property {string} category
 */

/**
 * @param {*} r 
 * @returns {DeviceConfigSchema}
 */
function get_device_config_schema(r) {
    return {
        id: r.id,
        device_id: base64_to_uuid_hex(r.deviceId),
        name: r.name,
        value: get_data_value(r.configBytes, r.configType),
        category: r.category
    };
}

/**
 * @param {*} r 
 * @returns {DeviceConfigSchema[]}
 */
function get_device_config_schema_vec(r) {
    return r.map((v) => {return get_device_config_schema(v)});
}

/**
 * @param {*} r 
 * @returns {GatewayConfigSchema}
 */
function get_gateway_config_schema(r) {
    return {
        id: r.id,
        gateway_id: base64_to_uuid_hex(r.deviceId),
        name: r.name,
        value: get_data_value(r.configBytes, r.configType),
        category: r.category
    };
}

/**
 * @param {*} r 
 * @returns {GatewayConfigSchema[]}
 */
function get_gateway_config_schema_vec(r) {
    return r.map((v) => {return get_gateway_config_schema(v)});
}

/**
 * @typedef {Object} ConfigUpdate
 * @property {number} id
 * @property {?string} name
 * @property {?number|string} value
 * @property {?string} category
 */


/**
 * Read a device by uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {DeviceId} request device uuid: id
 * @returns {Promise<DeviceSchema>} device schema: id, gateway_id, serial_number, name, description, device_type, configs
 */
async function read_device(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const deviceId = new pb_device.DeviceId();
    deviceId.setId(uuid_hex_to_base64(request.id));
    return client.readDevice(deviceId, metadata(server))
        .then(response => get_device_schema(response.toObject().result));
}

/**
 * Read a device by serial number
 * @param {ServerConfig} server server configuration: address, token
 * @param {SerialNumber} request serial number: serial_number
 * @returns {Promise<DeviceSchema>} device schema: id, gateway_id, serial_number, name, description, device_type, configs
 */
async function read_device_by_sn(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const serialNumber = new pb_device.SerialNumber();
    serialNumber.setSerialNumber(request.serial_number);
    return client.readDeviceBySn(serialNumber, metadata(server))
        .then(response => get_device_schema(response.toObject().result));
}

/**
 * Read devices by uuid list
 * @param {ServerConfig} server server configuration: address, token
 * @param {DeviceIds} request device uuid list: ids
 * @returns {Promise<DeviceSchema[]>} device schema: id, gateway_id, serial_number, name, description, device_type, configs
 */
async function list_device_by_ids(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const deviceIds = new pb_device.DeviceIds();
    deviceIds.setIdsList(request.ids.map((id) => uuid_hex_to_base64(id)));
    return client.listDeviceByIds(deviceIds, metadata(server))
        .then(response => get_device_schema_vec(response.toObject().resultsList));
}

/**
 * Read devices by gateway
 * @param {ServerConfig} server server configuration: address, token
 * @param {GatewayId} request gateway uuid: id
 * @returns {Promise<DeviceSchema[]>} device schema: id, gateway_id, serial_number, name, description, device_type, configs
 */
async function list_device_by_gateway(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const gatewayId = new pb_device.GatewayId();
    gatewayId.setId(uuid_hex_to_base64(request.id));
    return client.listDeviceByGateway(gatewayId, metadata(server))
        .then(response => get_device_schema_vec(response.toObject().resultsList));
}

/**
 * Read devices by type
 * @param {ServerConfig} server server configuration: address, token
 * @param {TypeId} request type uuid: id
 * @returns {Promise<DeviceSchema[]>} device schema: id, gateway_id, serial_number, name, description, device_type, configs
 */
async function list_device_by_type(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const typeId = new pb_device.TypeId();
    typeId.setId(uuid_hex_to_base64(request.id));
    return client.listDeviceByType(typeId, metadata(server))
        .then(response => get_device_schema_vec(response.toObject().resultsList));
}

/**
 * Read devices by name
 * @param {ServerConfig} server server configuration: address, token
 * @param {DeviceName} request device name: name
 * @returns {Promise<DeviceSchema[]>} device schema: id, gateway_id, serial_number, name, description, device_type, configs
 */
async function list_device_by_name(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const deviceName = new pb_device.DeviceName();
    deviceName.setName(request.name);
    return client.listDeviceByName(deviceName, metadata(server))
        .then(response => get_device_schema_vec(response.toObject().resultsList));
}

/**
 * Read devices with select options
 * @param {ServerConfig} server server configuration: address, token
 * @param {DeviceOption} request device select option: gateway_id, type_id, name
 * @returns {Promise<DeviceSchema[]>} device schema: id, gateway_id, serial_number, name, description, device_type, configs
 */
async function list_device_option(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const deviceOption = new pb_device.DeviceOption();
    if (request.gateway_id) {
        deviceOption.setGatewayId(uuid_hex_to_base64(request.gateway_id));
    }
    if (request.type_id) {
        deviceOption.setTypeId(uuid_hex_to_base64(request.type_id));
    }
    deviceOption.setName(request.name);
    return client.listDeviceOption(deviceOption, metadata(server))
        .then(response => get_device_schema_vec(response.toObject().resultsList));
}

/**
 * Create a device
 * @param {ServerConfig} server server configuration: address, token
 * @param {DeviceCreate} request device schema: id, gateway_id, serial_number, name, description, type_id
 * @returns {Promise<DeviceId>} device uuid: id
 */
async function create_device(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const typeSchema = new pb_device.TypeSchema();
    typeSchema.setId(uuid_hex_to_base64(request.type_id));
    const deviceSchema = new pb_device.DeviceSchema();
    deviceSchema.setId(uuid_hex_to_base64(request.id));
    deviceSchema.setGatewayId(uuid_hex_to_base64(request.gateway_id));
    deviceSchema.setSerialNumber(request.serial_number);
    deviceSchema.setName(request.name);
    deviceSchema.setDescription(request.description);
    deviceSchema.setDeviceType(typeSchema);
    return client.createDevice(deviceSchema, metadata(server))
        .then(response => get_device_id(response.toObject()));
}

/**
 * Update a device
 * @param {ServerConfig} server server configuration: address, token
 * @param {DeviceUpdate} request device update: id, gateway_id, serial_number, name, description, type_id
 * @returns {Promise<{}>} update response
 */
async function update_device(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const deviceUpdate = new pb_device.DeviceUpdate();
    deviceUpdate.setId(uuid_hex_to_base64(request.id));
    if (request.gateway_id) {
        deviceUpdate.setGatewayId(uuid_hex_to_base64(request.gateway_id));
    }
    deviceUpdate.setSerialNumber(request.serial_number);
    deviceUpdate.setName(request.name);
    deviceUpdate.setDescription(request.description);
    deviceUpdate.setTypeId(request.type_id);
    return client.updateDevice(deviceUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete a device
 * @param {ServerConfig} server server configuration: address, token
 * @param {DeviceId} request device uuid: id
 * @returns {Promise<{}>} delete response
 */
async function delete_device(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const deviceId = new pb_device.DeviceId();
    deviceId.setId(uuid_hex_to_base64(request.id));
    return client.deleteDevice(deviceId, metadata(server))
        .then(response => response.toObject());
}

/**
 * Read a gateway by uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {GatewayId} request gateway uuid: id
 * @returns {Promise<GatewaySchema>} gateway schema: id, serial_number, name, description, gateway_type, configs
 */
async function read_gateway(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const gatewayId = new pb_device.GatewayId();
    gatewayId.setId(uuid_hex_to_base64(request.id));
    return client.readGateway(gatewayId, metadata(server))
        .then(response => get_gateway_schema(response.toObject().result));
}

/**
 * Read a gateway by serial number
 * @param {ServerConfig} server server configuration: address, token
 * @param {SerialNumber} request serial number: serial_number
 * @returns {Promise<GatewaySchema>} gateway schema: id, serial_number, name, description, gateway_type, configs
 */
async function read_gateway_by_sn(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const serialNumber = new pb_device.SerialNumber();
    serialNumber.setSerialNumber(request.serial_number);
    return client.readGatewayBySn(serialNumber, metadata(server))
        .then(response => get_gateway_schema(response.toObject().result));
}

/**
 * Read gateways by uuid list
 * @param {ServerConfig} server server configuration: address, token
 * @param {GatewayIds} request gateway uuid list: ids
 * @returns {Promise<GatewaySchema[]>} gateway schema: id, serial_number, name, description, gateway_type, configs
 */
async function list_gateway_by_ids(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const gatewayIds = new pb_device.GatewayIds();
    gatewayIds.setIdsList(request.ids.map((id) => uuid_hex_to_base64(id)));
    return client.listGatewayByIds(gatewayIds, metadata(server))
        .then(response => get_gateway_schema_vec(response.toObject().resultsList));
}

/**
 * Read gateways by type
 * @param {ServerConfig} server server configuration: address, token
 * @param {TypeId} request type uuid: id
 * @returns {Promise<GatewaySchema[]>} gateway schema: id, serial_number, name, description, gateway_type, configs
 */
async function list_gateway_by_type(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const typeId = new pb_device.TypeId();
    typeId.setId(uuid_hex_to_base64(request.id));
    return client.listGatewayByType(typeId, metadata(server))
        .then(response => get_gateway_schema_vec(response.toObject().resultsList));
}

/**
 * Read gateways by name
 * @param {ServerConfig} server server configuration: address, token
 * @param {GatewayName} request gateway name: name
 * @returns {Promise<GatewaySchema[]>} gateway schema: id, serial_number, name, description, gateway_type, configs
 */
async function list_gateway_by_name(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const gatewayName = new pb_device.GatewayName();
    gatewayName.setName(request.name);
    return client.listGatewayByName(gatewayName, metadata(server))
        .then(response => get_gateway_schema_vec(response.toObject().resultsList));
}

/**
 * Read gateways with select options
 * @param {ServerConfig} server server configuration: address, token
 * @param {GatewayOption} request gateway select option: type_id, name
 * @returns {Promise<GatewaySchema[]>} gateway schema: id, serial_number, name, description, gateway_type, configs
 */
async function list_gateway_option(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const gatewayOption = new pb_device.GatewayOption();
    if (request.type_id) {
        gatewayOption.setTypeId(uuid_hex_to_base64(request.type_id));
    }
    gatewayOption.setName(request.name);
    return client.listGatewayOption(gatewayOption, metadata(server))
        .then(response => get_device_schema_vec(response.toObject().resultsList));
}

/**
 * Create a gateway
 * @param {ServerConfig} server server configuration: address, token
 * @param {GatewayCreate} request gateway schema: id, serial_number, name, description, type_id
 * @returns {Promise<GatewayId>} gateway uuid: id
 */
async function create_gateway(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const typeSchema = new pb_device.TypeSchema();
    typeSchema.setId(uuid_hex_to_base64(request.type_id));
    const gatewaySchema = new pb_device.GatewaySchema();
    gatewaySchema.setId(uuid_hex_to_base64(request.id));
    gatewaySchema.setSerialNumber(request.serial_number);
    gatewaySchema.setName(request.name);
    gatewaySchema.setDescription(request.description);
    gatewaySchema.setGatewayType(typeSchema);
    return client.createGateway(gatewaySchema, metadata(server))
        .then(response => get_gateway_id(response.toObject()));
}

/**
 * Update a gateway
 * @param {ServerConfig} server server configuration: address, token
 * @param {GatewayUpdate} request gateway update: id, serial_number, name, description, type_id
 * @returns {Promise<{}>} update response 
 */
async function update_gateway(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const gatewayUpdate = new pb_device.GatewayUpdate();
    gatewayUpdate.setId(uuid_hex_to_base64(request.id));
    gatewayUpdate.setSerialNumber(request.serial_number);
    gatewayUpdate.setName(request.name);
    gatewayUpdate.setDescription(request.description);
    gatewayUpdate.setTypeId(request.type_id);
    return client.updateGateway(gatewayUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete a gateway
 * @param {ServerConfig} server server configuration: address, token
 * @param {GatewayId} request gateway uuid: id
 * @returns {Promise<{}>} delete response
 */
async function delete_gateway(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const gatewayId = new pb_device.GatewayId();
    gatewayId.setId(uuid_hex_to_base64(request.id));
    return client.deleteGateway(gatewayId, metadata(server))
        .then(response => response.toObject());
}

/**
 * Read a device configuration by uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {ConfigId} request device config uuid: id
 * @returns {Promise<DeviceConfigSchema>} device config schema: id, device_id, name, value, category
 */
async function read_device_config(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const configId = new pb_device.ConfigId();
    configId.setId(request.id);
    return client.readDeviceConfig(configId, metadata(server))
        .then(response => get_device_config_schema(response.toObject().result));
}

/**
 * Read device configurations by device uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {DeviceId} request device uuid: id
 * @returns {Promise<DeviceConfigSchema[]>} device config schema: id, device_id, name, value, category
 */
async function list_device_config_by_device(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const deviceId = new pb_device.DeviceId();
    deviceId.setId(uuid_hex_to_base64(request.id));
    return client.listDeviceConfig(deviceId, metadata(server))
        .then(response => get_device_config_schema_vec(response.toObject().resultsList));
}

/**
 * Create a device configuration
 * @param {ServerConfig} server server configuration: address, token
 * @param {DeviceConfigSchema} request device config schema: device_id, name, value, category
 * @returns {Promise<ConfigId>} device config uuid: id
 */
async function create_device_config(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const configSchema = new pb_device.ConfigSchema();
    configSchema.setDeviceId(uuid_hex_to_base64(request.device_id));
    configSchema.setName(request.name);
    const value = set_data_value(request.value);
    configSchema.setConfigBytes(value.bytes);
    configSchema.setConfigType(value.type);
    configSchema.setCategory(request.category);
    return client.createDeviceConfig(configSchema, metadata(server))
        .then(response => get_config_id(response.toObject()));
}

/**
 * Update a device configuration
 * @param {ServerConfig} server server configuration: address, token
 * @param {ConfigUpdate} request device config update: id, name, value, category
 * @returns {Promise<{}>} update response
 */
async function update_device_config(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const configUpdate = new pb_device.ConfigUpdate();
    configUpdate.setId(request.id);
    configUpdate.setName(request.name);
    const value = set_data_value(request.value);
    configUpdate.setConfigBytes(value.bytes);
    configUpdate.setConfigType(value.type);
    configUpdate.setCategory(request.category);
    return client.updateDeviceConfig(configUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete a device configuration
 * @param {ServerConfig} server server configuration: address, token
 * @param {ConfigId} request device config uuid: id
 * @returns {Promise<{}>} delete response
 */
async function delete_device_config(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const configId = new pb_device.ConfigId();
    configId.setId(request.id);
    return client.deleteDeviceConfig(configId, metadata(server))
        .then(response => response.toObject());
}

/**
 * Read a gateway configuration by uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {ConfigId} request gateway config uuid: id
 * @returns {Promise<GatewayConfigSchema>} gateway config schema: id, gateway_id, name, value, category
 */
async function read_gateway_config(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const configId = new pb_device.ConfigId();
    configId.setId(request.id);
    return client.readGatewayConfig(configId, metadata(server))
        .then(response => get_gateway_config_schema(response.toObject().result));
}

/**
 * Read gateway configurations by gateway uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {GatewayId} request gateway uuid: id
 * @returns {Promise<GatewayConfigSchema[]>} gateway config schema: id, gateway_id, name, value, category
 */
async function list_gateway_config_by_gateway(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const gatewayId = new pb_device.GatewayId();
    gatewayId.setId(uuid_hex_to_base64(request.id));
    return client.listGatewayConfig(gatewayId, metadata(server))
        .then(response => get_gateway_config_schema_vec(response.toObject().resultsList));
}

/**
 * Create a gateway configuration
 * @param {ServerConfig} server server configuration: address, token
 * @param {GatewayConfigSchema} request gateway config schema: gateway_id, name, value, category
 * @returns {Promise<ConfigId>} gateway config id: id
 */
async function create_gateway_config(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const configSchema = new pb_device.ConfigSchema();
    configSchema.setDeviceId(uuid_hex_to_base64(request.gateway_id));
    configSchema.setName(request.name);
    const value = set_data_value(request.value);
    configSchema.setConfigBytes(value.bytes);
    configSchema.setConfigType(value.type);
    configSchema.setCategory(request.category);
    return client.createGatewayConfig(configSchema, metadata(server))
        .then(response => get_config_id(response.toObject()));
}

/**
 * Update a gateway configuration
 * @param {ServerConfig} server server configuration: address, token
 * @param {ConfigUpdate} request gateway config update: id, name, value, category
 * @returns {Promise<{}>} update response
 */
async function update_gateway_config(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const configUpdate = new pb_device.ConfigUpdate();
    configUpdate.setId(request.id);
    configUpdate.setName(request.name);
    const value = set_data_value(request.value);
    configUpdate.setConfigBytes(value.bytes);
    configUpdate.setConfigType(value.type);
    configUpdate.setCategory(request.category);
    return client.updateGatewayConfig(configUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete a gateway configuration
 * @param {ServerConfig} server server configuration: address, token
 * @param {ConfigId} request gateway config uuid: id
 * @returns {Promise<{}>} delete response
 */
async function delete_gateway_config(server, request) {
    const client = new pb_device.DeviceServicePromiseClient(server.address, null, null);
    const configId = new pb_device.ConfigId();
    configId.setId(request.id);
    return client.deleteGatewayConfig(configId, metadata(server))
        .then(response => response.toObject());
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} GroupId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} GroupIds
 * @property {Uuid[]} ids
 */

/**
 * @param {*} r 
 * @returns {GroupId}
 */
function get_group_id(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
 * @typedef {Object} GroupName
 * @property {string} name
 */

/**
 * @typedef {Object} GroupCategory
 * @property {string} category
 */

/**
 * @typedef {Object} GroupOption
 * @property {?string} name
 * @property {?string} category
 */

/**
 * @typedef {Object} GroupModelSchema
 * @property {Uuid} id
 * @property {string} name
 * @property {string} category
 * @property {string} description
 * @property {Uuid[]} models
 */

/**
 * @typedef {Object} GroupDeviceSchema
 * @property {Uuid} id
 * @property {string} name
 * @property {string} category
 * @property {string} description
 * @property {Uuid[]} devices
 */

/**
 * @typedef {Object} GroupGatewaySchema
 * @property {Uuid} id
 * @property {string} name
 * @property {string} category
 * @property {string} description
 * @property {Uuid[]} gateways
 */

/**
 * @param {*} r 
 * @returns {GroupModelSchema}
 */
function get_group_model_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        name: r.name,
        category: r.category,
        description: r.description,
        models: r.modelsList.map((v) => {return base64_to_uuid_hex(v)})
    };
}

/**
 * @param {*} r 
 * @returns {GroupModelSchema[]}
 */
function get_group_model_schema_vec(r) {
    return r.map((v) => {return get_group_model_schema(v)});
}

/**
 * @param {*} r 
 * @returns {GroupDeviceSchema}
 */
function get_group_device_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        name: r.name,
        category: r.category,
        description: r.description,
        devices: r.devicesList.map((v) => {return base64_to_uuid_hex(v)})
    };
}

/**
 * @param {*} r 
 * @returns {GroupDeviceSchema[]}
 */
function get_group_device_schema_vec(r) {
    return r.map((v) => {return get_group_device_schema(v)});
}

/**
 * @param {*} r 
 * @returns {GroupGatewaySchema}
 */
function get_group_gateway_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        name: r.name,
        category: r.category,
        description: r.description,
        gateways: r.devicesList.map((v) => {return base64_to_uuid_hex(v)})
    };
}

/**
 * @param {*} r 
 * @returns {GroupGatewaySchema[]}
 */
function get_group_gateway_schema_vec(r) {
    return r.map((v) => {return get_group_gateway_schema(v)});
}

/**
 * @typedef {Object} GroupUpdate
 * @property {Uuid} id
 * @property {?string} name
 * @property {?string} category
 * @property {?string} description
 */

/**
 * @typedef {Object} GroupModel
 * @property {Uuid} id
 * @property {Uuid} model_id
 */

/**
 * @typedef {Object} GroupDevice
 * @property {Uuid} id
 * @property {Uuid} device_id
 */

/**
 * @typedef {Object} GroupGateway
 * @property {Uuid} id
 * @property {Uuid} gateway_id
 */


/**
 * Read a group model by uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupId} request group model uuid: id
 * @returns {Promise<GroupModelSchema>} group model schema: id, name, category, description, models
 */
async function read_group_model(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupId = new pb_group.GroupId();
    groupId.setId(uuid_hex_to_base64(request.id));
    return client.readGroupModel(groupId, metadata(server))
        .then(response => get_group_model_schema(response.toObject().result));
}

/**
 * Read groups of model by uuid list
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupIds} request group uuid list: ids
 * @returns {Promise<GroupModelSchema[]>} group model schema: id, name, category, description, models
 */
async function list_group_model_by_ids(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupIds = new pb_group.GroupIds();
    groupIds.setIdsList(request.ids.map((id) => uuid_hex_to_base64(id)));
    return client.listGroupModelByIds(groupIds, metadata(server))
        .then(response => get_group_model_schema_vec(response.toObject().resultsList));
}

/**
 * Read groups of model by name
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupName} request group model name: name
 * @returns {Promise<GroupModelSchema[]>} group model schema: id, name, category, description, models
 */
async function list_group_model_by_name(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupName = new pb_group.GroupName();
    groupName.setName(request.name);
    return client.listGroupModelByName(groupName, metadata(server))
        .then(response => get_group_model_schema_vec(response.toObject().resultsList));
}

/**
 * Read groups of model by category
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupCategory} request group model category: category
 * @returns {Promise<GroupModelSchema[]>} group model schema: id, name, category, description, models
 */
async function list_group_model_by_category(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupCategory = new pb_group.GroupCategory();
    groupCategory.setCategory(request.category);
    return client.listGroupModelByCategory(groupCategory, metadata(server))
        .then(response => get_group_model_schema_vec(response.toObject().resultsList));
}

/**
 * Read groups of model with select option
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupOption} request group model option: name, category
 * @returns {Promise<GroupModelSchema[]>} group model schema: id, name, category, description, models
 */
async function list_group_model_option(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupOption = new pb_group.GroupOption();
    groupOption.setName(request.name);
    groupOption.setCategory(request.category);
    return client.listGroupModelOption(groupOption, metadata(server))
        .then(response => get_group_model_schema_vec(response.toObject().resultsList));
}

/**
 * Create a group model
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupModelSchema} request group model schema: id, name, category, description
 * @returns {Promise<GroupId>} group model uuid: id
 */
async function create_group_model(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupSchema = new pb_group.GroupModelSchema();
    groupSchema.setId(uuid_hex_to_base64(request.id));
    groupSchema.setName(request.name);
    groupSchema.setCategory(request.category);
    groupSchema.setDescription(request.description);
    return client.createGroupModel(groupSchema, metadata(server))
        .then(response => get_group_id(response.toObject()));
}

/**
 * Update a group model
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupUpdate} request group model update: id, name, category, description
 * @returns {Promise<{}>} update response
 */
async function update_group_model(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupUpdate = new pb_group.GroupUpdate();
    groupUpdate.setId(uuid_hex_to_base64(request.id));
    groupUpdate.setName(request.name);
    groupUpdate.setCategory(request.category);
    groupUpdate.setDescription(request.description);
    return client.updateGroupModel(groupUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete a group model
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupId} request group model uuid: id
 * @returns {Promise<{}>} delete response
 */
async function delete_group_model(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupId = new pb_group.GroupId();
    groupId.setId(uuid_hex_to_base64(request.id));
    return client.deleteGroupModel(groupId, metadata(server))
        .then(response => response.toObject());
}

/**
 * Add a member to a group model
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupModel} request group model member: id, model_id
 * @returns {Promise<{}>} change response
 */
async function add_group_model_member(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupModel = new pb_group.GroupModel();
    groupModel.setId(uuid_hex_to_base64(request.id));
    groupModel.setModelId(uuid_hex_to_base64(request.model_id));
    return client.addGroupModelMember(groupModel, metadata(server))
        .then(response => response.toObject());
}

/**
 * Remove a member to a group model
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupModel} request group model member: id, model_id
 * @returns {Promise<{}>} change response
 */
async function remove_group_model_member(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupModel = new pb_group.GroupModel();
    groupModel.setId(uuid_hex_to_base64(request.id));
    groupModel.setModelId(uuid_hex_to_base64(request.model_id));
    return client.removeGroupModelMember(groupModel, metadata(server))
        .then(response => response.toObject());
}

/**
 * Read a group device by uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupId} request group device uuid: id
 * @returns {Promise<GroupDeviceSchema>} group device schema: id, name, category, description, devices
 */
async function read_group_device(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupId = new pb_group.GroupId();
    groupId.setId(uuid_hex_to_base64(request.id));
    return client.readGroupDevice(groupId, metadata(server))
        .then(response => get_group_device_schema(response.toObject().result));
}

/**
 * Read groups of device by uuid list
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupIds} request group uuid list: ids
 * @returns {Promise<GroupDeviceSchema[]>} group device schema: id, name, category, description, devices
 */
async function list_group_device_by_ids(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupIds = new pb_group.GroupIds();
    groupIds.setIdsList(request.ids.map((id) => uuid_hex_to_base64(id)));
    return client.listGroupDeviceByIds(groupIds, metadata(server))
        .then(response => get_group_device_schema_vec(response.toObject().resultsList));
}

/**
 * Read groups of device by name
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupName} request group device name: name
 * @returns {Promise<GroupDeviceSchema[]>} group device schema: id, name, category, description, devices
 */
async function list_group_device_by_name(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupName = new pb_group.GroupName();
    groupName.setName(request.name);
    return client.listGroupDeviceByName(groupName, metadata(server))
        .then(response => get_group_device_schema_vec(response.toObject().resultsList));
}

/**
 * Read groups of device by category
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupCategory} request group device category: category
 * @returns {Promise<GroupDeviceSchema[]>} group device schema: id, name, category, description, devices
 */
async function list_group_device_by_category(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupCategory = new pb_group.GroupCategory();
    groupCategory.setCategory(request.category);
    return client.listGroupDeviceByCategory(groupCategory, metadata(server))
        .then(response => get_group_device_schema_vec(response.toObject().resultsList));
}

/**
 * Read groups of device with select options
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupOption} request group device option: name, category
 * @returns {Promise<GroupDeviceSchema[]>} group device schema: id, name, category, description, devices
 */
async function list_group_device_option(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupOption = new pb_group.GroupOption();
    groupOption.setName(request.name);
    groupOption.setCategory(request.category);
    return client.listGroupDeviceOption(groupOption, metadata(server))
        .then(response => get_group_device_schema_vec(response.toObject().resultsList));
}

/**
 * Create a group device
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupDeviceSchema} request group device schema: id, name, category, description
 * @returns {Promise<GroupId>} group device uuid: id
 */
async function create_group_device(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupSchema = new pb_group.GroupDeviceSchema();
    groupSchema.setId(uuid_hex_to_base64(request.id));
    groupSchema.setName(request.name);
    groupSchema.setCategory(request.category);
    groupSchema.setDescription(request.description);
    return client.createGroupDevice(groupSchema, metadata(server))
        .then(response => get_group_id(response.toObject()));
}

/**
 * Update a group device
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupUpdate} request group device update: id, name, category, description
 * @returns {Promise<{}>} update response
 */
async function update_group_device(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupUpdate = new pb_group.GroupUpdate();
    groupUpdate.setId(uuid_hex_to_base64(request.id));
    groupUpdate.setName(request.name);
    groupUpdate.setCategory(request.category);
    groupUpdate.setDescription(request.description);
    return client.updateGroupDevice(groupUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete a group device
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupId} request group device uuid: id
 * @returns {Promise<{}>} delete response
 */
async function delete_group_device(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupId = new pb_group.GroupId();
    groupId.setId(uuid_hex_to_base64(request.id));
    return client.deleteGroupDevice(groupId, metadata(server))
        .then(response => response.toObject());
}

/**
 * Add a member to a group device
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupDevice} request group device member: id, device_id
 * @returns {Promise<{}>} change response
 */
async function add_group_device_member(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupDevice = new pb_group.GroupDevice();
    groupDevice.setId(uuid_hex_to_base64(request.id));
    groupDevice.setDeviceId(uuid_hex_to_base64(request.device_id));
    return client.addGroupDeviceMember(groupDevice, metadata(server))
        .then(response => response.toObject());
}

/**
 * Remove a member to a group device
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupDevice} request group device member: id, device_id
 * @returns {Promise<{}>} change response
 */
async function remove_group_device_member(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupDevice = new pb_group.GroupDevice();
    groupDevice.setId(uuid_hex_to_base64(request.id));
    groupDevice.setDeviceId(uuid_hex_to_base64(request.device_id));
    return client.removeGroupDeviceMember(groupDevice, metadata(server))
        .then(response => response.toObject());
}

/**
 * Read a group gateway by uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupId} request group gateway uuid: id
 * @returns {Promise<GroupGatewaySchema>} group gateway schema: id, name, category, description, gateways
 */
async function read_group_gateway(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupId = new pb_group.GroupId();
    groupId.setId(uuid_hex_to_base64(request.id));
    return client.readGroupGateway(groupId, metadata(server))
        .then(response => get_group_gateway_schema(response.toObject().result));
}

/**
 * Read groups of gateway by uuid list
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupIds} request group uuid list: ids
 * @returns {Promise<GroupGatewaySchema[]>} group gateway schema: id, name, category, description, gateways
 */
async function list_group_gateway_by_ids(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupIds = new pb_group.GroupIds();
    groupIds.setIdsList(request.ids.map((id) => uuid_hex_to_base64(id)));
    return client.listGroupGatewayByIds(groupIds, metadata(server))
        .then(response => get_group_gateway_schema_vec(response.toObject().resultsList));
}

/**
 * Read groups of gateway by name
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupName} request group gateway name: name
 * @returns {Promise<GroupGatewaySchema[]>} group gateway schema: id, name, category, description, gateways
 */
async function list_group_gateway_by_name(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupName = new pb_group.GroupName();
    groupName.setName(request.name);
    return client.listGroupGatewayByName(groupName, metadata(server))
        .then(response => get_group_gateway_schema_vec(response.toObject().resultsList));
}

/**
 * Read groups of gateway by category
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupCategory} request group gateway category: category
 * @returns {Promise<GroupGatewaySchema[]>} group gateway schema: id, name, category, description, gateways
 */
async function list_group_gateway_by_category(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupCategory = new pb_group.GroupCategory();
    groupCategory.setCategory(request.category);
    return client.listGroupGatewayByCategory(groupCategory, metadata(server))
        .then(response => get_group_gateway_schema_vec(response.toObject().resultsList));
}

/**
 * Read groups of gateway with select options
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupOption} request group gateway option: name, category
 * @returns {Promise<GroupGatewaySchema[]>} group gateway schema: id, name, category, description, gateways
 */
async function list_group_gateway_option(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupOption = new pb_group.GroupOption();
    groupOption.setName(request.name);
    groupOption.setCategory(request.category);
    return client.listGroupGatewayOption(groupOption, metadata(server))
        .then(response => get_group_gateway_schema_vec(response.toObject().resultsList));
}

/**
 * Create a group gateway
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupGatewaySchema} request group gateway schema: id, name, category, description
 * @returns {Promise<GroupId>} group gateway uuid: id
 */
async function create_group_gateway(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupSchema = new pb_group.GroupDeviceSchema();
    groupSchema.setId(uuid_hex_to_base64(request.id));
    groupSchema.setName(request.name);
    groupSchema.setCategory(request.category);
    groupSchema.setDescription(request.description);
    return client.createGroupGateway(groupSchema, metadata(server))
        .then(response => get_group_id(response.toObject()));
}

/**
 * Update a group gateway
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupUpdate} request group gateway update: id, name, category, description
 * @returns {Promise<{}>} update response
 */
async function update_group_gateway(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupUpdate = new pb_group.GroupUpdate();
    groupUpdate.setId(uuid_hex_to_base64(request.id));
    groupUpdate.setName(request.name);
    groupUpdate.setCategory(request.category);
    groupUpdate.setDescription(request.description);
    return client.updateGroupGateway(groupUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete a group gateway
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupId} request group gateway uuid: id
 * @returns {Promise<{}>} delete response
 */
async function delete_group_gateway(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupId = new pb_group.GroupId();
    groupId.setId(uuid_hex_to_base64(request.id));
    return client.deleteGroupGateway(groupId, metadata(server))
        .then(response => response.toObject());
}

/**
 * Add a member to a group gateway
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupGateway} request group gateway member: id, gateway_id
 * @returns {Promise<{}>} change response
 */
async function add_group_gateway_member(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupDevice = new pb_group.GroupDevice();
    groupDevice.setId(uuid_hex_to_base64(request.id));
    groupDevice.setDeviceId(uuid_hex_to_base64(request.gateway_id));
    return client.addGroupGatewayMember(groupDevice, metadata(server))
        .then(response => response.toObject());
}

/**
 * Remove a member to a group gateway
 * @param {ServerConfig} server server configuration: address, token
 * @param {GroupGateway} request group gateway member: id, gateway_id
 * @returns {Promise<{}>} change response
 */
async function remove_group_gateway_member(server, request) {
    const client = new pb_group.GroupServicePromiseClient(server.address, null, null);
    const groupDevice = new pb_group.GroupDevice();
    groupDevice.setId(uuid_hex_to_base64(request.id));
    groupDevice.setDeviceId(uuid_hex_to_base64(request.gateway_id));
    return client.removeGroupGatewayMember(groupDevice, metadata(server))
        .then(response => response.toObject());
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} SetId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} SetIds
 * @property {Uuid[]} ids
 */

/**
 * @typedef {Object} SetName
 * @property {string} name
 */

/**
 * @typedef {Object} SetOption
 * @property {?Uuid} template_id
 * @property {?string} name
 */

/**
 * @param {*} r 
 * @returns {SetId}
 */
function get_set_id(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
* @typedef {Object} SetName
* @property {string} name
*/

/**
 * @typedef {Object} SetSchema
 * @property {Uuid} id
 * @property {Uuid} template_id
 * @property {string} name
 * @property {string} description
 * @property {SetMember[]} members
 */

/**
 * @param {*} r 
 * @returns {SetSchema}
 */
function get_set_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        template_id: base64_to_uuid_hex(r.templateId),
        name: r.name,
        description: r.description,
        members: r.membersList.map((v) => {return get_set_member(v)})
    };
}

/**
 * @param {*} r 
 * @returns {SetSchema[]}
 */
function get_set_schema_vec(r) {
    return r.map((v) => {return get_set_schema(v)});
}

/**
 * @typedef {Object} SetMember
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 * @property {number[]} data_index
 */

/**
 * @param {*} r 
 * @returns {SetMember}
 */
function get_set_member(r) {
    return {
        device_id: base64_to_uuid_hex(r.deviceId),
        model_id: base64_to_uuid_hex(r.modelId),
        data_index: base64_to_bytes(r.dataIndex)
    };
}

/**
 * @typedef {Object} SetUpdate
 * @property {Uuid} id
 * @property {?Uuid} template_id
 * @property {?string} name
 * @property {?string} description
 */

/**
 * @typedef {Object} SetMemberRequest
 * @property {Uuid} set_id
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 * @property {number[]} data_index
 */

/**
 * @typedef {Object} SetMemberSwap
 * @property {Uuid} set_id
 * @property {Uuid} device_id_1
 * @property {Uuid} model_id_1
 * @property {Uuid} device_id_2
 * @property {Uuid} model_id_2
 */

/**
 * @typedef {Object} SetTemplateId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} SetTemplateIds
 * @property {Uuid[]} ids
 */

/**
 * @typedef {Object} SetTemplateName
 * @property {string} name
 */

/**
 * @param {*} r 
 * @returns {SetTemplateId}
 */
function get_set_template_id(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
* @typedef {Object} SetTemplateName
* @property {string} name
*/

/**
 * @typedef {Object} SetTemplateOption
 * @property {?string} name
 */

/**
 * @typedef {Object} SetTemplateSchema
 * @property {Uuid} id
 * @property {string} name
 * @property {string} description
 * @property {SetTemplateMember[]} members
 */

/**
 * @param {*} r 
 * @returns {SetTemplateSchema}
 */
function get_set_template_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        name: r.name,
        description: r.description,
        members: r.membersList.map((v) => {return get_set_template_member(v)})
    };
}

/**
 * @param {*} r 
 * @returns {SetTemplateSchema[]}
 */
function get_set_template_schema_vec(r) {
    return r.map((v) => {return get_set_template_schema(v)});
}

/**
 * @typedef {Object} SetTemplateMember
 * @property {Uuid} type_id
 * @property {Uuid} model_id
 * @property {number[]} data_index
 */

/**
 * @param {*} r 
 * @returns {SetTemplateMember}
 */
function get_set_template_member(r) {
    return {
        type_id: base64_to_uuid_hex(r.typeId),
        model_id: base64_to_uuid_hex(r.modelId),
        data_index: base64_to_bytes(r.dataIndex)
    };
}

/**
 * @typedef {Object} SetTemplateUpdate
 * @property {Uuid} id
 * @property {?string} name
 * @property {?string} description
 */

/**
 * @typedef {Object} SetTemplateMemberRequest
 * @property {Uuid} set_id
 * @property {Uuid} type_id
 * @property {Uuid} model_id
 * @property {number[]} data_index
 * @property {number} template_index
 */

/**
 * @typedef {Object} SetTemplateMemberSwap
 * @property {Uuid} set_id
 * @property {number} template_index_1
 * @property {number} template_index_2
 */


/**
 * Read a set by uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetId} request set uuid: id
 * @returns {Promise<SetSchema>} set schema: id, template_id, name, description, members
 */
async function read_set(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const setId = new pb_set.SetId();
    setId.setId(uuid_hex_to_base64(request.id));
    return client.readSet(setId, metadata(server))
        .then(response => get_set_schema(response.toObject().result));
}

/**
 * Read sets by uuid list
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetIds} request set uuid list: ids
 * @returns {Promise<SetSchema[]>} set schema: id, template_id, name, description, members
 */
async function list_set_by_ids(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const setIds = new pb_set.SetIds();
    setIds.setIdsList(request.ids.map((id) => uuid_hex_to_base64(id)));
    return client.listSetByIds(setIds, metadata(server))
        .then(response => get_set_schema_vec(response.toObject().resultsList));
}

/**
 * Read sets by template uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetTemplateId} request set template uuid: id
 * @returns {Promise<SetSchema[]>} set schema: id, template_id, name, description, members
 */
async function list_set_by_template(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const templateId = new pb_set.SetTemplateId();
    templateId.setTemplateId(uuid_hex_to_base64(request.id));
    return client.listSetByTemplate(templateId, metadata(server))
        .then(response => get_set_schema_vec(response.toObject().resultsList));
}

/**
 * Read sets by name
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetName} request set name: name
 * @returns {Promise<SetSchema[]>} set schema: id, template_id, name, description, members
 */
async function list_set_by_name(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const setName = new pb_set.SetName();
    setName.setName(request.name);
    return client.listSetByName(setName, metadata(server))
        .then(response => get_set_schema_vec(response.toObject().resultsList));
}

/**
 * Read sets with select options
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetOption} request set option: template_id, name
 * @returns {Promise<SetSchema[]>} set schema: id, template_id, name, description, members
 */
async function list_set_by_option(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const setOption = new pb_set.SetOption();
    if (request.template_id) {
        setOption.setTemplateId(uuid_hex_to_base64(request.template_id));
    }
    setOption.setName(request.name);
    return client.listSetOption(setOption, metadata(server))
        .then(response => get_set_schema_vec(response.toObject().resultsList));
}

/**
 * Create a set
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetSchema} request set schema: id, template_id, name, description, members
 * @returns {Promise<SetId>} set uuid: id
 */
async function create_set(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const setSchema = new pb_set.SetSchema();
    setSchema.setId(uuid_hex_to_base64(request.id));
    setSchema.setTemplateId(uuid_hex_to_base64(request.template_id));
    setSchema.setName(request.name);
    setSchema.setDescription(request.description);
    return client.createSet(setSchema, metadata(server))
        .then(response => get_set_id(response.toObject()));
}

/**
 * Update a set
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetUpdate} request set update: id, template_id, name, description
 * @returns {Promise<{}>} update response
 */
async function update_set(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const setUpdate = new pb_set.SetUpdate();
    setUpdate.setId(uuid_hex_to_base64(request.id));
    setUpdate.setTemplateId(uuid_hex_to_base64(request.template_id));
    setUpdate.setName(request.name);
    setUpdate.setDescription(request.description);
    return client.updateSet(setUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete a set
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetId} request set uuid: id
 * @returns {Promise<{}>} delete response
 */
async function delete_set(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const setId = new pb_set.SetId();
    setId.setId(uuid_hex_to_base64(request.id));
    return client.deleteSet(setId, metadata(server))
        .then(response => response.toObject());
}

/**
 * Add a member to a set
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetMemberRequest} request set member request: set_id, device_id, model_id, data_index
 * @returns {Promise<{}>} change response
 */
async function add_set_member(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const setMember = new pb_set.SetMemberRequest();
    setMember.setId(uuid_hex_to_base64(request.id));
    setMember.setDeviceId(uuid_hex_to_base64(request.device_id));
    setMember.setModelId(uuid_hex_to_base64(request.model_id));
    setMember.setDataIndex(bytes_to_base64(request.data_index));
    return client.addSetMember(setMember, metadata(server))
        .then(response => response.toObject());
}

/**
 * Remove a member from a set
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetMemberRequest} request set member request: set_id, device_id, model_id, data_index
 * @returns {Promise<{}>} change response
 */
async function remove_set_member(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const setMember = new pb_set.SetMemberRequest();
    setMember.setId(uuid_hex_to_base64(request.id));
    setMember.setDeviceId(uuid_hex_to_base64(request.device_id));
    setMember.setModelId(uuid_hex_to_base64(request.model_id));
    return client.removeSetMember(setMember, metadata(server))
        .then(response => response.toObject());
}

/**
 * Swap a set member index position 
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetMemberSwap} request set member request: set_id, device_id_1, model_id_1, device_id_2, model_id_2
 * @returns {Promise<{}>} change response
 */
async function swap_set_member(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const setMember = new pb_set.SetMemberSwap();
    setMember.setId(uuid_hex_to_base64(request.id));
    setMember.setDeviceId1(uuid_hex_to_base64(request.device_id_1));
    setMember.setModelId1(uuid_hex_to_base64(request.model_id_1));
    setMember.setDeviceId2(uuid_hex_to_base64(request.device_id_2));
    setMember.setModelId2(uuid_hex_to_base64(request.model_id_2));
    return client.swapSetMember(setMember, metadata(server))
        .then(response => response.toObject());
}

/**
 * Read a set template by uuid
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetTemplateId} request set template uuid: id
 * @returns {Promise<SetTemplateSchema>} set template schema: id, name, description, members
 */
async function read_set_template(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const templateId = new pb_set.SetTemplateId();
    templateId.setId(uuid_hex_to_base64(request.id));
    return client.readSetTemplate(templateId, metadata(server))
        .then(response => get_set_template_schema(response.toObject().result));
}

/**
 * Read set templates by uuid list
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetTemplateIds} request set template uuid list: ids
 * @returns {Promise<SetTemplateSchema[]>} set template schema: id, name, description, members
 */
async function list_set_template_by_ids(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const templateIds = new pb_set.SetTemplateIds();
    templateIds.setIdsList(request.ids.map((id) => uuid_hex_to_base64(id)));
    return client.listSetTemplateByIds(templateIds, metadata(server))
        .then(response => get_set_template_schema_vec(response.toObject().resultsList));
}

/**
 * Read set templates by name
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetTemplateName} request set template name: name
 * @returns {Promise<SetTemplateSchema[]>} set template schema: id, name, description, members
 */
async function list_set_template_by_name(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const templateName = new pb_set.SetTemplateName();
    templateName.setName(request.name);
    return client.listSetTemplateByName(templateName, metadata(server))
        .then(response => get_set_template_schema_vec(response.toObject().resultsList));
}

/**
 * Read set templates with select options
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetTemplateOption} request set template option: name
 * @returns {Promise<SetTemplateSchema[]>} set schema: id, template_id, name, description, members
 */
async function list_set_template_by_option(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const setOption = new pb_set.SetTemplateOption();
    setOption.setName(request.name);
    return client.listSetTemplateOption(setOption, metadata(server))
        .then(response => get_set_template_schema_vec(response.toObject().resultsList));
}

/**
 * Create a set template
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetTemplateSchema} request set template schema: id, name, description, members
 * @returns {Promise<SetTemplateId>} set template uuid: id
 */
async function create_set_template(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const templateSchema = new pb_set.SetTemplateSchema();
    templateSchema.setId(uuid_hex_to_base64(request.id));
    templateSchema.setName(request.name);
    templateSchema.setDescription(request.description);
    return client.createSetTemplate(templateSchema, metadata(server))
        .then(response => get_set_template_id(response.toObject()));
}

/**
 * Update a set template
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetTemplateUpdate} request set template update: id, name, description
 * @returns {Promise<{}>} update response
 */
async function update_set_template(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const templateUpdate = new pb_set.SetTemplateUpdate();
    templateUpdate.setId(uuid_hex_to_base64(request.id));
    templateUpdate.setName(request.name);
    templateUpdate.setDescription(request.description);
    return client.updateSetTemplate(templateUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete a set template
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetTemplateId} request set template uuid: id
 * @returns {Promise<{}>} delete response
 */
async function delete_set_template(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const templateId = new pb_set.SetTemplateId();
    templateId.setId(uuid_hex_to_base64(request.id));
    return client.deleteSetTemplate(templateId, metadata(server))
        .then(response => response.toObject());
}

/**
 * Add a member to a set template
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetTemplateMemberRequest} request set member request: set_id, type_id, model_id, data_index
 * @returns {Promise<{}>} change response
 */
async function add_set_template_member(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const templateMember = new pb_set.SetTemplateMemberRequest();
    templateMember.setId(uuid_hex_to_base64(request.id));
    templateMember.setTypeId(uuid_hex_to_base64(request.type_id));
    templateMember.setModelId(uuid_hex_to_base64(request.model_id));
    templateMember.setDataIndex(bytes_to_base64(request.data_index));
    return client.addSetTemplateMember(templateMember, metadata(server))
        .then(response => response.toObject());
}

/**
 * Remove a member from a set template
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetTemplateMemberRequest} request set member request: set_id, template_index
 * @returns {Promise<{}>} change response
 */
async function remove_set_template_member(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const templateMember = new pb_set.SetTemplateMemberRequest();
    templateMember.setId(uuid_hex_to_base64(request.id));
    templateMember.setTemplateIndex(uuid_hex_to_base64(request.device_id));
    return client.removeSetTemplateMember(templateMember, metadata(server))
        .then(response => response.toObject());
}

/**
 * Swap a set template member index position 
 * @param {ServerConfig} server server configuration: address, token
 * @param {SetTemplateMemberSwap} request set template member swap: set_id, template_index_1, template_index_2
 * @returns {Promise<{}>} change response
 */
async function swap_set_template_member(server, request) {
    const client = new pb_set.SetServicePromiseClient(server.address, null, null);
    const templateMember = new pb_set.SetTemplateMemberSwap();
    templateMember.setId(uuid_hex_to_base64(request.id));
    templateMember.setTemplateIndex1(uuid_hex_to_base64(request.template_index_1));
    templateMember.setTemplateIndex2(uuid_hex_to_base64(request.template_index_2));
    return client.swapSetTemplateMember(templateMember, metadata(server))
        .then(response => response.toObject());
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} DataId
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 * @property {Date} timestamp
 */

/**
 * @typedef {Object} DataTime
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 * @property {Date} timestamp
 */

/**
 * @typedef {Object} DataRange
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 * @property {Date} begin
 * @property {Date} end
 */

/**
 * @typedef {Object} DataNumber
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 * @property {Date} timestamp
 * @property {number} number
 */

/**
 * @typedef {Object} DataCount
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 * @property {?Date} timestamp
 * @property {?Date} begin
 * @property {?Date} end
 */

/**
 * @typedef {Object} DataCountResult
 * @property {number} count
 */

/**
 * @typedef {Object} DataSchema
 * @property {Uuid} model_id
 * @property {Uuid} device_id
 * @property {Date} timestamp
 * @property {(number|bigint|string|Uint8Array|boolean)[]} data
 */

/**
 * @param {*} r 
 * @returns {DataSchema}
 */
function get_data_schema(r) {
    return {
        device_id: base64_to_uuid_hex(r.deviceId),
        model_id: base64_to_uuid_hex(r.modelId),
        timestamp: new Date(r.timestamp / 1000),
        data: get_data_values(r.dataBytes, r.dataTypeList)
    };
}

/**
 * @param {*} r 
 * @returns {DataSchema[]}
 */
function get_data_schema_vec(r) {
    return r.map((v) => {return get_data_schema(v)});
}

/**
 * @typedef {Object} DataSetId
 * @property {Uuid} set_id
 * @property {Date} timestamp
 */

/**
 * @typedef {Object} DataSetTime
 * @property {Uuid} set_id
 * @property {Date} timestamp
 */

/**
 * @typedef {Object} DataSetRange
 * @property {Uuid} set_id
 * @property {Date} begin
 * @property {Date} end
 */

/**
 * @typedef {Object} DataSetNumber
 * @property {Uuid} set_id
 * @property {Date} timestamp
 * @property {number} number
 */

/**
 * @typedef {Object} DataSetSchema
 * @property {Uuid} set_id
 * @property {Date} timestamp
 * @property {(number|bigint|string|Uint8Array|boolean)[]} data
 */

/**
 * @param {*} r 
 * @returns {DataSetSchema}
 */
function get_data_set_schema(r) {
    return {
        set_id: base64_to_uuid_hex(r.setId),
        timestamp: new Date(r.timestamp / 1000),
        data: get_data_values(r.dataBytes, r.dataTypeList)
    };
}

/**
 * @param {*} r 
 * @returns {DataSetSchema[]}
 */
function get_data_set_schema_vec(r) {
    return r.map((v) => {return get_data_set_schema(v)});
}


/**
 * Read a data by id
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataId} request data id: device_id, model_id, timestamp
 * @returns {Promise<DataSchema>} data schema: device_id, model_id, timestamp, data
 */
async function read_data(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const dataId = new pb_data.DataId();
    dataId.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataId.setModelId(uuid_hex_to_base64(request.model_id));
    dataId.setTimestamp(request.timestamp.valueOf() * 1000);
    return client.readData(dataId, metadata(server))
        .then(response => get_data_schema(response.toObject().result));
}

/**
 * Read multiple data by last time
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataTime} request data time: device_id, model_id, timestamp
 * @returns {Promise<DataSchema[]>} data schema: device_id, model_id, timestamp, data
 */
async function list_data_by_last_time(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const dataTime = new pb_data.DataTime();
    dataTime.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataTime.setModelId(uuid_hex_to_base64(request.model_id));
    dataTime.setTimestamp(request.timestamp.valueOf() * 1000);
    return client.listDataByLastTime(dataTime, metadata(server))
        .then(response => get_data_schema_vec(response.toObject().resultsList));
}

/**
 * Read multiple data by range time
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataRange} request data range: device_id, model_id, begin, end
 * @returns {Promise<DataSchema[]>} data schema: device_id, model_id, timestamp, data
 */
async function list_data_by_range_time(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const dataRange = new pb_data.DataRange();
    dataRange.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataRange.setModelId(uuid_hex_to_base64(request.model_id));
    dataRange.setBegin(request.begin.valueOf() * 1000);
    dataRange.setEnd(request.end.valueOf() * 1000);
    return client.listDataByRangeTime(dataRange, metadata(server))
        .then(response => get_data_schema_vec(response.toObject().resultsList));
}

/**
 * Read multiple data by specific time and number before
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataNumber} request data time and number: device_id, model_id, timestamp, number
 * @returns {Promise<DataSchema[]>} data schema: device_id, model_id, timestamp, data
 */
async function list_data_by_number_before(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const dataNumber = new pb_data.DataNumber();
    dataNumber.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataNumber.setModelId(uuid_hex_to_base64(request.model_id));
    dataNumber.setTimestamp(request.timestamp.valueOf() * 1000);
    dataNumber.setNumber(request.number);
    return client.listDataByNumberBefore(dataNumber, metadata(server))
        .then(response => get_data_schema_vec(response.toObject().resultsList));
}

/**
 * Read multiple data by specific time and number after
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataNumber} request data time and number: device_id, model_id, timestamp, number
 * @returns {Promise<DataSchema[]>} data schema: device_id, model_id, timestamp, data
 */
async function list_data_by_number_after(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const dataNumber = new pb_data.DataNumber();
    dataNumber.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataNumber.setModelId(uuid_hex_to_base64(request.model_id));
    dataNumber.setTimestamp(request.timestamp.valueOf() * 1000);
    dataNumber.setNumber(request.number);
    return client.listDataByNumberAfter(dataNumber, metadata(server))
        .then(response => get_data_schema_vec(response.toObject().resultsList));
}

/**
 * Read multiple data by set uuid and specific time
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataSetTime} request dataset time: set_id, timestamp
 * @returns {Promise<DataSchema[]>} data schema: device_id, model_id, timestamp, data
 */
async function list_data_by_set_time(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const datasetTime = new pb_data.DataSetTime();
    datasetTime.setSetId(uuid_hex_to_base64(request.set_id));
    datasetTime.setTimestamp(request.timestamp.valueOf() * 1000);
    return client.listDataBySetTime(datasetTime, metadata(server))
        .then(response => get_data_schema_vec(response.toObject().resultsList));
}

/**
 * Read multiple data by set uuid and last time
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataSetTime} request dataset time: set_id, timestamp
 * @returns {Promise<DataSchema[]>} data schema: device_id, model_id, timestamp, data
 */
async function list_data_by_set_last_time(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const datasetTime = new pb_data.DataSetTime();
    datasetTime.setSetId(uuid_hex_to_base64(request.set_id));
    datasetTime.setTimestamp(request.timestamp.valueOf() * 1000);
    return client.listDataBySetLastTime(datasetTime, metadata(server))
        .then(response => get_data_schema_vec(response.toObject().resultsList));
}

/**
 * Read multiple data by set uuid and range time
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataSetRange} request dataset range: set_id, begin, end
 * @returns {Promise<DataSchema[]>} data schema: device_id, model_id, timestamp, data
 */
async function list_data_by_set_range_time(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const datasetRange = new pb_data.DataSetRange();
    datasetRange.setSetId(uuid_hex_to_base64(request.set_id));
    datasetRange.setBegin(request.begin.valueOf() * 1000);
    datasetRange.setEnd(request.end.valueOf() * 1000);
    return client.listDataBySetRangeTime(datasetRange, metadata(server))
        .then(response => get_data_schema_vec(response.toObject().resultsList));
}

/**
 * Read multiple data by set uuid and specific time and number before
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataSetNumber} request dataset time and number: set_id, timestamp, number
 * @returns {Promise<DataSchema[]>} data schema: device_id, model_id, timestamp, data
 */
async function list_data_by_set_number_before(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const datasetNumber = new pb_data.DataSetNumber();
    datasetNumber.setSetId(uuid_hex_to_base64(request.set_id));
    datasetNumber.setTimestamp(request.timestamp.valueOf() * 1000);
    datasetNumber.setNumber(request.number);
    return client.listDataBySetNumberBefore(datasetNumber, metadata(server))
        .then(response => get_data_schema_vec(response.toObject().resultsList));
}

/**
 * Read multiple data by set uuid and specific time and number after
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataSetNumber} request dataset time and number: set_id, timestamp, number
 * @returns {Promise<DataSchema[]>} data schema: device_id, model_id, timestamp, data
 */
async function list_data_by_set_number_after(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const datasetNumber = new pb_data.DataSetNumber();
    datasetNumber.setSetId(uuid_hex_to_base64(request.set_id));
    datasetNumber.setTimestamp(request.timestamp.valueOf() * 1000);
    datasetNumber.setNumber(request.number);
    return client.listDataBySetNumberAfter(datasetNumber, metadata(server))
        .then(response => get_data_schema_vec(response.toObject().resultsList));
}

/**
 * Read a dataset by id
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataSetId} request dataset id: set_id, timestamp
 * @returns {Promise<DataSetSchema>} data schema: set_id, timestamp, data
 */
async function read_data_set(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const dataId = new pb_data.DataSetId();
    dataId.setSetId(uuid_hex_to_base64(request.set_id));
    dataId.setTimestamp(request.timestamp.valueOf() * 1000);
    return client.readDataSet(dataId, metadata(server))
        .then(response => get_data_set_schema(response.toObject().result));
}

/**
 * Read multiple dataset by last time
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataSetTime} request dataset time: set_id, timestamp
 * @returns {Promise<DataSetSchema[]>} data schema: device_id, model_id, timestamp, data
 */
async function list_data_set_by_last_time(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const datasetTime = new pb_data.DataSetTime();
    datasetTime.setSetId(uuid_hex_to_base64(request.set_id));
    datasetTime.setTimestamp(request.timestamp.valueOf() * 1000);
    return client.listDataSetByLastTime(datasetTime, metadata(server))
        .then(response => get_data_set_schema_vec(response.toObject().resultsList));
}

/**
 * Read multiple dataset by range time
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataSetRange} request dataset range: set_id, begin, end
 * @returns {Promise<DataSetSchema[]>} data schema: device_id, model_id, timestamp, data
 */
async function list_data_set_by_range_time(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const datasetRange = new pb_data.DataSetRange();
    datasetRange.setSetId(uuid_hex_to_base64(request.set_id));
    datasetRange.setBegin(request.begin.valueOf() * 1000);
    datasetRange.setEnd(request.end.valueOf() * 1000);
    return client.listDataSetByRangeTime(datasetRange, metadata(server))
        .then(response => get_data_set_schema_vec(response.toObject().resultsList));
}

/**
 * Read multiple dataset by specific time and number before
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataSetNumber} request dataset time and number: set_id, timestamp, number
 * @returns {Promise<DataSetSchema[]>} data schema: device_id, model_id, timestamp, data
 */
async function list_data_set_by_number_before(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const datasetNumber = new pb_data.DataSetNumber();
    datasetNumber.setSetId(uuid_hex_to_base64(request.set_id));
    datasetNumber.setTimestamp(request.timestamp.valueOf() * 1000);
    datasetNumber.setNumber(request.number);
    return client.listDataSetByNumberBefore(datasetNumber, metadata(server))
        .then(response => get_data_set_schema_vec(response.toObject().resultsList));
}

/**
 * Read multiple dataset by specific time and number after
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataSetNumber} request dataset time and number: set_id, timestamp, number
 * @returns {Promise<DataSetSchema[]>} data schema: device_id, model_id, timestamp, data
 */
async function list_data_set_by_number_after(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const datasetNumber = new pb_data.DataSetNumber();
    datasetNumber.setSetId(uuid_hex_to_base64(request.set_id));
    datasetNumber.setTimestamp(request.timestamp.valueOf() * 1000);
    datasetNumber.setNumber(request.number);
    return client.listDataSetByNumberAfter(datasetNumber, metadata(server))
        .then(response => get_data_set_schema_vec(response.toObject().resultsList));
}

/**
 * Create a data
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataSchema} request data schema: device_id, model_id, timestamp, data
 * @returns {Promise<{}>} create response
 */
async function create_data(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const dataSchema = new pb_data.DataSchema();
    dataSchema.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataSchema.setModelId(uuid_hex_to_base64(request.model_id));
    dataSchema.setTimestamp(request.timestamp.valueOf() * 1000);
    const value = set_data_values(request.data);
    dataSchema.setDataBytes(value.bytes);
    for (const type of value.types) {
        dataSchema.addDataType(type);
    }
    return client.createData(dataSchema, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete a data
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataId} request data id: device_id, model_id, timestamp
 * @returns {Promise<{}>} delete response
 */
async function delete_data(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const dataId = new pb_data.DataId();
    dataId.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataId.setModelId(uuid_hex_to_base64(request.model_id));
    dataId.setTimestamp(request.timestamp.valueOf() * 1000);
    return client.deleteData(dataId, metadata(server))
        .then(response => response.toObject());
}

/**
 * Read a data timestamp by id
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataId} request data id: device_id, model_id, timestamp
 * @returns {Promise<Date>} data timestamp
 */
async function read_data_timestamp(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const dataId = new pb_data.DataId();
    dataId.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataId.setModelId(uuid_hex_to_base64(request.model_id));
    dataId.setTimestamp(request.timestamp.valueOf() * 1000);
    return client.readDataTimestamp(dataId, metadata(server))
        .then(response => new Date(response.toObject().timestamp / 1000));
}

/**
 * Read multiple data timestamp by last time
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataTime} request data time: device_id, model_id, timestamp
 * @returns {Promise<Date[]>} data timestamp
 */
async function list_data_timestamp_by_last_time(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const dataTime = new pb_data.DataTime();
    dataTime.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataTime.setModelId(uuid_hex_to_base64(request.model_id));
    dataTime.setTimestamp(request.timestamp.valueOf() * 1000);
    return client.listDataTimestampByLastTime(dataTime, metadata(server))
        .then(response => response.toObject().timestampsList.map((v) => new Date(v / 1000)));
}

/**
 * Read multiple data timestamp by range time
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataRange} request data range: device_id, model_id, begin, end
 * @returns {Promise<Date[]>} data timestamp
 */
async function list_data_timestamp_by_range_time(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const dataRange = new pb_data.DataRange();
    dataRange.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataRange.setModelId(uuid_hex_to_base64(request.model_id));
    dataRange.setBegin(request.begin.valueOf() * 1000);
    dataRange.setEnd(request.end.valueOf() * 1000);
    return client.listDataTimestampByRangeTime(dataRange, metadata(server))
        .then(response => response.toObject().timestampsList.map((v) => new Date(v / 1000)));
}

/**
 * Read a data set timestamp by id
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataSetId} request data set id: set_id, timestamp
 * @returns {Promise<Date>} data set timestamp
 */
async function read_data_timestamp_by_set(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const dataId = new pb_data.DataSetId();
    dataId.setSetId(uuid_hex_to_base64(request.set_id));
    dataId.setTimestamp(request.timestamp.valueOf() * 1000);
    return client.readDataTimestampBySet(dataId, metadata(server))
        .then(response => new Date(response.toObject().timestamp / 1000));
}

/**
 * Read multiple data set timestamp by last time
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataSetTime} request data set time: set_id, timestamp
 * @returns {Promise<Date[]>} data set timestamp
 */
async function list_data_timestamp_by_set_last_time(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const dataTime = new pb_data.DataSetTime();
    dataTime.setSetId(uuid_hex_to_base64(request.set_id));
    dataTime.setTimestamp(request.timestamp.valueOf() * 1000);
    return client.listDataTimestampBySetLastTime(dataTime, metadata(server))
        .then(response => response.toObject().timestampsList.map((v) => new Date(v / 1000)));
}

/**
 * Read multiple data set timestamp by range time
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataSetRange} request data set range: set_id, begin, end
 * @returns {Promise<Date[]>} data set timestamp
 */
async function list_data_timestamp_by_set_range_time(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const dataRange = new pb_data.DataSetRange();
    dataRange.setSetId(uuid_hex_to_base64(request.set_id));
    dataRange.setBegin(request.begin.valueOf() * 1000);
    dataRange.setEnd(request.end.valueOf() * 1000);
    return client.listDataTimestampBySetRangeTime(dataRange, metadata(server))
        .then(response => response.toObject().timestampsList.map((v) => new Date(v / 1000)));
}

/**
 * Count data
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataCount} request data count: device_id, model_id
 * @returns {Promise<DataCountResult>} data count: count
 */
async function count_data(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const dataCount = new pb_data.DataCount();
    dataCount.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataCount.setModelId(uuid_hex_to_base64(request.model_id));
    return client.countData(dataCount, metadata(server))
        .then(response => response.toObject());
}

/**
 * Count data by last time
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataCount} request data count: device_id, model_id, timestamp
 * @returns {Promise<DataCountResult>} data count: count
 */
async function count_data_by_last_time(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const dataCount = new pb_data.DataCount();
    dataCount.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataCount.setModelId(uuid_hex_to_base64(request.model_id));
    if (request.timestamp) {
        dataCount.setTimestamp(request.timestamp.valueOf() * 1000);
    }
    return client.countDataByLastTime(dataCount, metadata(server))
        .then(response => response.toObject());
}

/**
 * Count data by range time
 * @param {ServerConfig} server server configuration: address, token
 * @param {DataCount} request data count: device_id, model_id, begin, end
 * @returns {Promise<DataCountResult>} data count: count
 */
async function count_data_by_range_time(server, request) {
    const client = new pb_data.DataServicePromiseClient(server.address, null, null);
    const dataCount = new pb_data.DataCount();
    dataCount.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataCount.setModelId(uuid_hex_to_base64(request.model_id));
    if (request.begin) {
        dataCount.setTimestamp(request.begin.valueOf() * 1000);
    }
    if (request.end) {
        dataCount.setTimestamp(request.end.valueOf() * 1000);
    }
    return client.countDataByRangeTime(dataCount, metadata(server))
        .then(response => response.toObject());
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} BufferId
 * @property {number} id
 */

/**
 * @param {*} r 
 * @returns {BufferId}
 */
function get_buffer_id(r) {
    return {
        id: r.id
    };
}

/**
 * @typedef {Object} BufferTime
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 * @property {Date} timestamp
 * @property {?number|string} status
 */

/**
 * @typedef {Object} BufferSelector
 * @property {?Uuid} device_id
 * @property {?Uuid} model_id
 * @property {?number|string} status
 */

/**
 * @typedef {Object} BuffersSelector
 * @property {?Uuid} device_id
 * @property {?Uuid} model_id
 * @property {?number|string} status
 * @property {number} number
 * @property {number} offset
 */

/**
 * @typedef {Object} BufferCount
 * @property {?Uuid} device_id
 * @property {?Uuid} model_id
 * @property {?number|string} status
 */

/**
 * @typedef {Object} BufferCountResult
 * @property {number} count
 */

/**
 * @typedef {Object} BufferSchema
 * @property {number} id
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 * @property {Date} timestamp
 * @property {(number|bigint|string|Uint8Array|boolean)[]} data
 * @property {number|string} status
 */

/**
 * @param {*} r 
 * @returns {BufferSchema}
 */
function get_buffer_schema(r) {
    return {
        id: r.id,
        device_id: base64_to_uuid_hex(r.deviceId),
        model_id: base64_to_uuid_hex(r.modelId),
        timestamp: new Date(r.timestamp / 1000),
        data: get_data_values(r.dataBytes, r.dataTypeList),
        status: get_buffer_status(r.status)
    };
}

/**
 * @param {*} r 
 * @returns {BufferSchema[]}
 */
function get_buffer_schema_vec(r) {
    return r.map((v) => {return get_buffer_schema(v)});
}

/**
 * @typedef {Object} BufferUpdate
 * @property {number} id
 * @property {?number|bigint|string|boolean} data
 * @property {?number|string} status
 */

/**
 * @param {number} status 
 * @returns {number|string}
 */
function get_buffer_status(status) {
    switch (status) {
        case 0: return "DEFAULT";
        case 1: return "ERROR";
        case 2: return "DELETE";
        case 3: return "HOLD";
        case 4: return "SEND_UPLINK";
        case 5: return "SEND_DOWNLINK";
        case 6: return "TRANSFER_LOCAL";
        case 7: return "TRANSFER_GATEWAY";
        case 8: return "TRANSFER_SERVER";
        case 9: return "BACKUP";
        case 10: return "RESTORE";
        case 11: return "ANALYSIS_1";
        case 12: return "ANALYSIS_2";
        case 13: return "ANALYSIS_3";
        case 14: return "ANALYSIS_4";
        case 15: return "ANALYSIS_5";
        case 16: return "ANALYSIS_6";
        case 17: return "ANALYSIS_7";
        case 18: return "ANALYSIS_8";
        case 19: return "ANALYSIS_9";
        case 20: return "ANALYSIS_10";
        case 21: return "EXTERNAL_OUTPUT";
        case 22: return "EXTERNAL_INPUT";
    }
    return status;
}

/**
 * @param {number|string} status 
 * @returns {number}
 */
function set_buffer_status(status) {
    if (typeof status == "number") {
        return status;
    }
    if (typeof status == "string") {
        status = status.replace(/[a-z][A-Z]/, s => `${s.charAt(0)}_${s.charAt(1)}`);
        switch (status.toUpperCase()) {
            case "DEFAULT": return 0;
            case "ERROR": return 1;
            case "DELETE": return 2;
            case "HOLD": return 3;
            case "SEND_UPLINK": return 4;
            case "SEND_DOWNLINK": return 5;
            case "TRANSFER_LOCAL": return 6;
            case "TRANSFER_GATEWAY": return 7;
            case "TRANSFER_SERVER": return 8;
            case "BACKUP": return 9;
            case "RESTORE": return 10;
            case "ANALYSIS_1": return 11;
            case "ANALYSIS_2": return 12;
            case "ANALYSIS_3": return 13;
            case "ANALYSIS_4": return 14;
            case "ANALYSIS_5": return 15;
            case "ANALYSIS_6": return 16;
            case "ANALYSIS_7": return 17;
            case "ANALYSIS_8": return 18;
            case "ANALYSIS_9": return 19;
            case "ANALYSIS_10": return 20;
            case "EXTERNAL_INPUT": return 21;
            case "EXTERNAL_OUTPUT": return 22;
        }
    }
    return 0;
}


/**
 * Read a data buffer by id
 * @param {ServerConfig} server server configuration: address, token
 * @param {BufferId} request data buffer id: id
 * @returns {Promise<BufferSchema>} data buffer schema: id, device_id, model_id, timestamp, data, status
 */
async function read_buffer(server, request) {
    const client = new pb_buffer.BufferServicePromiseClient(server.address, null, null);
    const bufferId = new pb_buffer.BufferId();
    bufferId.setId(request.id);
    return client.readBuffer(bufferId, metadata(server))
        .then(response => get_buffer_schema(response.toObject().result));
}

/**
 * Read a data buffer by time
 * @param {ServerConfig} server server configuration: address, token
 * @param {BufferTime} request data buffer time: device_id, model_id, timestamp, status
 * @returns {Promise<BufferSchema>} data buffer schema: id, device_id, model_id, timestamp, data, status
 */
async function read_buffer_by_time(server, request) {
    const client = new pb_buffer.BufferServicePromiseClient(server.address, null, null);
    const bufferTime = new pb_buffer.BufferTime();
    bufferTime.setDeviceId(uuid_hex_to_base64(request.device_id));
    bufferTime.setModelId(uuid_hex_to_base64(request.model_id));
    bufferTime.setTimestamp(request.timestamp.valueOf() * 1000);
    bufferTime.setStatus(set_buffer_status(request.status));
    return client.readBufferByTime(bufferTime, metadata(server))
        .then(response => get_buffer_schema(response.toObject().result));
}

/**
 * Read first of a data buffer
 * @param {ServerConfig} server server configuration: address, token
 * @param {BufferSelector} request data buffer selector: device_id, model_id, status
 * @returns {Promise<BufferSchema>} data buffer schema: id, device_id, model_id, timestamp, data, status
 */
async function read_buffer_first(server, request) {
    const client = new pb_buffer.BufferServicePromiseClient(server.address, null, null);
    const bufferSelector = new pb_buffer.BufferSelector();
    if (request.device_id) {
        bufferSelector.setDeviceId(uuid_hex_to_base64(request.device_id));
    }
    if (request.model_id) {
        bufferSelector.setModelId(uuid_hex_to_base64(request.model_id));
    }
    if (typeof request.status == "number" || typeof request.status == "string") {
        bufferSelector.setStatus(set_buffer_status(request.status));
    }
    return client.readBufferFirst(bufferSelector, metadata(server))
        .then(response => get_buffer_schema(response.toObject().result));
}

/**
 * Read last of a data buffer
 * @param {ServerConfig} server server configuration: address, token
 * @param {BufferSelector} request data buffer selector: device_id, model_id, status
 * @returns {Promise<BufferSchema>} data buffer schema: id, device_id, model_id, timestamp, data, status
 */
async function read_buffer_last(server, request) {
    const client = new pb_buffer.BufferServicePromiseClient(server.address, null, null);
    const bufferSelector = new pb_buffer.BufferSelector();
    if (request.device_id) {
        bufferSelector.setDeviceId(uuid_hex_to_base64(request.device_id));
    }
    if (request.model_id) {
        bufferSelector.setModelId(uuid_hex_to_base64(request.model_id));
    }
    if (typeof request.status == "number" || typeof request.status == "string") {
        bufferSelector.setStatus(set_buffer_status(request.status));
    }
    return client.readBufferLast(bufferSelector, metadata(server))
        .then(response => get_buffer_schema(response.toObject().result));
}

/**
 * Read first of data buffers
 * @param {ServerConfig} server server configuration: address, token
 * @param {BuffersSelector} request data buffer selector: device_id, model_id, status, number
 * @returns {Promise<BufferSchema[]>} data buffer schema: id, device_id, model_id, timestamp, data, status
 */
async function list_buffer_first(server, request) {
    const client = new pb_buffer.BufferServicePromiseClient(server.address, null, null);
    const buffersSelector = new pb_buffer.BuffersSelector();
    if (request.device_id) {
        buffersSelector.setDeviceId(uuid_hex_to_base64(request.device_id));
    }
    if (request.model_id) {
        buffersSelector.setModelId(uuid_hex_to_base64(request.model_id));
    }
    if (typeof request.status == "number" || typeof request.status == "string") {
        buffersSelector.setStatus(set_buffer_status(request.status));
    }
    buffersSelector.setNumber(request.number);
    return client.listBufferFirst(buffersSelector, metadata(server))
        .then(response => get_buffer_schema_vec(response.toObject().resultsList));
}

/**
 * Read first of data buffers with offset
 * @param {ServerConfig} server server configuration: address, token
 * @param {BuffersSelector} request data buffer selector: device_id, model_id, status, number, offset
 * @returns {Promise<BufferSchema[]>} data buffer schema: id, device_id, model_id, timestamp, data, status
 */
async function list_buffer_first_offset(server, request) {
    const client = new pb_buffer.BufferServicePromiseClient(server.address, null, null);
    const buffersSelector = new pb_buffer.BuffersSelector();
    if (request.device_id) {
        buffersSelector.setDeviceId(uuid_hex_to_base64(request.device_id));
    }
    if (request.model_id) {
        buffersSelector.setModelId(uuid_hex_to_base64(request.model_id));
    }
    if (typeof request.status == "number" || typeof request.status == "string") {
        buffersSelector.setStatus(set_buffer_status(request.status));
    }
    buffersSelector.setNumber(request.number);
    buffersSelector.setOffset(request.offset);
    return client.listBufferFirstOffset(buffersSelector, metadata(server))
        .then(response => get_buffer_schema_vec(response.toObject().resultsList));
}

/**
 * Read last of data buffers
 * @param {ServerConfig} server server configuration: address, token
 * @param {BuffersSelector} request data buffer selector: device_id, model_id, status, number
 * @returns {Promise<BufferSchema[]>} data buffer schema: id, device_id, model_id, timestamp, data, status
 */
async function list_buffer_last(server, request) {
    const client = new pb_buffer.BufferServicePromiseClient(server.address, null, null);
    const buffersSelector = new pb_buffer.BuffersSelector();
    if (request.device_id) {
        buffersSelector.setDeviceId(uuid_hex_to_base64(request.device_id));
    }
    if (request.model_id) {
        buffersSelector.setModelId(uuid_hex_to_base64(request.model_id));
    }
    if (typeof request.status == "number" || typeof request.status == "string") {
        buffersSelector.setStatus(set_buffer_status(request.status));
    }
    buffersSelector.setNumber(request.number);
    return client.listBufferLast(buffersSelector, metadata(server))
        .then(response => get_buffer_schema_vec(response.toObject().resultsList));
}

/**
 * Read last of data buffers with offset
 * @param {ServerConfig} server server configuration: address, token
 * @param {BuffersSelector} request data buffer selector: device_id, model_id, status, number, offset
 * @returns {Promise<BufferSchema[]>} data buffer schema: id, device_id, model_id, timestamp, data, status
 */
async function list_buffer_last_offset(server, request) {
    const client = new pb_buffer.BufferServicePromiseClient(server.address, null, null);
    const buffersSelector = new pb_buffer.BuffersSelector();
    if (request.device_id) {
        buffersSelector.setDeviceId(uuid_hex_to_base64(request.device_id));
    }
    if (request.model_id) {
        buffersSelector.setModelId(uuid_hex_to_base64(request.model_id));
    }
    if (typeof request.status == "number" || typeof request.status == "string") {
        buffersSelector.setStatus(set_buffer_status(request.status));
    }
    buffersSelector.setNumber(request.number);
    buffersSelector.setOffset(request.offset);
    return client.listBufferLastOffset(buffersSelector, metadata(server))
        .then(response => get_buffer_schema_vec(response.toObject().resultsList));
}

/**
 * Create a data buffer
 * @param {ServerConfig} server server configuration: address, token
 * @param {BufferSchema} request data buffer schema: device_id, model_id, timestamp, data, status
 * @returns {Promise<BufferId>} data buffer id: id
 */
async function create_buffer(server, request) {
    const client = new pb_buffer.BufferServicePromiseClient(server.address, null, null);
    const bufferSchema = new pb_buffer.BufferSchema();
    bufferSchema.setDeviceId(uuid_hex_to_base64(request.device_id));
    bufferSchema.setModelId(uuid_hex_to_base64(request.model_id));
    bufferSchema.setTimestamp(request.timestamp.valueOf() * 1000);
    const value = set_data_values(request.data);
    bufferSchema.setDataBytes(value.bytes);
    for (const type of value.types) {
        bufferSchema.addDataType(type);
    }
    bufferSchema.setStatus(set_buffer_status(request.status));
    return client.createBuffer(bufferSchema, metadata(server))
        .then(response => get_buffer_id(response.toObject()));
}

/**
 * Update a data buffer
 * @param {ServerConfig} server server configuration: address, token
 * @param {BufferUpdate} request data buffer update: id, data, status
* @returns {Promise<{}>} update response
 */
async function update_buffer(server, request) {
    const client = new pb_buffer.BufferServicePromiseClient(server.address, null, null);
    const bufferUpdate = new pb_buffer.BufferUpdate();
    bufferUpdate.setId(request.id);
    const ty = typeof request.data;
    if (ty == "number" || ty == "string" || ty == "bigint" || ty == "boolean") {
        const value = set_data_values(request.data);
        bufferUpdate.setDataBytes(value.bytes);
        for (const type of value.types) {
            bufferUpdate.addDataType(type);
        }
    }
    bufferUpdate.setStatus(set_buffer_status(request.status));
    return client.updateBuffer(bufferUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete a data buffer
 * @param {ServerConfig} server server configuration: address, token
 * @param {BufferId} request data buffer id: id
* @returns {Promise<{}>} delete response
 */
async function delete_buffer(server, request) {
    const client = new pb_buffer.BufferServicePromiseClient(server.address, null, null);
    const bufferId = new pb_buffer.BufferId();
    bufferId.setId(request.id);
    return client.deleteBuffer(bufferId, metadata(server))
        .then(response => response.toObject());
}

/**
 * Count data buffers
 * @param {ServerConfig} server server configuration: address, token
 * @param {BufferCount} request data buffer count: device_id, model_id, status
 * @returns {Promise<BufferCountResult>} data buffer count: count
 */
async function count_buffer(server, request) {
    const client = new pb_buffer.BufferServicePromiseClient(server.address, null, null);
    const bufferCount = new pb_buffer.BufferCount();
    if (request.device_id) {
        bufferCount.setDeviceId(uuid_hex_to_base64(request.device_id));
    }
    if (request.model_id) {
        bufferCount.setModelId(uuid_hex_to_base64(request.model_id));
    }
    if (typeof request.status == "number" || typeof request.status == "string") {
        bufferCount.setStatus(set_buffer_status(request.status));
    }
    return client.countBuffer(bufferCount, metadata(server))
        .then(response => response.toObject());
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} SliceId
 * @property {number} id
 */

/**
 * @param {*} r 
 * @returns {SliceId}
 */
function get_slice_id(r) {
    return {
        id: r.id    
    };
}

/**
 * @typedef {Object} SliceTime
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 * @property {Date} timestamp
 */

/**
 * @typedef {Object} SliceRange
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 * @property {Date} begin
 * @property {Date} end
 */

/**
 * @typedef {Object} SliceNameTime
 * @property {string} name
 * @property {Date} timestamp
 */

/**
 * @typedef {Object} SliceNameRange
 * @property {string} name
 * @property {Date} begin
 * @property {Date} end
 */

/**
 * @typedef {Object} SliceOption
 * @property {?Uuid} device_id
 * @property {?Uuid} model_id
 * @property {?string} name
 * @property {?Date} begin_or_timestamp
 * @property {?Date} end
 */

/**
 * @typedef {Object} SliceSchema
 * @property {number} id
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 * @property {Date} timestamp_begin
 * @property {Date} timestamp_end
 * @property {string} name
 * @property {string} description
 */

/**
 * @param {*} r 
 * @returns {SliceSchema}
 */
function get_slice_schema(r) {
    return {
        id: r.id,
        device_id: base64_to_uuid_hex(r.deviceId),
        model_id: base64_to_uuid_hex(r.modelId),
        timestamp_begin: new Date(r.timestampBegin / 1000),
        timestamp_end: new Date(r.timestampEnd / 1000),
        name: r.name,
        description: r.description
    };
}

/**
 * @param {*} r 
 * @returns {SliceSchema[]}
 */
function get_slice_schema_vec(r) {
    return r.map((v) => {return get_slice_schema(v)});
}

/**
 * @typedef {Object} SliceUpdate
 * @property {number} id
 * @property {?Date} timestamp_begin
 * @property {?Date} timestamp_end
 * @property {?string} name
 * @property {?string} description
 */

/**
 * @typedef {Object} SliceSetTime
 * @property {Uuid} set_id
 * @property {Date} timestamp
 */

/**
 * @typedef {Object} SliceSetRange
 * @property {Uuid} set_id
 * @property {Date} begin
 * @property {Date} end
 */

/**
 * @typedef {Object} SliceSetOption
 * @property {Uuid} set_id
 * @property {?string} name
 * @property {?Date} begin_or_timestamp
 * @property {?Date} end
 */

/**
 * @typedef {Object} SliceSetSchema
 * @property {number} id
 * @property {Uuid} set_id
 * @property {Date} timestamp_begin
 * @property {Date} timestamp_end
 * @property {string} name
 * @property {string} description
 */

/**
 * @param {*} r 
 * @returns {SliceSetSchema}
 */
function get_slice_set_schema(r) {
    return {
        id: r.id,
        set_id: base64_to_uuid_hex(r.setId),
        timestamp_begin: new Date(r.timestampBegin / 1000),
        timestamp_end: new Date(r.timestampEnd / 1000),
        name: r.name,
        description: r.description
    };
}

/**
 * @param {*} r 
 * @returns {SliceSetSchema[]}
 */
function get_slice_set_schema_vec(r) {
    return r.map((v) => {return get_slice_set_schema(v)});
}


/**
 * Read a data slice by id
 * @param {ServerConfig} server server configuration: address, token
 * @param {SliceId} request data slice id: id
 * @returns {Promise<SliceSchema>} data slice schema: device_id, model_id, timestamp_begin, timestamp_end, name, description
 */
async function read_slice(server, request) {
    const client = new pb_slice.SliceServicePromiseClient(server.address, null, null);
    const sliceId = new pb_slice.SliceId();
    sliceId.setId(request.id);
    return client.readSlice(sliceId, metadata(server))
        .then(response => get_slice_schema(response.toObject().result));
}

/**
 * Read data slices by specific time
 * @param {ServerConfig} server server configuration: address, token
 * @param {SliceTime} request data slice time: device_id, model_id, timestamp
 * @returns {Promise<SliceSchema[]>} data slice schema: device_id, model_id, timestamp_begin, timestamp_end, name, description
 */
async function list_slice_by_time(server, request) {
    const client = new pb_slice.SliceServicePromiseClient(server.address, null, null);
    const sliceTime = new pb_slice.SliceTime();
    sliceTime.setDeviceId(uuid_hex_to_base64(request.device_id));
    sliceTime.setModelId(uuid_hex_to_base64(request.model_id));
    sliceTime.setTimestamp(request.timestamp.valueOf() * 1000);
    return client.listSliceByTime(sliceTime, metadata(server))
        .then(response => get_slice_schema_vec(response.toObject().resultsList));
}

/**
 * Read data slices by range time
 * @param {ServerConfig} server server configuration: address, token
 * @param {SliceRange} request data slice range: device_id, model_id, begin, end
 * @returns {Promise<SliceSchema[]>} data slice schema: device_id, model_id, timestamp_begin, timestamp_end, name, description
 */
async function list_slice_by_range_time(server, request) {
    const client = new pb_slice.SliceServicePromiseClient(server.address, null, null);
    const sliceRange = new pb_slice.SliceRange();
    sliceRange.setDeviceId(uuid_hex_to_base64(request.device_id));
    sliceRange.setModelId(uuid_hex_to_base64(request.model_id));
    sliceRange.setBegin(request.begin.valueOf() * 1000);
    sliceRange.setEnd(request.end.valueOf() * 1000);
    return client.listSliceByRangeTime(sliceRange, metadata(server))
        .then(response => get_slice_schema_vec(response.toObject().resultsList));
}

/**
 * Read data slices by name and specific time
 * @param {ServerConfig} server server configuration: address, token
 * @param {SliceNameTime} request data slice name and time: name, timestamp
 * @returns {Promise<SliceSchema[]>} data slice schema: device_id, model_id, timestamp_begin, timestamp_end, name, description
 */
async function list_slice_by_name_time(server, request) {
    const client = new pb_slice.SliceServicePromiseClient(server.address, null, null);
    const sliceNameTime = new pb_slice.SliceNameTime();
    sliceNameTime.setName(request.name);
    sliceNameTime.setTimestamp(request.timestamp.valueOf() * 1000);
    return client.listSliceByNameTime(sliceNameTime, metadata(server))
        .then(response => get_slice_schema_vec(response.toObject().resultsList));
}

/**
 * Read data slices by name and range time
 * @param {ServerConfig} server server configuration: address, token
 * @param {SliceNameRange} request data slice name and range: name, begin, end
 * @returns {Promise<SliceSchema[]>} data slice schema: device_id, model_id, timestamp_begin, timestamp_end, name, description
 */
async function list_slice_by_name_range_time(server, request) {
    const client = new pb_slice.SliceServicePromiseClient(server.address, null, null);
    const sliceNameRange = new pb_slice.SliceNameRange();
    sliceNameRange.setName(request.name);
    sliceNameRange.setBegin(request.begin.valueOf() * 1000);
    sliceNameRange.setEnd(request.end.valueOf() * 1000);
    return client.listSliceByNameRangeTime(sliceNameRange, metadata(server))
        .then(response => get_slice_schema_vec(response.toObject().resultsList));
}

/**
 * Read data slices by options
 * @param {ServerConfig} server server configuration: address, token
 * @param {SliceOption} request data slice selection option: device_id, model_id, name, begin_or_timestamp, end
 * @returns {Promise<SliceSchema[]>} data slice schema: device_id, model_id, timestamp_begin, timestamp_end, name, description
 */
async function list_slice_option(server, request) {
    const client = new pb_slice.SliceServicePromiseClient(server.address, null, null);
    const sliceOption = new pb_slice.SliceOption();
    if (request.device_id) {
        sliceOption.setDeviceId(uuid_hex_to_base64(request.device_id));
    }
    if (request.model_id) {
        sliceOption.setModelId(uuid_hex_to_base64(request.model_id));
    }
    sliceOption.setName(request.name);
    if (request.begin instanceof Date) {
        sliceOption.setBegin(request.timestamp_begin.valueOf() * 1000);
    }
    if (request.end instanceof Date) {
        sliceOption.setEnd(request.timestamp_end.valueOf() * 1000);
    }
    return client.listSliceOption(sliceOption, metadata(server))
        .then(response => get_slice_schema_vec(response.toObject().resultsList));
}

/**
 * Create a data slice
 * @param {ServerConfig} server server configuration: address, token
 * @param {SliceSchema} request data slice schema: device_id, model_id, timestamp_begin, timestamp_end, name, description
 * @returns {Promise<SliceId>} data slice id: id
 */
async function create_slice(server, request) {
    const client = new pb_slice.SliceServicePromiseClient(server.address, null, null);
    const sliceSchema = new pb_slice.SliceSchema();
    sliceSchema.setDeviceId(uuid_hex_to_base64(request.device_id));
    sliceSchema.setModelId(uuid_hex_to_base64(request.model_id));
    sliceSchema.setTimestampBegin(request.timestamp_begin.valueOf() * 1000);
    sliceSchema.setTimestampEnd(request.timestamp_end.valueOf() * 1000);
    sliceSchema.setName(request.name);
    sliceSchema.setDescription(request.description);
    return client.createSlice(sliceSchema, metadata(server))
        .then(response => get_slice_id(response.toObject()));
}

/**
 * Update a data slice
 * @param {ServerConfig} server server configuration: address, token
 * @param {SliceUpdate} request data slice update: id, timestamp_begin, timestamp_end, name, description
 * @returns {Promise<{}>} update response
 */
async function update_slice(server, request) {
    const client = new pb_slice.SliceServicePromiseClient(server.address, null, null);
    const sliceUpdate = new pb_slice.SliceUpdate();
    sliceUpdate.setId(request.id);
    if (request.timestamp_begin instanceof Date) {
        sliceUpdate.setTimestampBegin(request.timestamp_begin.valueOf() * 1000);
    }
    if (request.timestamp_end instanceof Date) {
        sliceUpdate.setTimestampEnd(request.timestamp_end.valueOf() * 1000);
    }
    sliceUpdate.setName(request.name);
    sliceUpdate.setDescription(request.description);
    return client.updateSlice(sliceUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete a data slice
 * @param {ServerConfig} server server configuration: address, token
 * @param {SliceId} request data slice id: id
 * @returns {Promise<{}>} delete response
 */
async function delete_slice(server, request) {
    const client = new pb_slice.SliceServicePromiseClient(server.address, null, null);
    const sliceId = new pb_slice.SliceId();
    sliceId.setId(request.id);
    return client.deleteSlice(sliceId, metadata(server))
        .then(response => response.toObject());
}

/**
 * Read a data set slice by id
 * @param {ServerConfig} server server configuration: address, token
 * @param {SliceId} request data set slice id: id
 * @returns {Promise<SliceSetSchema>} data set slice schema: set_id, timestamp_begin, timestamp_end, name, description
 */
async function read_slice_set(server, request) {
    const client = new pb_slice.SliceServicePromiseClient(server.address, null, null);
    const sliceId = new pb_slice.SliceId();
    sliceId.setId(request.id);
    return client.readSliceSet(sliceId, metadata(server))
        .then(response => get_slice_set_schema(response.toObject().result));
}

/**
 * Read data set slices by specific time
 * @param {ServerConfig} server server configuration: address, token
 * @param {SliceSetTime} request data set slice time: set_id, timestamp
 * @returns {Promise<SliceSetSchema[]>} data set slice schema: set_id, timestamp_begin, timestamp_end, name, description
 */
async function list_slice_set_by_time(server, request) {
    const client = new pb_slice.SliceServicePromiseClient(server.address, null, null);
    const sliceTime = new pb_slice.SliceSetTime();
    sliceTime.setSetId(uuid_hex_to_base64(request.set_id));
    sliceTime.setTimestamp(request.timestamp.valueOf() * 1000);
    return client.listSliceSetByTime(sliceTime, metadata(server))
        .then(response => get_slice_set_schema_vec(response.toObject().resultsList));
}

/**
 * Read data set slices by range time
 * @param {ServerConfig} server server configuration: address, token
 * @param {SliceSetRange} request data set slice range: set_id, begin, end
 * @returns {Promise<SliceSetSchema[]>} data set slice schema: set_id, timestamp_begin, timestamp_end, name, description
 */
async function list_slice_set_by_range_time(server, request) {
    const client = new pb_slice.SliceServicePromiseClient(server.address, null, null);
    const sliceRange = new pb_slice.SliceSetRange();
    sliceRange.setSetId(uuid_hex_to_base64(request.set_id));
    sliceRange.setBegin(request.begin.valueOf() * 1000);
    sliceRange.setEnd(request.end.valueOf() * 1000);
    return client.listSliceSetByRangeTime(sliceRange, metadata(server))
        .then(response => get_slice_set_schema_vec(response.toObject().resultsList));
}

/**
 * Read data set slices by name and specific time
 * @param {ServerConfig} server server configuration: address, token
 * @param {SliceNameTime} request data set slice name and time: name, timestamp
 * @returns {Promise<SliceSetSchema[]>} data slice schema: set_id, timestamp_begin, timestamp_end, name, description
 */
async function list_slice_set_by_name_time(server, request) {
    const client = new pb_slice.SliceServicePromiseClient(server.address, null, null);
    const sliceNameTime = new pb_slice.SliceNameTime();
    sliceNameTime.setName(request.name);
    sliceNameTime.setTimestamp(request.timestamp.valueOf() * 1000);
    return client.listSliceSetByNameTime(sliceNameTime, metadata(server))
        .then(response => get_slice_set_schema_vec(response.toObject().resultsList));
}

/**
 * Read data set slices by name and range time
 * @param {ServerConfig} server server configuration: address, token
 * @param {SliceNameRange} request data set slice name and range: name, begin, end
 * @returns {Promise<SliceSetSchema[]>} data set slice schema: set_id, timestamp_begin, timestamp_end, name, description
 */
async function list_slice_set_by_name_range_time(server, request) {
    const client = new pb_slice.SliceServicePromiseClient(server.address, null, null);
    const sliceNameRange = new pb_slice.SliceNameRange();
    sliceNameRange.setName(request.name);
    sliceNameRange.setBegin(request.begin.valueOf() * 1000);
    sliceNameRange.setEnd(request.end.valueOf() * 1000);
    return client.listSliceSetByNameRangeTime(sliceNameRange, metadata(server))
        .then(response => get_slice_set_schema_vec(response.toObject().resultsList));
}

/**
 * Read data set slices by options
 * @param {ServerConfig} server server configuration: address, token
 * @param {SliceSetOption} request data set slice selection option: set_id, name, begin_or_timestamp, end
 * @returns {Promise<SliceSetSchema[]>} data set slice schema: set_id, timestamp_begin, timestamp_end, name, description
 */
async function list_slice_set_option(server, request) {
    const client = new pb_slice.SliceServicePromiseClient(server.address, null, null);
    const sliceOption = new pb_slice.SliceSetOption();
    if (request.set_id) {
        sliceOption.setSetId(uuid_hex_to_base64(request.set_id));
    }
    sliceOption.setName(request.name);
    if (request.begin instanceof Date) {
        sliceOption.setBegin(request.timestamp_begin.valueOf() * 1000);
    }
    if (request.end instanceof Date) {
        sliceOption.setEnd(request.timestamp_end.valueOf() * 1000);
    }
    return client.listSliceSetOption(sliceOption, metadata(server))
        .then(response => get_slice_set_schema_vec(response.toObject().resultsList));
}

/**
 * Create a data set slice
 * @param {ServerConfig} server server configuration: address, token
 * @param {SliceSetSchema} request data set slice schema: set_id, timestamp_begin, timestamp_end, name, description
 * @returns {Promise<SliceId>} data set slice id: id
 */
async function create_slice_set(server, request) {
    const client = new pb_slice.SliceServicePromiseClient(server.address, null, null);
    const sliceSchema = new pb_slice.SliceSetSchema();
    sliceSchema.setSetId(uuid_hex_to_base64(request.set_id));
    sliceSchema.setTimestampBegin(request.timestamp_begin.valueOf() * 1000);
    sliceSchema.setTimestampEnd(request.timestamp_end.valueOf() * 1000);
    sliceSchema.setName(request.name);
    sliceSchema.setDescription(request.description);
    return client.createSliceSet(sliceSchema, metadata(server))
        .then(response => get_slice_id(response.toObject()));
}

/**
 * Update a data set slice
 * @param {ServerConfig} server server configuration: address, token
 * @param {SliceUpdate} request data set slice update: id, timestamp_begin, timestamp_end, name, description
 * @returns {Promise<{}>} update response
 */
async function update_slice_set(server, request) {
    const client = new pb_slice.SliceServicePromiseClient(server.address, null, null);
    const sliceUpdate = new pb_slice.SliceUpdate();
    sliceUpdate.setId(request.id);
    if (request.timestamp_begin instanceof Date) {
        sliceUpdate.setTimestampBegin(request.timestamp_begin.valueOf() * 1000);
    }
    if (request.timestamp_end instanceof Date) {
        sliceUpdate.setTimestampEnd(request.timestamp_end.valueOf() * 1000);
    }
    sliceUpdate.setName(request.name);
    sliceUpdate.setDescription(request.description);
    return client.updateSliceSet(sliceUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete a data set slice
 * @param {ServerConfig} server server configuration: address, token
 * @param {SliceId} request data set slice id: id
 * @returns {Promise<{}>} delete response
 */
async function delete_slice_set(server, request) {
    const client = new pb_slice.SliceServicePromiseClient(server.address, null, null);
    const sliceId = new pb_slice.SliceId();
    sliceId.setId(request.id);
    return client.deleteSliceSet(sliceId, metadata(server))
        .then(response => response.toObject());
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} LogId
 * @property {Date} timestamp
 * @property {Uuid} device_id
 */

/**
 * @typedef {Object} LogTime
 * @property {Date} timestamp
 * @property {?Uuid} device_id
 * @property {?number|string} status
 */

/**
 * @typedef {Object} LogRange
 * @property {Date} begin
 * @property {Date} end
 * @property {?Uuid} device_id
 * @property {?number|string} status
 */

/**
 * @typedef {Object} LogSchema
 * @property {Date} timestamp
 * @property {Uuid} device_id
 * @property {number|string} status
 * @property {number|bigint|string|Uint8Array|boolean} value
 */

/**
 * @param {*} r 
 * @returns {LogSchema}
 */
function get_log_schema(r) {
    return {
        timestamp: new Date(r.timestamp / 1000),
        device_id: base64_to_uuid_hex(r.deviceId),
        status: get_log_status(r.status),
        value: get_data_value(r.logBytes, r.logType)
    };
}

/**
 * @param {*} r 
 * @returns {LogSchema[]}
 */
function get_log_schema_vec(r) {
    return r.map((v) => {return get_log_schema(v)});
}

/**
 * @typedef {Object} LogUpdate
 * @property {Date} timestamp
 * @property {Uuid} device_id
 * @property {?number|string} status
 * @property {?number|string} value
 */

/**
 * @param {number} status 
 * @returns {number|string}
 */
function get_log_status(status) {
    switch (status) {
        case 0: return "DEFAULT";
        case 1: return "SUCCESS";
        case 2: return "ERROR_SEND";
        case 3: return "ERROR_TRANSFER";
        case 4: return "ERROR_ANALYSIS";
        case 5: return "ERROR_NETWORK";
        case 6: return "FAIL_READ";
        case 7: return "FAIL_CREATE";
        case 8: return "FAIL_UPDATE";
        case 9: return "FAIL_DELETE";
        case 10: return "INVALID_TOKEN";
        case 11: return "INVALID_REQUEST";
        case 12: return "UNKNOWN_ERROR";
        case 13: return "UNKNOWN_STATUS";
    }
    return status;
}

/**
 * @param {number|string} status 
 * @returns {number}
 */
function set_log_status(status) {
    if (typeof status == "number") {
        return status;
    }
    if (typeof status == "string") {
        status = status.replace(/[a-z][A-Z]/, s => `${s.charAt(0)}_${s.charAt(1)}`);
        switch (status.toUpperCase()) {
            case "DEFAULT": return 0;
            case "SUCCESS": return 1;
            case "ERROR_SEND": return 2;
            case "ERROR_TRANSFER": return 3;
            case "ERROR_ANALYSIS": return 4;
            case "ERROR_NETWORK": return 5;
            case "FAIL_READ": return 6;
            case "FAIL_CREATE": return 7;
            case "FAIL_UPDATE": return 8;
            case "FAIL_DELETE": return 9;
            case "INVALID_TOKEN": return 10;
            case "INVALID_REQUEST": return 11;
            case "UNKNOWN_ERROR": return 12;
            case "UNKNOWN_STATUS": return 13;
        }
    }
    return 0;
}


/**
 * Read a system log by id
 * @param {ServerConfig} server server configuration: address, token
 * @param {LogId} request system log id: timestamp, device_id
 * @returns {Promise<LogSchema>} system log schema: timestamp, device_id, status, value
 */
async function read_log(server, request) {
    const client = new pb_log.LogServicePromiseClient(server.address, null, null);
    const logId = new pb_log.LogId();
    logId.setTimestamp(request.timestamp.valueOf() * 1000);
    logId.setDeviceId(uuid_hex_to_base64(request.device_id));
    return client.readLog(logId, metadata(server))
        .then(response => get_log_schema(response.toObject().result));
}

/**
 * Read system logs by time
 * @param {ServerConfig} server server configuration: address, token
 * @param {LogTime} request system log time: timestamp, device_id, status
 * @returns {Promise<LogSchema[]>} system log schema: timestamp, device_id, status, value
 */
async function list_log_by_time(server, request) {
    const client = new pb_log.LogServicePromiseClient(server.address, null, null);
    const logTime = new pb_log.LogTime();
    logTime.setTimestamp(request.timestamp.valueOf() * 1000);
    if (request.device_id) {
        logTime.setDeviceId(uuid_hex_to_base64(request.device_id));
    }
    if (typeof request.status == "number" || typeof request.status == "string") {
        logTime.setStatus(request.status);
    }
    return client.listLogByTime(logTime, metadata(server))
        .then(response => get_log_schema_vec(response.toObject().resultsList));
}

/**
 * Read system logs by last time
 * @param {ServerConfig} server server configuration: address, token
 * @param {LogTime} request system log last time: timestamp, device_id, status
 * @returns {Promise<LogSchema[]>} system log schema: timestamp, device_id, status, value
 */
async function list_log_by_last_time(server, request) {
    const client = new pb_log.LogServicePromiseClient(server.address, null, null);
    const logTime = new pb_log.LogTime();
    logTime.setTimestamp(request.timestamp.valueOf() * 1000);
    if (request.device_id) {
        logTime.setDeviceId(uuid_hex_to_base64(request.device_id));
    }
    if (typeof request.status == "number" || typeof request.status == "string") {
        logTime.setStatus(request.status);
    }
    return client.listLogByLastTime(logTime, metadata(server))
        .then(response => get_log_schema_vec(response.toObject().resultsList));
}

/**
 * Read system logs by range time
 * @param {ServerConfig} server server configuration: address, token
 * @param {LogRange} request system log time: begin, end, device_id, status
 * @returns {Promise<LogSchema[]>} system log schema: timestamp, device_id, status, value
 */
async function list_log_by_range_time(server, request) {
    const client = new pb_log.LogServicePromiseClient(server.address, null, null);
    const logRange = new pb_log.LogRange();
    logRange.setBegin(request.begin.valueOf() * 1000);
    logRange.setEnd(request.end.valueOf() * 1000);
    if (request.device_id) {
        logRange.setDeviceId(uuid_hex_to_base64(request.device_id));
    }
    if (typeof request.status == "number" || typeof request.status == "string") {
        logRange.setStatus(request.status);
    }
    return client.listLogByRangeTime(logRange, metadata(server))
        .then(response => get_log_schema_vec(response.toObject().resultsList));
}

/**
 * Create a system log
 * @param {ServerConfig} server server configuration: address, token
 * @param {LogSchema} request system log schema: timestamp, device_id, status, value
 * @returns {Promise<{}>} create response
 */
async function create_log(server, request) {
    const client = new pb_log.LogServicePromiseClient(server.address, null, null);
    const logSchema = new pb_log.LogSchema();
    logSchema.setTimestamp(request.timestamp.valueOf() * 1000);
    logSchema.setDeviceId(uuid_hex_to_base64(request.device_id));
    logSchema.setStatus(set_log_status(request.status));
    const value = set_data_value(request.value);
    logSchema.setLogBytes(value.bytes);
    logSchema.setLogType(value.type);
    return client.createLog(logSchema, metadata(server))
        .then(response => response.toObject());
}

/**
 * Update a system log
 * @param {ServerConfig} server server configuration: address, token
 * @param {LogUpdate} request system log id: timestamp, device_id, status, value
 * @returns {Promise<{}>} update response
 */
async function update_log(server, request) {
    const client = new pb_log.LogServicePromiseClient(server.address, null, null);
    const logUpdate = new pb_log.LogUpdate();
    logUpdate.setTimestamp(request.timestamp.valueOf() * 1000);
    logUpdate.setDeviceId(uuid_hex_to_base64(request.device_id));
    if (typeof request.status == "number" || typeof request.status == "string") {
        logUpdate.setStatus(set_log_status(request.status));
    }
    const value = set_data_value(request.value);
    logUpdate.setLogBytes(value.bytes);
    logUpdate.setLogType(value.type);
    return client.updateLog(logUpdate, metadata(server))
        .then(response => response.toObject());
}

/**
 * Delete a system log
 * @param {ServerConfig} server server configuration: address, token
 * @param {LogId} request system log id: timestamp, device_id
 * @returns {Promise<{}>} delete response
 */
async function delete_log(server, request) {
    const client = new pb_log.LogServicePromiseClient(server.address, null, null);
    const logId = new pb_log.LogId();
    logId.setTimestamp(request.timestamp.valueOf() * 1000);
    logId.setDeviceId(uuid_hex_to_base64(request.device_id));
    return client.deleteLog(logId, metadata(server))
        .then(response => response.toObject());
}

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    add_group_device_member: add_group_device_member,
    add_group_gateway_member: add_group_gateway_member,
    add_group_model_member: add_group_model_member,
    add_set_member: add_set_member,
    add_set_template_member: add_set_template_member,
    add_type_model: add_type_model,
    count_buffer: count_buffer,
    count_data: count_data,
    count_data_by_last_time: count_data_by_last_time,
    count_data_by_range_time: count_data_by_range_time,
    create_buffer: create_buffer,
    create_data: create_data,
    create_device: create_device,
    create_device_config: create_device_config,
    create_gateway: create_gateway,
    create_gateway_config: create_gateway_config,
    create_group_device: create_group_device,
    create_group_gateway: create_group_gateway,
    create_group_model: create_group_model,
    create_log: create_log,
    create_model: create_model,
    create_model_config: create_model_config,
    create_set: create_set,
    create_set_template: create_set_template,
    create_slice: create_slice,
    create_slice_set: create_slice_set,
    create_type: create_type,
    delete_buffer: delete_buffer,
    delete_data: delete_data,
    delete_device: delete_device,
    delete_device_config: delete_device_config,
    delete_gateway: delete_gateway,
    delete_gateway_config: delete_gateway_config,
    delete_group_device: delete_group_device,
    delete_group_gateway: delete_group_gateway,
    delete_group_model: delete_group_model,
    delete_log: delete_log,
    delete_model: delete_model,
    delete_model_config: delete_model_config,
    delete_set: delete_set,
    delete_set_template: delete_set_template,
    delete_slice: delete_slice,
    delete_slice_set: delete_slice_set,
    delete_type: delete_type,
    list_buffer_first: list_buffer_first,
    list_buffer_first_offset: list_buffer_first_offset,
    list_buffer_last: list_buffer_last,
    list_buffer_last_offset: list_buffer_last_offset,
    list_data_by_last_time: list_data_by_last_time,
    list_data_by_number_after: list_data_by_number_after,
    list_data_by_number_before: list_data_by_number_before,
    list_data_by_range_time: list_data_by_range_time,
    list_data_by_set_last_time: list_data_by_set_last_time,
    list_data_by_set_number_after: list_data_by_set_number_after,
    list_data_by_set_number_before: list_data_by_set_number_before,
    list_data_by_set_range_time: list_data_by_set_range_time,
    list_data_by_set_time: list_data_by_set_time,
    list_data_set_by_last_time: list_data_set_by_last_time,
    list_data_set_by_number_after: list_data_set_by_number_after,
    list_data_set_by_number_before: list_data_set_by_number_before,
    list_data_set_by_range_time: list_data_set_by_range_time,
    list_data_timestamp_by_last_time: list_data_timestamp_by_last_time,
    list_data_timestamp_by_range_time: list_data_timestamp_by_range_time,
    list_data_timestamp_by_set_last_time: list_data_timestamp_by_set_last_time,
    list_data_timestamp_by_set_range_time: list_data_timestamp_by_set_range_time,
    list_device_by_gateway: list_device_by_gateway,
    list_device_by_ids: list_device_by_ids,
    list_device_by_name: list_device_by_name,
    list_device_by_type: list_device_by_type,
    list_device_config_by_device: list_device_config_by_device,
    list_device_option: list_device_option,
    list_gateway_by_ids: list_gateway_by_ids,
    list_gateway_by_name: list_gateway_by_name,
    list_gateway_by_type: list_gateway_by_type,
    list_gateway_config_by_gateway: list_gateway_config_by_gateway,
    list_gateway_option: list_gateway_option,
    list_group_device_by_category: list_group_device_by_category,
    list_group_device_by_ids: list_group_device_by_ids,
    list_group_device_by_name: list_group_device_by_name,
    list_group_device_option: list_group_device_option,
    list_group_gateway_by_category: list_group_gateway_by_category,
    list_group_gateway_by_ids: list_group_gateway_by_ids,
    list_group_gateway_by_name: list_group_gateway_by_name,
    list_group_gateway_option: list_group_gateway_option,
    list_group_model_by_category: list_group_model_by_category,
    list_group_model_by_ids: list_group_model_by_ids,
    list_group_model_by_name: list_group_model_by_name,
    list_group_model_option: list_group_model_option,
    list_log_by_last_time: list_log_by_last_time,
    list_log_by_range_time: list_log_by_range_time,
    list_log_by_time: list_log_by_time,
    list_model_by_category: list_model_by_category,
    list_model_by_ids: list_model_by_ids,
    list_model_by_name: list_model_by_name,
    list_model_by_type: list_model_by_type,
    list_model_config_by_model: list_model_config_by_model,
    list_model_option: list_model_option,
    list_set_by_ids: list_set_by_ids,
    list_set_by_name: list_set_by_name,
    list_set_by_option: list_set_by_option,
    list_set_by_template: list_set_by_template,
    list_set_template_by_ids: list_set_template_by_ids,
    list_set_template_by_name: list_set_template_by_name,
    list_set_template_by_option: list_set_template_by_option,
    list_slice_by_name_range_time: list_slice_by_name_range_time,
    list_slice_by_name_time: list_slice_by_name_time,
    list_slice_by_range_time: list_slice_by_range_time,
    list_slice_by_time: list_slice_by_time,
    list_slice_option: list_slice_option,
    list_slice_set_by_name_range_time: list_slice_set_by_name_range_time,
    list_slice_set_by_name_time: list_slice_set_by_name_time,
    list_slice_set_by_range_time: list_slice_set_by_range_time,
    list_slice_set_by_time: list_slice_set_by_time,
    list_slice_set_option: list_slice_set_option,
    list_type_by_ids: list_type_by_ids,
    list_type_by_name: list_type_by_name,
    list_type_option: list_type_option,
    read_buffer: read_buffer,
    read_buffer_by_time: read_buffer_by_time,
    read_buffer_first: read_buffer_first,
    read_buffer_last: read_buffer_last,
    read_data: read_data,
    read_data_set: read_data_set,
    read_data_timestamp: read_data_timestamp,
    read_data_timestamp_by_set: read_data_timestamp_by_set,
    read_device: read_device,
    read_device_by_sn: read_device_by_sn,
    read_device_config: read_device_config,
    read_gateway: read_gateway,
    read_gateway_by_sn: read_gateway_by_sn,
    read_gateway_config: read_gateway_config,
    read_group_device: read_group_device,
    read_group_gateway: read_group_gateway,
    read_group_model: read_group_model,
    read_log: read_log,
    read_model: read_model,
    read_model_config: read_model_config,
    read_set: read_set,
    read_set_template: read_set_template,
    read_slice: read_slice,
    read_slice_set: read_slice_set,
    read_type: read_type,
    remove_group_device_member: remove_group_device_member,
    remove_group_gateway_member: remove_group_gateway_member,
    remove_group_model_member: remove_group_model_member,
    remove_set_member: remove_set_member,
    remove_set_template_member: remove_set_template_member,
    remove_type_model: remove_type_model,
    swap_set_member: swap_set_member,
    swap_set_template_member: swap_set_template_member,
    update_buffer: update_buffer,
    update_device: update_device,
    update_device_config: update_device_config,
    update_gateway: update_gateway,
    update_gateway_config: update_gateway_config,
    update_group_device: update_group_device,
    update_group_gateway: update_group_gateway,
    update_group_model: update_group_model,
    update_log: update_log,
    update_model: update_model,
    update_model_config: update_model_config,
    update_set: update_set,
    update_set_template: update_set_template,
    update_slice: update_slice,
    update_slice_set: update_slice_set,
    update_type: update_type
});

export { add_group_device_member, add_group_gateway_member, add_group_model_member, add_role_access, add_set_member, add_set_template_member, add_type_model, add_user_role, index$1 as auth, count_buffer, count_data, count_data_by_last_time, count_data_by_range_time, create_access_token, create_api, create_auth_token, create_buffer, create_data, create_device, create_device_config, create_gateway, create_gateway_config, create_group_device, create_group_gateway, create_group_model, create_log, create_model, create_model_config, create_procedure, create_role, create_set, create_set_template, create_slice, create_slice_set, create_type, create_user, delete_access_token, delete_api, delete_auth_token, delete_buffer, delete_data, delete_device, delete_device_config, delete_gateway, delete_gateway_config, delete_group_device, delete_group_gateway, delete_group_model, delete_log, delete_model, delete_model_config, delete_procedure, delete_role, delete_set, delete_set_template, delete_slice, delete_slice_set, delete_token_by_user, delete_type, delete_user, list_api_by_category, list_api_by_ids, list_api_by_name, list_api_option, list_auth_token, list_buffer_first, list_buffer_first_offset, list_buffer_last, list_buffer_last_offset, list_data_by_last_time, list_data_by_number_after, list_data_by_number_before, list_data_by_range_time, list_data_by_set_last_time, list_data_by_set_number_after, list_data_by_set_number_before, list_data_by_set_range_time, list_data_by_set_time, list_data_set_by_last_time, list_data_set_by_number_after, list_data_set_by_number_before, list_data_set_by_range_time, list_data_timestamp_by_last_time, list_data_timestamp_by_range_time, list_data_timestamp_by_set_last_time, list_data_timestamp_by_set_range_time, list_device_by_gateway, list_device_by_ids, list_device_by_name, list_device_by_type, list_device_config_by_device, list_device_option, list_gateway_by_ids, list_gateway_by_name, list_gateway_by_type, list_gateway_config_by_gateway, list_gateway_option, list_group_device_by_category, list_group_device_by_ids, list_group_device_by_name, list_group_device_option, list_group_gateway_by_category, list_group_gateway_by_ids, list_group_gateway_by_name, list_group_gateway_option, list_group_model_by_category, list_group_model_by_ids, list_group_model_by_name, list_group_model_option, list_log_by_last_time, list_log_by_range_time, list_log_by_time, list_model_by_category, list_model_by_ids, list_model_by_name, list_model_by_type, list_model_config_by_model, list_model_option, list_procedure_by_api, list_procedure_by_ids, list_procedure_by_name, list_procedure_option, list_role_by_api, list_role_by_ids, list_role_by_name, list_role_by_user, list_role_option, list_set_by_ids, list_set_by_name, list_set_by_option, list_set_by_template, list_set_template_by_ids, list_set_template_by_name, list_set_template_by_option, list_slice_by_name_range_time, list_slice_by_name_time, list_slice_by_range_time, list_slice_by_time, list_slice_option, list_slice_set_by_name_range_time, list_slice_set_by_name_time, list_slice_set_by_range_time, list_slice_set_by_time, list_slice_set_option, list_token_by_user, list_type_by_ids, list_type_by_name, list_type_option, list_user_by_api, list_user_by_ids, list_user_by_name, list_user_by_role, list_user_option, read_access_token, read_api, read_api_by_name, read_buffer, read_buffer_by_time, read_buffer_first, read_buffer_last, read_data, read_data_set, read_data_timestamp, read_data_timestamp_by_set, read_device, read_device_by_sn, read_device_config, read_gateway, read_gateway_by_sn, read_gateway_config, read_group_device, read_group_gateway, read_group_model, read_log, read_model, read_model_config, read_procedure, read_procedure_by_name, read_role, read_role_by_name, read_set, read_set_template, read_slice, read_slice_set, read_type, read_user, read_user_by_name, remove_group_device_member, remove_group_gateway_member, remove_group_model_member, remove_role_access, remove_set_member, remove_set_template_member, remove_type_model, remove_user_role, index as resource, swap_set_member, swap_set_template_member, update_access_token, update_api, update_auth_token, update_buffer, update_device, update_device_config, update_gateway, update_gateway_config, update_group_device, update_group_gateway, update_group_model, update_log, update_model, update_model_config, update_procedure, update_role, update_set, update_set_template, update_slice, update_slice_set, update_type, update_user, user_login, user_login_key, user_logout, user_refresh, utility };
