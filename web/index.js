import { pb_api, pb_role, pb_user, pb_token, pb_auth } from 'rmcs-auth-api';
import { pb_model, pb_device, pb_group, pb_data, pb_buffer, pb_slice, pb_log } from 'rmcs-resource-api';

/**
 * Construct request metadata
 * @param {{address:string,token:string}} server 
 * @returns {Object.<string,string>}
 */
function metadata(server) {
    if (server.token) {
        return { "Authorization": "Bearer " + server.token };
    }
    return {};
}

/**
 * Convert base64 string to UUID hex representation
 * @param {string} str 
 * @returns {string}
 */
function base64_to_uuid_hex(str) {
    const raw = atob(str);
    let result = '';
    let dashPos = [3, 5, 7, 9];
    for (let i = 0; i < raw.length; i++) {
      const hex = raw.charCodeAt(i).toString(16);
      result += (hex.length === 2 ? hex : '0' + hex);
      if (dashPos.includes(i)) {
        result += '-';
      }
    }
    return result;
}

/**
 * Convert UUID hex representation to base64 string
 * @param {string} uuid 
 * @returns {string}
 */
function uuid_hex_to_base64(uuid) {
    if (typeof uuid == "string") {
        uuid = uuid.replace(/-/g, '');
        if (/^[0-9a-fA-F]{32}$/.test(uuid)) {
            return btoa(uuid.match(/\w{2}/g).map((a) => {
                return String.fromCharCode(parseInt(a, 16));
            }).join(""));
        }
    }
    return "";
}

/**
 * Generate random bytes
 * @param {number} number number of generated bytes (integer) 
 */
function random_binary(number) {
    const buffer = new Uint8Array(number);
    buffer.forEach((value, index, array) => {
        array[index] = Math.floor(Math.random() * 256);
    });
    return buffer;
}

/**
 * Generate random base64 string
 * @param {number} number number of generated base64 string (integer) 
 * @returns {string}
 */
function random_base64(number) {
    const base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    let str = "";
    for (let i=0; i<number; i++) {
        str += base64.charAt(Math.floor(Math.random() * 64));
    }
    return str;
}

/**
 * Generate random UUID version 4 in hex format
 * @returns {string}
 */
function uuid_v4_hex() {
    const buffer = random_binary(16);
    let result = '';
    let dashPos = [3, 5, 7, 9];
    for (let i = 0; i < buffer.length; i++) {
        let hex = buffer[i].toString(16);
        hex = hex.length === 2 ? hex : '0' + hex;
        if (i === 6) {
            hex = '4' + hex.charAt(1);
        }
        result += hex;
        if (dashPos.includes(i)) {
            result += '-';
        }
    }
    return result;
}

/**
 * Convert a string into an ArrayBuffer
 * @param {string} str 
 * @returns {ArrayBuffer}
 */
function string_to_array_buffer(str) {
    const buf = new ArrayBuffer(str.length);
    const bufView = new Uint8Array(buf);
    for (let i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }
    return buf;
}

/**
 * Convert base64 string to bytes (number[])
 * @param {string} base64 
 * @returns {number[]}
 */
function base64_to_bytes(base64) {
    return atob(base64).split("").map((v) => {
        return v.charCodeAt();
    });
}

/**
 * Convert bytes (Uint8Array, number[]) to base64 string
 * @param {Uint8Array|number[]} bytes 
 * @returns {string}
 */
function bytes_to_base64(bytes) {
    return btoa(Array.from(bytes).map((v) => {
        return String.fromCharCode(v);
    }).join(""));
}

var utility = /*#__PURE__*/Object.freeze({
    __proto__: null,
    base64_to_bytes: base64_to_bytes,
    base64_to_uuid_hex: base64_to_uuid_hex,
    bytes_to_base64: bytes_to_base64,
    metadata: metadata,
    random_base64: random_base64,
    random_binary: random_binary,
    string_to_array_buffer: string_to_array_buffer,
    uuid_hex_to_base64: uuid_hex_to_base64,
    uuid_v4_hex: uuid_v4_hex
});

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} ApiId
 * @property {Uuid} id
 */

/**
 * @param {*} r 
 * @returns {ApiId}
 */
function getApiId(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
 * @typedef {Object} ApiName
 * @property {string} name
 */

/**
 * @typedef {Object} ApiCategory
 * @property {string} category
 */

/**
 * @typedef {Object} ApiSchema
 * @property {Uuid} id
 * @property {string} name
 * @property {string} address
 * @property {string} category
 * @property {string} description
 * @property {string} password
 * @property {string} access_key
 * @property {ProcedureSchema[]} procedures
 */

/**
 * @param {*} r 
 * @returns {ApiSchema}
 */
function get_api_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        name: r.name,
        address: r.address,
        category: r.category,
        description: r.description,
        password: r.password,
        access_key: r.accessKey,
        procedures: get_procedure_schema_vec(r.proceduresList)
    };
}

/**
 * @param {*} r 
 * @returns {ApiSchema[]}
 */
function get_api_schema_vec(r) {
    return r.map((v) => {return get_api_schema(v)});
}

/**
 * @typedef {Object} ApiUpdate
 * @property {Uuid} id
 * @property {?string} name
 * @property {?string} address
 * @property {?string} category
 * @property {?string} description
 * @property {?string} password
 * @property {?string} access_key
 */

/**
 * @typedef {Object} ProcedureId
 * @property {Uuid} id
 */

/**
 * @param {*} r 
 * @returns {ProcedureId}
 */
function get_procedure_id(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
 * @typedef {Object} ProcedureName
 * @property {Uuid} api_id
 * @property {string} name
 */

/**
 * @typedef {Object} ProcedureSchema
 * @property {Uuid} id
 * @property {string} api_id
 * @property {string} name
 * @property {string} description
 * @property {string[]} roles
 */

/**
 * @param {*} r 
 * @returns {ProcedureSchema}
 */
function get_procedure_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        api_id: base64_to_uuid_hex(r.apiId),
        name: r.name,
        description: r.description,
        roles: r.rolesList
    };
}

/**
 * @param {*} r 
 * @returns {ProcedureSchema[]}
 */
function get_procedure_schema_vec(r) {
    return r.map((v) => {return get_procedure_schema(v)});
}

/**
 * @typedef {Object} ProcedureUpdate
 * @property {Uuid} id
 * @property {?string} name
 * @property {?string} description
 */


/**
 * Read an api by uuid
 * @param {ServerConfig} server Server configuration
 * @param {ApiId} request api uuid: id
 * @param {function(?grpc.web.RpcError, ?ApiSchema)} callback The callback function(error, response)
 */
async function read_api(server, request, callback) {
    const client = new pb_api.ApiServiceClient(server.address, null, null);
    const apiId = new pb_api.ApiId();
    apiId.setId(uuid_hex_to_base64(request.id));
    await client.readApi(apiId, metadata(server), (e, r) => {
        const response = r ? get_api_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read an api by name
 * @param {ServerConfig} server Server configuration
 * @param {ApiName} request api name: id, name
 * @param {function(?grpc.web.RpcError, ?ApiSchema)} callback The callback function(error, response)
 */
async function read_api_by_name(server, request, callback) {
    const client = new pb_api.ApiServiceClient(server.address, null, null);
    const apiName = new pb_api.ApiName();
    apiName.setName(request.name);
    await client.readApiByName(apiName, metadata(server), (e, r) => {
        const response = r ? get_api_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read apis by category
 * @param {ServerConfig} server Server configuration
 * @param {ApiCategory} request api category: category
 * @param {function(?grpc.web.RpcError, ?ApiSchema[])} callback The callback function(error, response)
 */
async function list_api_by_category(server, request, callback) {
    const client = new pb_api.ApiServiceClient(server.address, null, null);
    const apiCategory = new pb_api.ApiCategory();
    apiCategory.setCategory(request.category);
    await client.listApiByCategory(apiCategory, metadata(server), (e, r) => {
        const response = r ? get_api_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Create an api
 * @param {ServerConfig} server Server configuration
 * @param {ApiSchema} request api schema: id, name, address, category, description, password, access_key
 * @param {function(?grpc.web.RpcError, ?ApiId)} callback The callback function(error, response)
 */
async function create_api(server, request, callback) {
    const client = new pb_api.ApiServiceClient(server.address, null, null);
    const apiSchema = new pb_api.ApiSchema();
    apiSchema.setId(uuid_hex_to_base64(request.id));
    apiSchema.setName(request.name);
    apiSchema.setAddress(request.address);
    apiSchema.setCategory(request.category);
    apiSchema.setDescription(request.description);
    apiSchema.setPassword(request.password);
    apiSchema.setAccessKey(request.access_key);
    await client.createApi(apiSchema, metadata(server), (e, r) => {
        const response = r ? getApiId(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * Update an api
 * @param {ServerConfig} server Server configuration
 * @param {ApiUpdate} request api update: id, name, address, category, description, password, access_key
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function update_api(server, request, callback) {
    const client = new pb_api.ApiServiceClient(server.address, null, null);
    const apiUpdate = new pb_api.ApiUpdate();
    apiUpdate.setId(uuid_hex_to_base64(request.id));
    apiUpdate.setName(request.name);
    apiUpdate.setAddress(request.address);
    apiUpdate.setCategory(request.category);
    apiUpdate.setDescription(request.description);
    apiUpdate.setPassword(request.password);
    apiUpdate.setAccessKey(request.access_key);
    await client.updateApi(apiUpdate, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Delete an api
 * @param {ServerConfig} server Server configuration
 * @param {ApiId} request api uuid: id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_api(server, request, callback) {
    const client = new pb_api.ApiServiceClient(server.address, null, null);
    const apiId = new pb_api.ApiId();
    apiId.setId(uuid_hex_to_base64(request.id));
    await client.deleteApi(apiId, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Read an procedure by uuid
 * @param {ServerConfig} server Server configuration
 * @param {ProcedureId} request procedure uuid: id
 * @param {function(?grpc.web.RpcError, ?ProcedureSchema)} callback The callback function(error, response)
 */
async function read_procedure(server, request, callback) {
    const client = new pb_api.ApiServiceClient(server.address, null, null);
    const procedureId = new pb_api.ProcedureId();
    procedureId.setId(uuid_hex_to_base64(request.id));
    await client.readProcedure(procedureId, metadata(server), (e, r) => {
        const response = r ? get_procedure_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read an procedure by name
 * @param {ServerConfig} server Server configuration
 * @param {ProcedureName} request procedure name: api_id, name
 * @param {function(?grpc.web.RpcError, ?ProcedureSchema)} callback The callback function(error, response)
 */
async function read_procedure_by_name(server, request, callback) {
    const client = new pb_api.ApiServiceClient(server.address, null, null);
    const procedureName = new pb_api.ProcedureName();
    procedureName.setApiId(uuid_hex_to_base64(request.api_id));
    procedureName.setName(request.name);
    await client.readProcedureByName(procedureName, metadata(server), (e, r) => {
        const response = r ? get_procedure_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read procedures by api uuid
 * @param {ServerConfig} server Server configuration
 * @param {ApiId} request api uuid: id
 * @param {function(?grpc.web.RpcError, ?ProcedureSchema[])} callback The callback function(error, response)
 */
async function list_procedure_by_api(server, request, callback) {
    const client = new pb_api.ApiServiceClient(server.address, null, null);
    const apiId = new pb_api.ApiId();
    apiId.setId(uuid_hex_to_base64(request.id));
    await client.listProcedureByApi(apiId, metadata(server), (e, r) => {
        const response = r ? get_procedure_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Create a procedure
 * @param {ServerConfig} server Server configuration
 * @param {ProcedureSchema} request procedure schema: id, api_id, name, description
 * @param {function(?grpc.web.RpcError, ?ProcedureSchema)} callback The callback function(error, response)
 */
async function create_procedure(server, request, callback) {
    const client = new pb_api.ApiServiceClient(server.address, null, null);
    const procedureSchema = new pb_api.ProcedureSchema();
    procedureSchema.setId(uuid_hex_to_base64(request.id));
    procedureSchema.setApiId(uuid_hex_to_base64(request.api_id));
    procedureSchema.setName(request.name);
    procedureSchema.setDescription(request.description);
    await client.createProcedure(procedureSchema, metadata(server), (e, r) => {
        const response = r ? get_procedure_id(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * Update a procedure
 * @param {ServerConfig} server Server configuration
 * @param {ProcedureUpdate} request procedure update: id, name, description
 * @param {function(?grpc.web.RpcError, ?ProcedureSchema)} callback The callback function(error, response)
 */
async function update_procedure(server, request, callback) {
    const client = new pb_api.ApiServiceClient(server.address, null, null);
    const procedureUpdate = new pb_api.ProcedureUpdate();
    procedureUpdate.setId(uuid_hex_to_base64(request.id));
    procedureUpdate.setName(request.name);
    procedureUpdate.setDescription(request.description);
    await client.updateProcedure(procedureUpdate, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Delete a procedure
 * @param {ServerConfig} server Server configuration
 * @param {ProcedureId} request procedure uuid: id
 * @param {function(?grpc.web.RpcError, ?ProcedureSchema)} callback The callback function(error, response)
 */
async function delete_procedure(server, request, callback) {
    const client = new pb_api.ApiServiceClient(server.address, null, null);
    const procedureId = new pb_api.ProcedureId();
    procedureId.setId(uuid_hex_to_base64(request.id));
    await client.deleteProcedure(procedureId, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} RoleId
 * @property {Uuid} id
 */

/**
 * @param {*} r 
 * @returns {RoleId}
 */
function get_role_id(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
 * @typedef {Object} RoleName
 * @property {Uuid} api_id
 * @property {string} name
 */

/**
 * @typedef {import('./api.js').ApiId} ApiId
 */

/**
 * @typedef {import('./user.js').UserId} UserId
 */

/**
 * @typedef {Object} RoleSchema
 * @property {Uuid} id
 * @property {Uuid} api_id
 * @property {string} name
 * @property {boolean} multi
 * @property {boolean} ip_lock
 * @property {number} access_duration
 * @property {number} refresh_duration
 * @property {string} access_key
 * @property {string[]} procedures
 */

/**
 * @param {*} r 
 * @returns {RoleSchema}
 */
function get_role_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        api_id: base64_to_uuid_hex(r.apiId),
        name: r.name,
        multi: r.multi,
        ip_lock: r.ipLock,
        access_duration: r.accessDuration,
        refresh_duration: r.refreshDuration,
        access_key: r.accessKey,
        procedures: r.proceduresList.map((v) => {return base64_to_uuid_hex(v)})
    };
}

/**
 * @param {*} r 
 * @returns {RoleSchema[]}
 */
function get_role_schema_vec(r) {
    return r.map((v) => {return get_role_schema(v)});
}

/**
 * @typedef {Object} RoleUpdate
 * @property {Uuid} id
 * @property {?string} name
 * @property {?boolean} multi
 * @property {?boolean} ip_lock
 * @property {?number} access_duration
 * @property {?number} refresh_duration
 */

/**
 * @typedef {Object} RoleAccess
 * @property {Uuid} id
 * @property {Uuid} procedure_id
 */


/**
 * Read a role by uuid
 * @param {ServerConfig} server Server configuration
 * @param {RoleId} request role uuid: id
 * @param {function(?grpc.web.RpcError, ?RoleSchema)} callback The callback function(error, response)
 */
async function read_role(server, request, callback) {
    const client = new pb_role.RoleServiceClient(server.address, null, null);
    const roleId = new pb_role.RoleId();
    roleId.setId(uuid_hex_to_base64(request.id));
    await client.readRole(roleId, metadata(server), (e, r) => {
        const response = r ? get_role_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read a role by name
 * @param {ServerConfig} server Server configuration
 * @param {RoleName} request role name: api_id, name
 * @param {function(?grpc.web.RpcError, ?RoleSchema)} callback The callback function(error, response)
 */
async function read_role_by_name(server, request, callback) {
    const client = new pb_role.RoleServiceClient(server.address, null, null);
    const roleName = new pb_role.RoleName();
    roleName.setApiId(uuid_hex_to_base64(request.api_id));
    roleName.setName(request.name);
    await client.readRoleByName(roleName, metadata(server), (e, r) => {
        const response = r ? get_role_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read roles by api uuid
 * @param {ServerConfig} server Server configuration
 * @param {ApiId} request api uuid: id
 * @param {function(?grpc.web.RpcError, ?RoleSchema[])} callback The callback function(error, response)
 */
async function list_role_by_api(server, request, callback) {
    const client = new pb_role.RoleServiceClient(server.address, null, null);
    const apiId = new pb_role.ApiId();
    apiId.setApiId(uuid_hex_to_base64(request.id));
    await client.listRoleByApi(apiId, metadata(server), (e, r) => {
        const response = r ? get_role_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read roles by user uuid
 * @param {ServerConfig} server Server configuration
 * @param {UserId} request user uuid: id
 * @param {function(?grpc.web.RpcError, ?RoleSchema[])} callback The callback function(error, response)
 */
async function list_role_by_user(server, request, callback) {
    const client = new pb_role.RoleServiceClient(server.address, null, null);
    const userId = new pb_role.UserId();
    userId.setUserId(uuid_hex_to_base64(request.id));
    await client.listRoleByUser(userId, metadata(server), (e, r) => {
        const response = r ? get_role_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Create a role
 * @param {ServerConfig} server Server configuration
 * @param {RoleSchema} request role schema: id, api_id, name, multi, ip_lock, access_duration, refresh_duration, access_key
 * @param {function(?grpc.web.RpcError, ?RoleId)} callback The callback function(error, response)
 */
async function create_role(server, request, callback) {
    const client = new pb_role.RoleServiceClient(server.address, null, null);
    const roleSchema = new pb_role.RoleSchema();
    roleSchema.setId(uuid_hex_to_base64(request.id));
    roleSchema.setApiId(uuid_hex_to_base64(request.api_id));
    roleSchema.setName(request.name);
    roleSchema.setMulti(request.multi);
    roleSchema.setIpLock(request.ip_lock);
    roleSchema.setAccessDuration(request.access_duration);
    roleSchema.setRefreshDuration(request.refresh_duration);
    roleSchema.setAccessKey(request.access_key);
    await client.createRole(roleSchema, metadata(server), (e, r) => {
        const response = r ? get_role_id(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * Update a role
 * @param {ServerConfig} server Server configuration
 * @param {RoleUpdate} request role update: id, name, multi, ip_lock, access_duration, refresh_duration
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function update_role(server, request, callback) {
    const client = new pb_role.RoleServiceClient(server.address, null, null);
    const roleUpdate = new pb_role.RoleUpdate();
    roleUpdate.setId(uuid_hex_to_base64(request.id));
    roleUpdate.setName(request.name);
    roleUpdate.setMulti(request.multi);
    roleUpdate.setIpLock(request.ip_lock);
    roleUpdate.setAccessDuration(request.access_duration);
    roleUpdate.setRefreshDuration(request.refresh_duration);
    await client.updateRole(roleUpdate, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Delete a role
 * @param {ServerConfig} server Server configuration
 * @param {RoleId} request role uuid: id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_role(server, request, callback) {
    const client = new pb_role.RoleServiceClient(server.address, null, null);
    const roleId = new pb_role.RoleId();
    roleId.setId(uuid_hex_to_base64(request.id));
    await client.deleteRole(roleId, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Add a role access
 * @param {ServerConfig} server Server configuration
 * @param {RoleAccess} request role access: id, procedure_id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function add_role_access(server, request, callback) {
    const client = new pb_role.RoleServiceClient(server.address, null, null);
    const roleAccess = new pb_role.RoleAccess();
    roleAccess.setId(uuid_hex_to_base64(request.id));
    roleAccess.setProcedureId(uuid_hex_to_base64(request.procedure_id));
    await client.addRoleAccess(roleAccess, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Remove a role access
 * @param {ServerConfig} server Server configuration
 * @param {RoleAccess} request role access: id, procedure_id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function remove_role_access(server, request, callback) {
    const client = new pb_role.RoleServiceClient(server.address, null, null);
    const roleAccess = new pb_role.RoleAccess();
    roleAccess.setId(uuid_hex_to_base64(request.id));
    roleAccess.setProcedureId(uuid_hex_to_base64(request.procedure_id));
    await client.removeRoleAccess(roleAccess, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} UserId
 * @property {Uuid} id
 */

/**
 * @param {*} r 
 * @returns {UserId}
 */
function get_user_id(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
 * @typedef {Object} UserName
 * @property {string} name
 */

/**
 * @typedef {import('./role.js').RoleId} RoleId
 */

/**
 * @typedef {Object} UserRoleSchema
 * @property {Uuid} api_id
 * @property {string} role
 * @property {boolean} multi
 * @property {boolean} ip_lock
 * @property {number} access_duration
 * @property {number} refresh_duration
 * @property {string} access_key
 */

/**
 * @typedef {Object} UserSchema
 * @property {Uuid} id
 * @property {string} name
 * @property {string} email
 * @property {string} phone
 * @property {string} password
 * @property {UserRoleSchema[]} roles
 */

/**
 * @param {*} r 
 * @returns {UserRoleSchema}
 */
function get_user_role_schema(r) {
    return {
        api_id: base64_to_uuid_hex(r.apiId),
        role: r.role,
        multi: r.multi,
        ip_lock: r.ipLock,
        access_duration: r.accessDuration,
        refresh_duration: r.refreshDuration,
        access_key: r.accessKey
    };
}

/**
 * @param {*} r 
 * @returns {UserSchema}
 */
function get_user_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        name: r.name,
        email: r.email,
        phone: r.phone,
        password: r.password,
        roles: r.rolesList.map((v) => {return get_user_role_schema(v)})
    };
}

/**
 * @param {*} r 
 * @returns {UserSchema[]}
 */
function get_user_schema_vec(r) {
    return r.map((v) => {return get_user_schema(v)});
}

/**
 * @typedef {Object} UserUpdate
 * @property {Uuid} id
 * @property {?string} name
 * @property {?string} email
 * @property {?string} phone
 * @property {?string} password
 */

/**
 * @typedef {Object} UserRole
 * @property {Uuid} user_id
 * @property {Uuid} role_id
 */


/**
 * Read a user by uuid
 * @param {ServerConfig} server Server configuration
 * @param {UserId} request user uuid: id
 * @param {function(?grpc.web.RpcError, ?UserSchema)} callback The callback function(error, response)
 */
async function read_user(server, request, callback) {
    const client = new pb_user.UserServiceClient(server.address, null, null);
    const userId = new pb_user.UserId();
    userId.setId(uuid_hex_to_base64(request.id));
    await client.readUser(userId, metadata(server), (e, r) => {
        const response = r ? get_user_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read a user by name
 * @param {ServerConfig} server Server configuration
 * @param {UserName} request user name: name
 * @param {function(?grpc.web.RpcError, ?UserSchema)} callback The callback function(error, response)
 */
async function read_user_by_name(server, request, callback) {
    const client = new pb_user.UserServiceClient(server.address, null, null);
    const userName = new pb_user.UserName();
    userName.setName(request.name);
    await client.readUserByName(userName, metadata(server), (e, r) => {
        const response = r ? get_user_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read users by role uuid
 * @param {ServerConfig} server Server configuration
 * @param {RoleId} request role uuid: id
 * @param {function(?grpc.web.RpcError, ?UserSchema[])} callback The callback function(error, response)
 */
async function list_user_by_role(server, request, callback) {
    const client = new pb_user.UserServiceClient(server.address, null, null);
    const roleId = new pb_user.RoleId();
    roleId.setId(uuid_hex_to_base64(request.id));
    await client.listUserByRole(roleId, metadata(server), (e, r) => {
        const response = r ? get_user_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Create an user
 * @param {ServerConfig} server Server configuration
 * @param {UserSchema} request user schema: id, name, email, phone, password
 * @param {function(?grpc.web.RpcError, ?UserId)} callback The callback function(error, response)
 */
async function create_user(server, request, callback) {
    const client = new pb_user.UserServiceClient(server.address, null, null);
    const userSchema = new pb_user.UserSchema();
    userSchema.setId(uuid_hex_to_base64(request.id));
    userSchema.setName(request.name);
    userSchema.setEmail(request.email);
    userSchema.setPhone(request.phone);
    userSchema.setPassword(request.password);
    await client.createUser(userSchema, metadata(server), (e, r) => {
        const response = r ? get_user_id(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * Update an user
 * @param {ServerConfig} server Server configuration
 * @param {UserUpdate} request user update: id, name, email, phone, password
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function update_user(server, request, callback) {
    const client = new pb_user.UserServiceClient(server.address, null, null);
    const userUpdate = new pb_user.UserUpdate();
    userUpdate.setId(uuid_hex_to_base64(request.id));
    userUpdate.setName(request.name);
    userUpdate.setEmail(request.email);
    userUpdate.setPhone(request.phone);
    userUpdate.setPassword(request.password);
    await client.updateUser(userUpdate, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Delete an user
 * @param {ServerConfig} server Server configuration
 * @param {UserId} request user uuid: id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_user(server, request, callback) {
    const client = new pb_user.UserServiceClient(server.address, null, null);
    const userId = new pb_user.UserId();
    userId.setId(uuid_hex_to_base64(request.id));
    await client.deleteUser(userId, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Add a role to user
 * @param {ServerConfig} server Server configuration
 * @param {UserRole} request user role: user_id, role_id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function add_user_role(server, request, callback) {
    const client = new pb_user.UserServiceClient(server.address, null, null);
    const userRole = new pb_user.UserRole();
    userRole.setUserId(uuid_hex_to_base64(request.user_id));
    userRole.setRoleId(uuid_hex_to_base64(request.role_id));
    await client.addUserRole(userRole, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Remove a role from user
 * @param {ServerConfig} server Server configuration
 * @param {UserRole} request user role: user_id, role_id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function remove_user_role(server, request, callback) {
    const client = new pb_user.UserServiceClient(server.address, null, null);
    const userRole = new pb_user.UserRole();
    userRole.setUserId(uuid_hex_to_base64(request.user_id));
    userRole.setRoleId(uuid_hex_to_base64(request.role_id));
    await client.removeUserRole(userRole, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} AccessId
 * @property {number} access_id
 */

/**
 * @typedef {Object} AuthToken
 * @property {string} auth_token
 */

/**
 * @typedef {import('./user.js').UserId} UserId
 */

/**
 * @typedef {Object} TokenSchema
 * @property {number} access_id
 * @property {Uuid} user_id
 * @property {string} refresh_token
 * @property {string} auth_token
 * @property {Date} expire
 * @property {number[]|Uint8Array} ip
 */

/**
 * @param {*} r 
 * @returns {TokenSchema}
 */
function get_token_schema(r) {
    return {
        access_id: r.accessId,
        user_id: base64_to_uuid_hex(r.userId),
        refresh_token: r.refreshToken,
        auth_token: r.authToken,
        expire: new Date(r.expire / 1000),
        ip: base64_to_bytes(r.ip)
    };
}

/**
 * @param {*} r 
 * @returns {TokenSchema[]}
 */
function get_token_schema_vec(r) {
    return r.map((v) => {return get_token_schema(v)});
}

/**
 * @typedef {Object} AuthTokenCreate
 * @property {Uuid} user_id
 * @property {Date} expire
 * @property {number[]|Uint8Array} ip
 * @property {number} number
 */

/**
 * @typedef {Object} TokenUpdate
 * @property {?number} access_id
 * @property {?string} refresh_token
 * @property {?string} auth_token
 * @property {?Date} expire
 * @property {?number[]|Uint8Array} ip
 */

/**
 * @typedef {Object} TokenCreateResponse
 * @property {number} access_id
 * @property {string} refresh_token
 * @property {string} auth_token
 */

/**
 * @param {*} r 
 * @returns {TokenCreateResponse}
 */
function get_token_create_response(r) {
    return {
        access_id: r.accessId,
        refresh_token: r.refreshToken,
        auth_token: r.authToken,
    };
}

/**
 * @param {*} r 
 * @returns {TokenCreateResponse[]}
 */
function get_token_create_response_vec(r) {
    return r.map((v) => {return get_token_create_response(v)});
}

/**
 * @typedef {Object} TokenUpdateResponse
 * @property {string} refresh_token
 * @property {string} auth_token
 */

/**
 * @param {*} r 
 * @returns {TokenUpdateResponse}
 */
function get_token_update_response(r) {
    return {
        refresh_token: r.refreshToken,
        auth_token: r.authToken,
    };
}


/**
 * Read an access token by access id
 * @param {ServerConfig} server Server configuration
 * @param {AccessId} request access id: access_id
 * @param {function(?grpc.web.RpcError, ?TokenSchema)} callback The callback function(error, response)
 */
async function read_access_token(server, request, callback) {
    const client = new pb_token.TokenServiceClient(server.address, null, null);
    const accessId = new pb_token.AccessId();
    accessId.setAccessId(request.access_id);
    await client.readAccessToken(accessId, metadata(server), (e, r) => {
        const response = r ? get_token_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read tokens by auth token
 * @param {ServerConfig} server Server configuration
 * @param {AuthToken} request auth token: auth_token
 * @param {function(?grpc.web.RpcError, ?TokenSchema[])} callback The callback function(error, response)
 */
async function list_auth_token(server, request, callback) {
    const client = new pb_token.TokenServiceClient(server.address, null, null);
    const authToken = new pb_token.AuthToken();
    authToken.setAuthToken(request.auth_token);
    await client.listAuthToken(authToken, metadata(server), (e, r) => {
        const response = r ? get_token_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read tokens by user id
 * @param {ServerConfig} server Server configuration
 * @param {UserId} request user id: id
 * @param {function(?grpc.web.RpcError, ?TokenSchema[])} callback The callback function(error, response)
 */
async function list_token_by_user(server, request, callback) {
    const client = new pb_token.TokenServiceClient(server.address, null, null);
    const userId = new pb_token.UserId();
    userId.setUserId(uuid_hex_to_base64(request.id));
    await client.listTokenByUser(userId, metadata(server), (e, r) => {
        const response = r ? get_token_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Create an access token
 * @param {ServerConfig} server Server configuration
 * @param {TokenSchema} request token schema: user_id, auth_token, expire, ip
 * @param {function(?grpc.web.RpcError, ?TokenCreateResponse)} callback The callback function(error, response)
 */
async function create_access_token(server, request, callback) {
    const client = new pb_token.TokenServiceClient(server.address, null, null);
    const tokenSchema = new pb_token.TokenSchema();
    tokenSchema.setUserId(uuid_hex_to_base64(request.user_id));
    tokenSchema.setAuthToken(request.auth_token);
    tokenSchema.setExpire(request.expire.valueOf() * 1000);
    tokenSchema.setIp(bytes_to_base64(request.ip));
    await client.createAccessToken(tokenSchema, metadata(server), (e, r) => {
        const response = r ? get_token_create_response(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * Create tokens with shared auth token
 * @param {ServerConfig} server Server configuration
 * @param {AuthTokenCreate} request token schema: user_id, expire, ip, number
 * @param {function(?grpc.web.RpcError, ?TokenCreateResponse[])} callback The callback function(error, response)
 */
async function create_auth_token(server, request, callback) {
    const client = new pb_token.TokenServiceClient(server.address, null, null);
    const authTokenCreate = new pb_token.AuthTokenCreate();
    authTokenCreate.setUserId(uuid_hex_to_base64(request.user_id));
    authTokenCreate.setExpire(request.expire.valueOf() * 1000);
    authTokenCreate.setIp(bytes_to_base64(request.ip));
    authTokenCreate.setNumber(request.number);
    await client.createAuthToken(authTokenCreate, metadata(server), (e, r) => {
        const response = r ? get_token_create_response_vec(r.toObject().tokensList) : null;
        callback(e, response);
    });
}

/**
 * Update an access token
 * @param {ServerConfig} server Server configuration
 * @param {TokenUpdate} request token update: access_id, expire, ip
 * @param {function(?grpc.web.RpcError, ?TokenUpdateResponse)} callback The callback function(error, response)
 */
async function update_access_token(server, request, callback) {
    const client = new pb_token.TokenServiceClient(server.address, null, null);
    const tokenUpdate = new pb_token.TokenUpdate();
    tokenUpdate.setAccessId(request.access_id);
    if (request.expire instanceof Date) {
        tokenUpdate.setExpire(request.expire.valueOf() * 1000);
    }
    if (request.ip) {
        tokenUpdate.setIp(bytes_to_base64(request.ip));
    }
    await client.updateAccessToken(tokenUpdate, metadata(server), (e, r) => {
        const response = r ? get_token_update_response(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * Update all tokens with shared auth token
 * @param {ServerConfig} server Server configuration
 * @param {TokenUpdate} request token update: auth_token, expire, ip
 * @param {function(?grpc.web.RpcError, ?TokenUpdateResponse)} callback The callback function(error, response)
 */
async function update_auth_token(server, request, callback) {
    const client = new pb_token.TokenServiceClient(server.address, null, null);
    const tokenUpdate = new pb_token.TokenUpdate();
    tokenUpdate.setAuthToken(request.auth_token);
    if (request.expire instanceof Date) {
        tokenUpdate.setExpire(request.expire.valueOf() * 1000);
    }
    if (request.ip) {
        tokenUpdate.setIp(bytes_to_base64(request.ip));
    }
    await client.updateAuthToken(tokenUpdate, metadata(server), (e, r) => {
        const response = r ? get_token_update_response(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * Delete an access token by access id
 * @param {ServerConfig} server Server configuration
 * @param {AccessId} request access id: access_id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_access_token(server, request, callback) {
    const client = new pb_token.TokenServiceClient(server.address, null, null);
    const accessId = new pb_token.AccessId();
    accessId.setAccessId(request.access_id);
    await client.deleteAccessToken(accessId, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Delete tokens by auth token
 * @param {ServerConfig} server Server configuration
 * @param {AuthToken} request auth token: auth_token
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_auth_token(server, request, callback) {
    const client = new pb_token.TokenServiceClient(server.address, null, null);
    const authToken = new pb_token.AuthToken();
    authToken.setAuthToken(request.auth_token);
    await client.deleteAuthToken(authToken, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Delete tokens by user id
 * @param {ServerConfig} server Server configuration
 * @param {UserId} request user id: id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_token_by_user(server, request, callback) {
    const client = new pb_token.TokenServiceClient(server.address, null, null);
    const userId = new pb_token.UserId();
    userId.setUserId(uuid_hex_to_base64(request.id));
    await client.deleteTokenByUser(userId, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} UserKeyResponse
 * @property {string} public_key
 */

/**
 * @typedef {Object} UserLoginRequest
 * @property {string} username
 * @property {string} password
 */

/**
 * @typedef {Object} AccessTokenMap
 * @property {Uuid} api_id
 * @property {string} access_token
 * @property {string} refresh_token
 */

/**
 * @param {*} r 
 * @returns {AccessTokenMap}
 */
function get_access_token(r) {
    return {
        api_id: base64_to_uuid_hex(r.apiId),
        access_token: r.accessToken,
        refresh_token: r.refreshToken
    };
}

/**
 * @typedef {Object} UserLoginResponse
 * @property {Uuid} user_id
 * @property {string} auth_token
 * @property {AccessTokenMap[]} access_tokens
 */

/**
 * @param {*} r 
 * @returns {UserLoginResponse}
 */
function get_login_response(r) {
    return {
        user_id: base64_to_uuid_hex(r.userId),
        auth_token: r.authToken,
        access_tokens: r.accessTokensList.map((v) => {return get_access_token(v)})
    };
}

/**
 * @typedef {Object} UserRefreshRequest
 * @property {Uuid} api_id
 * @property {string} access_token
 * @property {string} refresh_token
 */

/**
 * @typedef {Object} UserRefreshResponse
 * @property {string} access_token
 * @property {string} refresh_token
 */

/**
 * @param {*} r 
 * @returns {UserRefreshResponse}
 */
function get_refresh_response(r) {
    return {
        access_token: r.accessToken,
        refresh_token: r.refreshToken
    };
}

/**
 * @typedef {Object} UserLogoutRequest
 * @property {Uuid} user_id
 * @property {string} auth_token
 */

/**
 * Import a PEM encoded RSA public key, to use for RSA-OAEP / RSASSA-PKCS1-v1_5 encryption
 * @param {string} pem 
 * @returns 
 */
function importKey(pem) {
    try {
        const binaryDerString = window.atob(pem);
        const binaryDer = string_to_array_buffer(binaryDerString);
        return window.crypto.subtle.importKey(
            "spki",
            binaryDer,
            {
                name: "RSA-OAEP",
                hash: "SHA-256"
            },
            true,
            ["encrypt"]
        );
    } catch {
        return null;
    }
}

/**
 * Get the encoded message, encrypt it and display a representation of the ciphertext
 * @param {string} message 
 * @param {CryptoKey} encryptionKey 
 * @returns 
 */
async function encryptMessage(message, encryptionKey)
{
    try {
        const enc = new TextEncoder();
        const encoded = enc.encode(message);
        const buf = await window.crypto.subtle.encrypt(
            {
                name: "RSA-OAEP"
            },
            encryptionKey,
            encoded
        );
        const chars = String.fromCharCode.apply(null, new Uint8Array(buf));
        return btoa(chars);
    } catch {
        return null;
    }
}


/**
 * Get user login key
 * @param {ServerConfig} server Server configuration
 * @param {} request empty object
 * @param {function(?grpc.web.RpcError, ?UserKeyResponse)} callback The callback function(error, response)
 */
async function user_login_key(server, request, callback) {
    const client = new pb_auth.AuthServiceClient(server.address, null, null);
    const userKeyRequest = new pb_auth.UserKeyRequest();
    await client.userLoginKey(userKeyRequest, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * User login
 * @param {ServerConfig} server Server configuration
 * @param {UserLoginRequest} request user login request: username, password
 * @param {function(?grpc.web.RpcError, ?UserLoginResponse)} callback The callback function(error, response)
 */
async function user_login(server, request, callback) {
    const client = new pb_auth.AuthServiceClient(server.address, null, null);
    const userKeyRequest = new pb_auth.UserKeyRequest();
    const userLoginRequest = new pb_auth.UserLoginRequest();
    userLoginRequest.setUsername(request.username);
    await client.userLoginKey(userKeyRequest, {}, async (e, r) => {
        if (r) {
            const key = r.toObject().publicKey;
            const pubkey = await importKey(key);
            const ciphertext = await encryptMessage(request.password, pubkey);
            userLoginRequest.setPassword(ciphertext);
            await client.userLogin(userLoginRequest, metadata(server), (e, r) => {
                const response = r ? get_login_response(r.toObject()) : null;
                callback(e, response);
            });
        }
    });
}

/**
 * Refresh user token
 * @param {ServerConfig} server Server configuration
 * @param {UserRefreshRequest} request user refresh request: api_id, access_token, refresh_token
 * @param {function(?grpc.web.RpcError, ?UserRefreshResponse)} callback The callback function(error, response)
 */
async function user_refresh(server, request, callback) {
    const client = new pb_auth.AuthServiceClient(server.address, null, null);
    const userRefreshRequest = new pb_auth.UserRefreshRequest();
    userRefreshRequest.setApiId(uuid_hex_to_base64(request.api_id));
    userRefreshRequest.setAccessToken(request.access_token);
    userRefreshRequest.setRefreshToken(request.refresh_token);
    await client.userRefresh(userRefreshRequest, metadata(server), (e, r) => {
        const response = r ? get_refresh_response(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * User logout
 * @param {ServerConfig} server Server configuration
 * @param {UserLogoutRequest} request user logout request: user_id, auth_token
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function user_logout(server, request, callback) {
    const client = new pb_auth.AuthServiceClient(server.address, null, null);
    const userLogoutRequest = new pb_auth.UserLogoutRequest();
    userLogoutRequest.setUserId(uuid_hex_to_base64(request.user_id));
    userLogoutRequest.setAuthToken(request.auth_token);
    await client.userLogout(userLogoutRequest, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

var index$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    add_role_access: add_role_access,
    add_user_role: add_user_role,
    create_access_token: create_access_token,
    create_api: create_api,
    create_auth_token: create_auth_token,
    create_procedure: create_procedure,
    create_role: create_role,
    create_user: create_user,
    delete_access_token: delete_access_token,
    delete_api: delete_api,
    delete_auth_token: delete_auth_token,
    delete_procedure: delete_procedure,
    delete_role: delete_role,
    delete_token_by_user: delete_token_by_user,
    delete_user: delete_user,
    list_api_by_category: list_api_by_category,
    list_auth_token: list_auth_token,
    list_procedure_by_api: list_procedure_by_api,
    list_role_by_api: list_role_by_api,
    list_role_by_user: list_role_by_user,
    list_token_by_user: list_token_by_user,
    list_user_by_role: list_user_by_role,
    read_access_token: read_access_token,
    read_api: read_api,
    read_api_by_name: read_api_by_name,
    read_procedure: read_procedure,
    read_procedure_by_name: read_procedure_by_name,
    read_role: read_role,
    read_role_by_name: read_role_by_name,
    read_user: read_user,
    read_user_by_name: read_user_by_name,
    remove_role_access: remove_role_access,
    remove_user_role: remove_user_role,
    update_access_token: update_access_token,
    update_api: update_api,
    update_auth_token: update_auth_token,
    update_procedure: update_procedure,
    update_role: update_role,
    update_user: update_user,
    user_login: user_login,
    user_login_key: user_login_key,
    user_logout: user_logout,
    user_refresh: user_refresh
});

/**
 * @enum {number}
 */
const DataType = {
    NULLD: 0,
    I8: 1,
    I16: 2,
    I32: 3,
    I64: 4,
    U8: 5,
    U16: 6,
    U32: 7,
    U64: 8,
    F32: 9,
    F64: 10,
    CHAR: 11,
    BOOL: 12
};

/**
 * @enum {number}
 */
const ConfigType = {
    NULLC: 0,
    INT: 1,
    FLOAT: 2,
    STR: 3
};

/**
 * @param {number|string} type
 * @returns {number}
 */
function set_data_type(type) {
    if (typeof type === "number") {
        if (type >= 0 && type <= 12) {
            return type;
        }
    }
    else if (typeof type === "string") {
        switch (type.toUpperCase()) {
            case "I8": return DataType.I8;
            case "I16": return DataType.I16;
            case "I32": return DataType.I32;
            case "I64": return DataType.I64;
            case "U8": return DataType.U8;
            case "U16": return DataType.U16;
            case "U32": return DataType.U32;
            case "U64": return DataType.U64;
            case "F32": return DataType.F32;
            case "F64": return DataType.F64;
            case "CHAR": return DataType.CHAR;
            case "BOOL": return DataType.BOOL;
        }
    }
    return DataType.NULLD;
}

/**
 * @param {number} type 
 * @returns {string}
 */
function get_data_type(type) {
    switch (type) {
        case DataType.I8: return "I8";
        case DataType.I16: return "I16";
        case DataType.I32: return "I32";
        case DataType.I64: return "I64";
        case DataType.U8: return "U8";
        case DataType.U16: return "U16";
        case DataType.U32: return "U32";
        case DataType.U64: return "U64";
        case DataType.F32: return "F32";
        case DataType.F64: return "F64";
        case DataType.CHAR: return "CHAR";
        case DataType.BOOL: return "BOOL";
    }
    return "NULL";
}

/**
 * @param {string} base64 
 * @returns {ArrayBufferLike}
 */
function base64_to_array_buffer(base64) {
    let binaryString = atob(base64);
    let bytes = new Uint8Array(binaryString.length);
    for (let i=0; i<binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return bytes.buffer;
}

/**
 * @param {ArrayBufferLike} buffer 
 * @returns {string}
 */
function array_buffer_to_base64(buffer) {
    let bytes = new Uint8Array(buffer);
    let binaryString = String.fromCharCode.apply(null, bytes);
    return btoa(binaryString);
}

/**
 * @param {string} base64 
 * @param {number[]} types 
 * @returns {(number|bigint|string|boolean|null)[]}
 */
function get_data_value(base64, types) {
    const view = new DataView(base64_to_array_buffer(base64));
    let values = [];
    let offset = 0;
    for (const type of types) {
        switch (type) {
            case DataType.I8: 
                values.push(view.getInt8(offset));
                offset += 1;
                break;
            case DataType.I16: 
                values.push(view.getInt16(offset));
                offset += 2;
                break;
            case DataType.I32: 
                values.push(view.getInt32(offset));
                offset += 4;
                break;
            case DataType.I64: 
                values.push(view.getBigInt64(offset));
                offset += 8;
                break;
            case DataType.U8: 
                values.push(view.getUint8(offset));
                offset += 1;
                break;
            case DataType.U16: 
                values.push(view.getUint16(offset));
                offset += 2;
                break;
            case DataType.U32: 
                values.push(view.getUint32(offset));
                offset += 4;
                break;
            case DataType.U64: 
                values.push(view.getBigUint64(offset));
                offset += 8;
                break;
            case DataType.F32: 
                values.push(view.getFloat32(offset));
                offset += 4;
                break;
            case DataType.F64: 
                values.push(view.getFloat64(offset));
                offset += 8;
                break;
            case DataType.CHAR: 
                values.push(String.fromCharCode(view.getUint8(offset)));
                offset += 1;
                break;
            case DataType.BOOL: 
                values.push(Boolean(view.getUint8(offset)));
                offset += 1;
                break;
            default:
                values.push(null);
        }
    }
    return values;
}

/**
 * @param {(number|bigint|string|boolean)[]} values
 */
function set_data_value(values) {
    if (values === undefined) {
        return {
            bytes: "",
            types: []
        };
    }
    let base64 = "";
    let types = [];
    for (const value of values) {
        let type = DataType.NULLD;
        if (typeof value == "number") {
            if (Number.isInteger(value)) {
                const buffer = new ArrayBuffer(4);
                const view = new DataView(buffer);
                view.setInt32(0, value);
                type = DataType.I32;
                base64 += array_buffer_to_base64(view.buffer);
            } else {
                const buffer = new ArrayBuffer(8);
                const view = new DataView(buffer);
                view.setFloat64(0, value);
                type = DataType.F64;
                base64 += array_buffer_to_base64(view.buffer);
            }
        }
        if (typeof value == "bigint") {
            const buffer = new ArrayBuffer(8);
            const view = new DataView(buffer);
            view.setBigInt64(0, value);
            type = DataType.I64;
            base64 += array_buffer_to_base64(view.buffer);
        }
        else if (typeof value == "string") {
            type = DataType.CHAR;
            base64 += btoa(value);
        }
        else if (typeof value == "boolean") {
            type = DataType.BOOL;
            base64 += btoa(String.fromCharCode(value));
        }
        types.push(type);
    }
    return {
        bytes: base64,
        types: types
    };
}

/**
 * @param {string} base64 
 * @param {ConfigType} type 
 * @returns {(number|string|null)[]}
 */
function get_config_value(base64, type) {
    const view = new DataView(base64_to_array_buffer(base64));
    if (type == ConfigType.STR) {
        return atob(base64);
    }
    else if (type == ConfigType.INT) {
        return view.getInt32(4);
    }
    else if (type == ConfigType.FLOAT) {
        return view.getFloat64(0);
    }
    return null;
}

/**
 * @param {?number|string} value 
 */
function set_config_value(value) {
    if (value === undefined) {
        return {
            bytes: undefined,
            type: undefined
        };
    }
    let base64 = "";
    let type = ConfigType.NULLC;
    if (typeof value == "number") {
        const buffer = new ArrayBuffer(8);
        const view = new DataView(buffer);
        if (Number.isInteger(value)) {
            view.setInt32(4, value);
            type = ConfigType.INT;
        } else {
            view.setFloat64(0, value);
            type = ConfigType.FLOAT;
        }
        base64 = array_buffer_to_base64(view.buffer);
    }
    else if (typeof value == "string") {
        type = ConfigType.STR;
        base64 = btoa(value);
    }
    return {
        bytes: base64,
        type: type
    };
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} ModelId
 * @property {Uuid} id
 */

/**
 * @param {*} r 
 * @returns {ModelId}
 */
function get_model_id(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
 * @typedef {Object} ModelName
 * @property {string} name
 */

/**
 * @typedef {Object} ModelCategory
 * @property {string} category
 */

/**
 * @typedef {Object} ModelNameCategory
 * @property {string} name
 * @property {string} category
 */

/**
 * @typedef {Object} TypeId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} ModelSchema
 * @property {Uuid} id
 * @property {string} category
 * @property {string} name
 * @property {string} description
 * @property {number[]|string[]} data_type
 * @property {ModelConfigSchema[][]} configs
 */

/**
 * @param {*} r 
 * @returns {ModelSchema}
 */
function get_model_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        category: r.category,
        name: r.name,
        description: r.description,
        data_type: r.dataTypeList.map((v) => { return get_data_type(v) }),
        configs: r.configsList.map((v) => { return get_model_config_schema_vec(v.configsList) })
    };
}

/**
 * @param {*} r 
 * @returns {ModelSchema[]}
 */
function get_model_schema_vec(r) {
    return r.map((v) => {return get_model_schema(v)});
}

/**
 * @typedef {Object} ModelUpdate
 * @property {Uuid} id
 * @property {?string} category
 * @property {?string} name
 * @property {?string} description
 * @property {?number[]|string[]} data_type
 */

/**
 * @typedef {Object} ModelConfigId
 * @property {number} id
 */

/**
 * @param {*} r 
 * @returns {ModelConfigId}
 */
function get_model_config_id(r) {
    return {
        id: r.id
    };
}

/**
 * @typedef {Object} ModelConfigSchema
 * @property {number} id
 * @property {Uuid} model_id
 * @property {number} index
 * @property {string} name
 * @property {number|string} value
 * @property {string} category
 */

/**
 * @param {*} r 
 * @returns {ModelConfigSchema}
 */
function get_model_config_schema(r) {
    return {
        id: r.id,
        model_id: base64_to_uuid_hex(r.modelId),
        index: r.index,
        name: r.name,
        value: get_config_value(r.configBytes, r.configType),
        category: r.category
    };
}

/**
 * @param {*} r 
 * @returns {ModelConfigSchema[]}
 */
function get_model_config_schema_vec(r) {
    return r.map((v) => {return get_model_config_schema(v)});
}

/**
 * @typedef {Object} ModelConfigUpdate
 * @property {number} id
 * @property {?string} name
 * @property {?number|string} value
 * @property {?string} category
 */


/**
 * Read a model by uuid
 * @param {ServerConfig} server Server configuration
 * @param {ModelId} request model uuid: id
 * @param {function(?grpc.web.RpcError, ?ModelSchema)} callback The callback function(error, response)
 */
async function read_model(server, request, callback) {
    const client = new pb_model.ModelServiceClient(server.address, null, null);
    const modelId = new pb_model.ModelId();
    modelId.setId(uuid_hex_to_base64(request.id));
    await client.readModel(modelId, metadata(server), (e, r) => {
        const response = r ? get_model_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read models by name
 * @param {ServerConfig} server Server configuration
 * @param {ModelName} request model name: name
 * @param {function(?grpc.web.RpcError, ?ModelSchema[])} callback The callback function(error, response)
 */
async function list_model_by_name(server, request, callback) {
    const client = new pb_model.ModelServiceClient(server.address, null, null);
    const modelName = new pb_model.ModelName();
    modelName.setName(request.name);
    await client.listModelByName(modelName, metadata(server), (e, r) => {
        const response = r ? get_model_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read models by category
 * @param {ServerConfig} server Server configuration
 * @param {ModelCategory} request model category: category
 * @param {function(?grpc.web.RpcError, ?ModelSchema[])} callback The callback function(error, response)
 */
async function list_model_by_category(server, request, callback) {
    const client = new pb_model.ModelServiceClient(server.address, null, null);
    const modelCategory = new pb_model.ModelCategory();
    modelCategory.setCategory(request.category);
    await client.listModelByCategory(modelCategory, metadata(server), (e, r) => {
        const response = r ? get_model_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read models by name and category
 * @param {ServerConfig} server Server configuration
 * @param {ModelNameCategory} request model name and category: name, category
 * @param {function(?grpc.web.RpcError, ?ModelSchema[])} callback The callback function(error, response)
 */
async function list_model_by_name_category(server, request, callback) {
    const client = new pb_model.ModelServiceClient(server.address, null, null);
    const modelNameCategory = new pb_model.ModelNameCategory();
    modelNameCategory.setName(request.name);
    modelNameCategory.setCategory(request.category);
    await client.listModelByNameCategory(modelNameCategory, metadata(server), (e, r) => {
        const response = r ? get_model_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read models by type
 * @param {ServerConfig} server Server configuration
 * @param {TypeId} request type uuid: id
 * @param {function(?grpc.web.RpcError, ?ModelSchema[])} callback The callback function(error, response)
 */
async function list_model_by_type(server, request, callback) {
    const client = new pb_model.ModelServiceClient(server.address, null, null);
    const typeId = new pb_model.TypeId();
    typeId.setId(uuid_hex_to_base64(request.id));
    await client.listModelByType(modelNameCategory, metadata(server), (e, r) => {
        const response = r ? get_model_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Create a model
 * @param {ServerConfig} server Server configuration
 * @param {ModelSchema} request model schema: id, data_type, category, name, description
 * @param {function(?grpc.web.RpcError, ?ModelId)} callback The callback function(error, response)
 */
async function create_model(server, request, callback) {
    const client = new pb_model.ModelServiceClient(server.address, null, null);
    const modelSchema = new pb_model.ModelSchema();
    modelSchema.setId(uuid_hex_to_base64(request.id));
    modelSchema.setDataTypeList(request.data_type.map((v) => {return set_data_type(v)}));
    modelSchema.setCategory(request.category);
    modelSchema.setName(request.name);
    modelSchema.setDescription(request.description);
    await client.createModel(modelSchema, metadata(server), (e, r) => {
        const response = r ? get_model_id(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * Update a model
 * @param {ServerConfig} server Server configuration
 * @param {ModelUpdate} request model update: id, data_type, category, name, description
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function update_model(server, request, callback) {
    const client = new pb_model.ModelServiceClient(server.address, null, null);
    const modelUpdate = new pb_model.ModelUpdate();
    modelUpdate.setId(uuid_hex_to_base64(request.id));
    if (request.data_type) {
        modelUpdate.setDataTypeList(request.data_type.map((v) => {return set_data_type(v)}));
        modelUpdate.setDataTypeFlag(true);
    } else {
        modelUpdate.setDataTypeFlag(false);
    }
    modelUpdate.setCategory(request.category);
    modelUpdate.setName(request.name);
    modelUpdate.setDescription(request.description);
    await client.updateModel(modelUpdate, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Delete a model
 * @param {ServerConfig} server Server configuration
 * @param {ModelId} request model id: id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_model(server, request, callback) {
    const client = new pb_model.ModelServiceClient(server.address, null, null);
    const modelId = new pb_model.ModelId();
    modelId.setId(uuid_hex_to_base64(request.id));
    await client.deleteModel(modelId, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Read a model configuration by uuid
 * @param {ServerConfig} server Server configuration
 * @param {ModelConfigId} request model config uuid: id
 * @param {function(?grpc.web.RpcError, ?ModelConfigSchema)} callback The callback function(error, response)
 */
async function read_model_config(server, request, callback) {
    const client = new pb_model.ModelServiceClient(server.address, null, null);
    const configId = new pb_model.ConfigId();
    configId.setId(request.id);
    await client.readModelConfig(configId, metadata(server), (e, r) => {
        const response = r ? get_model_config_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read model configurations by model uuid
 * @param {ServerConfig} server Server configuration
 * @param {ModelId} request model uuid: id
 * @param {function(?grpc.web.RpcError, ?ModelConfigSchema[])} callback The callback function(error, response)
 */
async function list_model_config_by_model(server, request, callback) {
    const client = new pb_model.ModelServiceClient(server.address, null, null);
    const modelId = new pb_model.ModelId();
    modelId.setId(uuid_hex_to_base64(request.id));
    await client.listModelConfig(modelId, metadata(server), (e, r) => {
        const response = r ? get_model_config_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Create a model configuration
 * @param {ServerConfig} server Server configuration
 * @param {ModelConfigSchema} request model config schema: model_id, index, name, value, category
 * @param {function(?grpc.web.RpcError, ?ModelConfigId)} callback The callback function(error, response)
 */
async function create_model_config(server, request, callback) {
    const client = new pb_model.ModelServiceClient(server.address, null, null);
    const configSchema = new pb_model.ConfigSchema();
    configSchema.setModelId(uuid_hex_to_base64(request.model_id));
    configSchema.setIndex(request.index);
    configSchema.setName(request.name);
    const value = set_config_value(request.value);
    configSchema.setConfigBytes(value.bytes);
    configSchema.setConfigType(value.type);
    configSchema.setCategory(request.category);
    await client.createModelConfig(configSchema, metadata(server), (e, r) => {
        const response = r ? get_model_config_id(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * Update a model configuration
 * @param {ServerConfig} server Server configuration
 * @param {ModelConfigUpdate} request model config update: id, name, value, category
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function update_model_config(server, request, callback) {
    const client = new pb_model.ModelServiceClient(server.address, null, null);
    const configUpdate = new pb_model.ConfigUpdate();
    configUpdate.setId(request.id);
    configUpdate.setName(request.name);
    const value = set_config_value(request.value);
    configUpdate.setConfigBytes(value.bytes);
    configUpdate.setConfigType(value.type);
    configUpdate.setCategory(request.category);
    await client.updateModelConfig(configUpdate, metadata(server), (e, r) => {
        callback(e, r.toObject());
    });
}

/**
 * Delete a model configuration
 * @param {ServerConfig} server Server configuration
 * @param {ModelConfigId} request model config uuid: id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_model_config(server, request, callback) {
    const client = new pb_model.ModelServiceClient(server.address, null, null);
    const configId = new pb_model.ConfigId();
    configId.setId(request.id);
    await client.deleteModelConfig(configId, metadata(server), (e, r) => {
        callback(e, r.toObject());
    });
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} TypeId
 * @property {Uuid} id
 */

/**
 * @typedef {Object} TypeName
 * @property {string} name
 */

/**
 * @param {*} r 
 * @returns {TypeId}
 */
function get_type_id(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
 * @typedef {Object} TypeSchema
 * @property {Uuid} id
 * @property {string} name
 * @property {string} description
 * @property {Uuid[]} models
 */

/**
 * @param {*} r 
 * @returns {TypeSchema}
 */
function get_type_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        name: r.name,
        description: r.description,
        models: r.modelsList.map((v) => {return base64_to_uuid_hex(v)})
    };
}

/**
 * @param {*} r 
 * @returns {TypeSchema[]}
 */
function get_type_schema_vec(r) {
    return r.map((v) => {return get_type_schema(v)});
}

/**
 * @typedef {Object} TypeUpdate
 * @property {Uuid} id
 * @property {?string} name
 * @property {?string} description
 */

/**
 * @typedef {Object} TypeModel
 * @property {Uuid} id
 * @property {Uuid} model_id
 */


/**
 * Read a device type by uuid
 * @param {ServerConfig} server Server configuration
 * @param {TypeId} request type uuid: id
 * @param {function(?grpc.web.RpcError, ?TypeSchema)} callback The callback function(error, response)
 */
async function read_type(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const typeId = new pb_device.TypeId();
    typeId.setId(uuid_hex_to_base64(request.id));
    await client.readType(typeId, metadata(server), (e, r) => {
        const response = r ? get_type_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read device types by name
 * @param {ServerConfig} server Server configuration
 * @param {TypeName} request type name: name
 * @param {function(?grpc.web.RpcError, ?TypeSchema[])} callback The callback function(error, response)
 */
async function list_type_by_name(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const typeName = new pb_device.TypeName();
    typeName.setName(request.name);
    await client.listTypeByName(typeName, metadata(server), (e, r) => {
        const response = r ? get_type_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Create a device type
 * @param {ServerConfig} server Server configuration
 * @param {TypeSchema} request type schema: id, name, description
 * @param {function(?grpc.web.RpcError, ?TypeId)} callback The callback function(error, response)
 */
async function create_type(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const typeSchema = new pb_device.TypeSchema();
    typeSchema.setId(uuid_hex_to_base64(request.id));
    typeSchema.setName(request.name);
    typeSchema.setDescription(request.description);
    await client.createType(typeSchema, metadata(server), (e, r) => {
        const response = r ? get_type_id(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * Update a device type
 * @param {ServerConfig} server Server configuration
 * @param {TypeUpdate} request type update: id, name, description
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function update_type(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const typeUpdate = new pb_device.TypeUpdate();
    typeUpdate.setId(uuid_hex_to_base64(request.id));
    typeUpdate.setName(request.name);
    typeUpdate.setDescription(request.description);
    await client.updateType(typeUpdate, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Delete a device type
 * @param {ServerConfig} server Server configuration
 * @param {TypeId} request type id: id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_type(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const typeId = new pb_device.TypeId();
    typeId.setId(uuid_hex_to_base64(request.id));
    await client.deleteType(typeId, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Add model to a device type
 * @param {ServerConfig} server Server configuration
 * @param {TypeModel} request type id: id, model_id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function add_type_model(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const typeModel = new pb_device.TypeModel();
    typeModel.setId(uuid_hex_to_base64(request.id));
    typeModel.setModelId(uuid_hex_to_base64(request.model_id));
    await client.addTypeModel(typeModel, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Remove model from a device type
 * @param {ServerConfig} server Server configuration
 * @param {TypeModel} request type id: id, model_id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function remove_type_model(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const typeModel = new pb_device.TypeModel();
    typeModel.setId(uuid_hex_to_base64(request.id));
    typeModel.setModelId(uuid_hex_to_base64(request.model_id));
    await client.removeTypeModel(typeModel, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} DeviceId
 * @property {Uuid} id
 */

/**
 * @param {*} r 
 * @returns {DeviceId}
 */
function get_device_id(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
 * @typedef {Object} SerialNumber
 * @property {string} serial_number
 */

/**
 * @typedef {import('./types.js').TypeId} TypeId
 */

/**
 * @typedef {Object} DeviceName
 * @property {string} name
 */

/**
 * @typedef {Object} DeviceGatewayType
 * @property {Uuid} gateway_id
 * @property {Uuid} type_id
 */

/**
 * @typedef {Object} DeviceGatewayName
 * @property {Uuid} gateway_id
 * @property {string} name
 */

/**
 * @typedef {Object} DeviceSchema
 * @property {Uuid} id
 * @property {Uuid} gateway_id
 * @property {string} serial_number
 * @property {string} name
 * @property {string} description
 * @property {import('./types.js').TypeSchema} device_type
 * @property {DeviceConfigSchema[]} configs
 */

/**
 * @param {*} r 
 * @returns {DeviceSchema}
 */
function get_device_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        gateway_id: base64_to_uuid_hex(r.gatewayId),
        serial_number: r.serialNumber,
        name: r.name,
        description: r.description,
        device_type: get_type_schema(r.deviceType),
        configs: get_device_config_schema_vec(r.configsList)
    };
}

/**
 * @param {*} r 
 * @returns {DeviceSchema[]}
 */
function get_device_schema_vec(r) {
    return r.map((v) => {return get_device_schema(v)});
}

/**
 * @typedef {Object} DeviceCreate
 * @property {Uuid} id
 * @property {Uuid} gateway_id
 * @property {string} serial_number
 * @property {string} name
 * @property {string} description
 * @property {Uuid} type_id
 */

/**
 * @typedef {Object} DeviceUpdate
 * @property {Uuid} id
 * @property {?Uuid} gateway_id
 * @property {?string} serial_number
 * @property {?string} name
 * @property {?string} description
 * @property {?Uuid} type_id
 */

/**
 * @typedef {Object} GatewayId
 * @property {Uuid} id
 */

/**
 * @param {*} r 
 * @returns {GatewayId}
 */
function get_gateway_id(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
 * @typedef {Object} GatewayName
 * @property {string} name
 */

/**
 * @typedef {Object} GatewaySchema
 * @property {Uuid} id
 * @property {string} serial_number
 * @property {string} name
 * @property {string} description
 * @property {import('./types.js').TypeSchema} gateway_type
 * @property {GatewayConfigSchema[]} configs
 */

/**
 * @param {*} r 
 * @returns {GatewaySchema}
 */
function get_gateway_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        serial_number: r.serialNumber,
        name: r.name,
        description: r.description,
        gateway_type: get_type_schema(r.gatewayType),
        configs: get_device_config_schema_vec(r.configsList)
    };
}

/**
 * @param {*} r 
 * @returns {GatewaySchema[]}
 */
function get_gateway_schema_vec(r) {
    return r.map((v) => {return get_gateway_schema(v)});
}

/**
 * @typedef {Object} GatewayCreate
 * @property {Uuid} id
 * @property {string} serial_number
 * @property {string} name
 * @property {string} description
 * @property {?Uuid} type_id
 */

/**
 * @typedef {Object} GatewayUpdate
 * @property {Uuid} id
 * @property {?string} serial_number
 * @property {?string} name
 * @property {?string} description
 * @property {?Uuid} type_id
 */

/**
 * @typedef {Object} ConfigId
 * @property {number} id
 */

/**
 * @param {*} r 
 * @returns {ConfigId}
 */
function get_config_id(r) {
    return {
        id: r.id
    };
}

/**
 * @typedef {Object} DeviceConfigSchema
 * @property {number} id
 * @property {Uuid} device_id
 * @property {string} name
 * @property {number|string} value
 * @property {string} category
 */

/**
 * @typedef {Object} GatewayConfigSchema
 * @property {number} id
 * @property {Uuid} gateway_id
 * @property {string} name
 * @property {number|string} value
 * @property {string} category
 */

/**
 * @param {*} r 
 * @returns {DeviceConfigSchema}
 */
function get_device_config_schema(r) {
    return {
        id: r.id,
        device_id: base64_to_uuid_hex(r.deviceId),
        name: r.name,
        value: get_config_value(r.configBytes, r.configType),
        category: r.category
    };
}

/**
 * @param {*} r 
 * @returns {DeviceConfigSchema[]}
 */
function get_device_config_schema_vec(r) {
    return r.map((v) => {return get_device_config_schema(v)});
}

/**
 * @param {*} r 
 * @returns {GatewayConfigSchema}
 */
function get_gateway_config_schema(r) {
    return {
        id: r.id,
        gateway_id: base64_to_uuid_hex(r.deviceId),
        name: r.name,
        value: get_config_value(r.configBytes, r.configType),
        category: r.category
    };
}

/**
 * @param {*} r 
 * @returns {GatewayConfigSchema[]}
 */
function get_gateway_config_schema_vec(r) {
    return r.map((v) => {return get_gateway_config_schema(v)});
}

/**
 * @typedef {Object} ConfigUpdate
 * @property {number} id
 * @property {?string} name
 * @property {?number|string} value
 * @property {?string} category
 */


/**
 * Read a device by uuid
 * @param {ServerConfig} server Server configuration
 * @param {DeviceId} request device uuid: id
 * @param {function(?grpc.web.RpcError, ?DeviceSchema)} callback The callback function(error, response)
 */
async function read_device(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const deviceId = new pb_device.DeviceId();
    deviceId.setId(uuid_hex_to_base64(request.id));
    await client.readDevice(deviceId, metadata(server), (e, r) => {
        const response = r ? get_device_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read a device by serial number
 * @param {ServerConfig} server Server configuration
 * @param {SerialNumber} request serial number: serial_number
 * @param {function(?grpc.web.RpcError, ?DeviceSchema)} callback The callback function(error, response)
 */
async function read_device_by_sn(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const serialNumber = new pb_device.SerialNumber();
    serialNumber.setSerialNumber(request.serial_number);
    await client.readDeviceBySn(serialNumber, metadata(server), (e, r) => {
        const response = r ? get_device_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read devices by gateway
 * @param {ServerConfig} server Server configuration
 * @param {GatewayId} request gateway uuid: id
 * @param {function(?grpc.web.RpcError, ?DeviceSchema[])} callback The callback function(error, response)
 */
async function list_device_by_gateway(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const gatewayId = new pb_device.GatewayId();
    gatewayId.setId(uuid_hex_to_base64(request.id));
    await client.listDeviceByGateway(gatewayId, metadata(server), (e, r) => {
        const response = r ? get_device_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read devices by type
 * @param {ServerConfig} server Server configuration
 * @param {TypeId} request type uuid: id
 * @param {function(?grpc.web.RpcError, ?DeviceSchema[])} callback The callback function(error, response)
 */
async function list_device_by_type(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const typeId = new pb_device.TypeId();
    typeId.setId(uuid_hex_to_base64(request.id));
    await client.listDeviceByType(typeId, metadata(server), (e, r) => {
        const response = r ? get_device_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read devices by name
 * @param {ServerConfig} server Server configuration
 * @param {DeviceName} request device name: name
 * @param {function(?grpc.web.RpcError, ?DeviceSchema[])} callback The callback function(error, response)
 */
async function list_device_by_name(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const deviceName = new pb_device.DeviceName();
    deviceName.setName(request.name);
    await client.listDeviceByName(deviceName, metadata(server), (e, r) => {
        const response = r ? get_device_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read devices by gateway and type
 * @param {ServerConfig} server Server configuration
 * @param {DeviceGatewayType} request gateway and type: gateway_id, type_id
 * @param {function(?grpc.web.RpcError, ?DeviceSchema[])} callback The callback function(error, response)
 */
async function list_device_by_gateway_type(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const gatewayType = new pb_device.DeviceGatewayType();
    gatewayType.setId(uuid_hex_to_base64(request.gateway_id));
    gatewayType.setId(uuid_hex_to_base64(request.type_id));
    await client.listDeviceByGatewayType(gatewayType, metadata(server), (e, r) => {
        const response = r ? get_device_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read devices by gateway and name
 * @param {ServerConfig} server Server configuration
 * @param {DeviceGatewayName} request gateway and name: gateway_id, name
 * @param {function(?grpc.web.RpcError, ?DeviceSchema[])} callback The callback function(error, response)
 */
async function list_device_by_gateway_name(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const gatewayName = new pb_device.DeviceGatewayName();
    gatewayName.setId(uuid_hex_to_base64(request.gateway_id));
    gatewayName.setId(request.name);
    await client.listDeviceByGatewayName(gatewayName, metadata(server), (e, r) => {
        const response = r ? get_device_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Create a device
 * @param {ServerConfig} server Server configuration
 * @param {DeviceCreate} request device schema: id, gateway_id, serial_number, name, description, type_id
 * @param {function(?grpc.web.RpcError, ?DeviceId)} callback The callback function(error, response)
 */
async function create_device(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const typeSchema = new pb_device.TypeSchema();
    typeSchema.setId(uuid_hex_to_base64(request.type_id));
    const deviceSchema = new pb_device.DeviceSchema();
    deviceSchema.setId(uuid_hex_to_base64(request.id));
    deviceSchema.setGatewayId(uuid_hex_to_base64(request.gateway_id));
    deviceSchema.setSerialNumber(request.serial_number);
    deviceSchema.setName(request.name);
    deviceSchema.setDescription(request.description);
    deviceSchema.setDeviceType(typeSchema);
    await client.createDevice(deviceSchema, metadata(server), (e, r) => {
        const response = r ? get_device_id(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * Update a device
 * @param {ServerConfig} server Server configuration
 * @param {DeviceUpdate} request device update: id, gateway_id, serial_number, name, description, type_id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function update_device(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const deviceUpdate = new pb_device.DeviceUpdate();
    deviceUpdate.setId(uuid_hex_to_base64(request.id));
    if (request.gateway_id) {
        deviceUpdate.setGatewayId(uuid_hex_to_base64(request.gateway_id));
    }
    deviceUpdate.setSerialNumber(request.serial_number);
    deviceUpdate.setName(request.name);
    deviceUpdate.setDescription(request.description);
    deviceUpdate.setTypeId(request.type_id);
    await client.updateDevice(deviceUpdate, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Delete a device
 * @param {ServerConfig} server Server configuration
 * @param {DeviceId} request device uuid: id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_device(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const deviceId = new pb_device.DeviceId();
    deviceId.setId(uuid_hex_to_base64(request.id));
    await client.deleteDevice(deviceId, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Read a gateway by uuid
 * @param {ServerConfig} server Server configuration
 * @param {GatewayId} request gateway uuid: id
 * @param {function(?grpc.web.RpcError, ?GatewaySchema)} callback The callback function(error, response)
 */
async function read_gateway(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const gatewayId = new pb_device.GatewayId();
    gatewayId.setId(uuid_hex_to_base64(request.id));
    await client.readGateway(gatewayId, metadata(server), (e, r) => {
        const response = r ? get_gateway_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read a gateway by serial number
 * @param {ServerConfig} server Server configuration
 * @param {SerialNumber} request serial number: serial_number
 * @param {function(?grpc.web.RpcError, ?GatewaySchema)} callback The callback function(error, response)
 */
async function read_gateway_by_sn(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const serialNumber = new pb_device.SerialNumber();
    serialNumber.setSerialNumber(request.serial_number);
    await client.readGatewayBySn(serialNumber, metadata(server), (e, r) => {
        const response = r ? get_gateway_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read gateways by type
 * @param {ServerConfig} server Server configuration
 * @param {TypeId} request type uuid: id
 * @param {function(?grpc.web.RpcError, ?GatewaySchema[])} callback The callback function(error, response)
 */
async function list_gateway_by_type(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const typeId = new pb_device.TypeId();
    typeId.setId(uuid_hex_to_base64(request.id));
    await client.listGatewayByType(typeId, metadata(server), (e, r) => {
        const response = r ? get_gateway_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read gateways by name
 * @param {ServerConfig} server Server configuration
 * @param {GatewayName} request gateway name: name
 * @param {function(?grpc.web.RpcError, ?GatewaySchema[])} callback The callback function(error, response)
 */
async function list_gateway_by_name(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const gatewayName = new pb_device.GatewayName();
    gatewayName.setName(request.name);
    await client.listGatewayByName(gatewayName, metadata(server), (e, r) => {
        const response = r ? get_gateway_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Create a gateway
 * @param {ServerConfig} server Server configuration
 * @param {GatewayCreate} request gateway schema: id, serial_number, name, description, type_id
 * @param {function(?grpc.web.RpcError, ?GatewayId)} callback The callback function(error, response)
 */
async function create_gateway(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const typeSchema = new pb_device.TypeSchema();
    typeSchema.setId(uuid_hex_to_base64(request.type_id));
    const gatewaySchema = new pb_device.GatewaySchema();
    gatewaySchema.setId(uuid_hex_to_base64(request.id));
    gatewaySchema.setSerialNumber(request.serial_number);
    gatewaySchema.setName(request.name);
    gatewaySchema.setDescription(request.description);
    gatewaySchema.setGatewayType(typeSchema);
    await client.createGateway(gatewaySchema, metadata(server), (e, r) => {
        const response = r ? get_gateway_id(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * Update a gateway
 * @param {ServerConfig} server Server configuration
 * @param {GatewayUpdate} request gateway update: id, serial_number, name, description, type_id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function update_gateway(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const gatewayUpdate = new pb_device.GatewayUpdate();
    gatewayUpdate.setId(uuid_hex_to_base64(request.id));
    gatewayUpdate.setSerialNumber(request.serial_number);
    gatewayUpdate.setName(request.name);
    gatewayUpdate.setDescription(request.description);
    gatewayUpdate.setTypeId(request.type_id);
    await client.updateGateway(gatewayUpdate, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Delete a gateway
 * @param {ServerConfig} server Server configuration
 * @param {GatewayId} request gateway uuid: id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_gateway(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const gatewayId = new pb_device.GatewayId();
    gatewayId.setId(uuid_hex_to_base64(request.id));
    await client.deleteGateway(gatewayId, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Read a device configuration by uuid
 * @param {ServerConfig} server Server configuration
 * @param {ConfigId} request device config uuid: id
 * @param {function(?grpc.web.RpcError, ?DeviceConfigSchema)} callback The callback function(error, response)
 */
async function read_device_config(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const configId = new pb_device.ConfigId();
    configId.setId(request.id);
    await client.readDeviceConfig(configId, metadata(server), (e, r) => {
        const response = r ? get_device_config_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read device configurations by device uuid
 * @param {ServerConfig} server Server configuration
 * @param {DeviceId} request device uuid: id
 * @param {function(?grpc.web.RpcError, ?DeviceConfigSchema[])} callback The callback function(error, response)
 */
async function list_device_config_by_device(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const deviceId = new pb_device.DeviceId();
    deviceId.setId(uuid_hex_to_base64(request.id));
    await client.listDeviceConfig(deviceId, metadata(server), (e, r) => {
        const response = r ? get_device_config_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Create a device configuration
 * @param {ServerConfig} server Server configuration
 * @param {DeviceConfigSchema} request device config schema: device_id, name, value, category
 * @param {function(?grpc.web.RpcError, ?ConfigId)} callback The callback function(error, response)
 */
async function create_device_config(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const configSchema = new pb_device.ConfigSchema();
    configSchema.setDeviceId(uuid_hex_to_base64(request.device_id));
    configSchema.setName(request.name);
    const value = set_config_value(request.value);
    configSchema.setConfigBytes(value.bytes);
    configSchema.setConfigType(value.type);
    configSchema.setCategory(request.category);
    await client.createDeviceConfig(configSchema, metadata(server), (e, r) => {
        const response = r ? get_config_id(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * Update a device configuration
 * @param {ServerConfig} server Server configuration
 * @param {ConfigUpdate} request device config update: id, name, value, category
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function update_device_config(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const configUpdate = new pb_device.ConfigUpdate();
    configUpdate.setId(request.id);
    configUpdate.setName(request.name);
    const value = set_config_value(request.value);
    configUpdate.setConfigBytes(value.bytes);
    configUpdate.setConfigType(value.type);
    configUpdate.setCategory(request.category);
    await client.updateDeviceConfig(configUpdate, metadata(server), (e, r) => {
        callback(e, r.toObject());
    });
}

/**
 * Delete a device configuration
 * @param {ServerConfig} server Server configuration
 * @param {ConfigId} request device config uuid: id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_device_config(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const configId = new pb_device.ConfigId();
    configId.setId(request.id);
    await client.deleteDeviceConfig(configId, metadata(server), (e, r) => {
        callback(e, r.toObject());
    });
}

/**
 * Read a gateway configuration by uuid
 * @param {ServerConfig} server Server configuration
 * @param {ConfigId} request gateway config uuid: id
 * @param {function(?grpc.web.RpcError, ?GatewayConfigSchema)} callback The callback function(error, response)
 */
async function read_gateway_config(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const configId = new pb_device.ConfigId();
    configId.setId(request.id);
    await client.readGatewayConfig(configId, metadata(server), (e, r) => {
        const response = r ? get_gateway_config_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read gateway configurations by gateway uuid
 * @param {ServerConfig} server Server configuration
 * @param {GatewayId} request gateway uuid: id
 * @param {function(?grpc.web.RpcError, ?GatewayConfigSchema[])} callback The callback function(error, response)
 */
async function list_gateway_config_by_gateway(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const gatewayId = new pb_device.GatewayId();
    gatewayId.setId(uuid_hex_to_base64(request.id));
    await client.listGatewayConfig(gatewayId, metadata(server), (e, r) => {
        const response = r ? get_gateway_config_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Create a gateway configuration
 * @param {ServerConfig} server Server configuration
 * @param {GatewayConfigSchema} request gateway config schema: gateway_id, name, value, category
 * @param {function(?grpc.web.RpcError, ?ConfigId)} callback The callback function(error, response)
 */
async function create_gateway_config(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const configSchema = new pb_device.ConfigSchema();
    configSchema.setDeviceId(uuid_hex_to_base64(request.gateway_id));
    configSchema.setName(request.name);
    const value = set_config_value(request.value);
    configSchema.setConfigBytes(value.bytes);
    configSchema.setConfigType(value.type);
    configSchema.setCategory(request.category);
    await client.createGatewayConfig(configSchema, metadata(server), (e, r) => {
        const response = r ? get_config_id(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * Update a gateway configuration
 * @param {ServerConfig} server Server configuration
 * @param {ConfigUpdate} request gateway config update: id, name, value, category
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function update_gateway_config(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const configUpdate = new pb_device.ConfigUpdate();
    configUpdate.setId(request.id);
    configUpdate.setName(request.name);
    const value = set_config_value(request.value);
    configUpdate.setConfigBytes(value.bytes);
    configUpdate.setConfigType(value.type);
    configUpdate.setCategory(request.category);
    await client.updateGatewayConfig(configUpdate, metadata(server), (e, r) => {
        callback(e, r.toObject());
    });
}

/**
 * Delete a gateway configuration
 * @param {ServerConfig} server Server configuration
 * @param {ConfigId} request gateway config uuid: id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_gateway_config(server, request, callback) {
    const client = new pb_device.DeviceServiceClient(server.address, null, null);
    const configId = new pb_device.ConfigId();
    configId.setId(request.id);
    await client.deleteGatewayConfig(configId, metadata(server), (e, r) => {
        callback(e, r.toObject());
    });
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} GroupId
 * @property {Uuid} id
 */

/**
 * @param {*} r 
 * @returns {GroupId}
 */
function get_group_id(r) {
    return {
        id: base64_to_uuid_hex(r.id)
    };
}

/**
 * @typedef {Object} GroupName
 * @property {string} name
 */

/**
 * @typedef {Object} GroupCategory
 * @property {string} category
 */

/**
 * @typedef {Object} GroupNameCategory
 * @property {string} name
 * @property {string} category
 */

/**
 * @typedef {Object} GroupModelSchema
 * @property {Uuid} id
 * @property {string} name
 * @property {string} category
 * @property {string} description
 * @property {Uuid[]} models
 */

/**
 * @typedef {Object} GroupDeviceSchema
 * @property {Uuid} id
 * @property {string} name
 * @property {string} category
 * @property {string} description
 * @property {Uuid[]} devices
 */

/**
 * @typedef {Object} GroupGatewaySchema
 * @property {Uuid} id
 * @property {string} name
 * @property {string} category
 * @property {string} description
 * @property {Uuid[]} gateways
 */

/**
 * @param {*} r 
 * @returns {GroupModelSchema}
 */
function get_group_model_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        name: r.name,
        category: r.category,
        description: r.description,
        models: r.modelsList.map((v) => {return base64_to_uuid_hex(v)})
    };
}

/**
 * @param {*} r 
 * @returns {GroupModelSchema[]}
 */
function get_group_model_schema_vec(r) {
    return r.map((v) => {return get_group_model_schema(v)});
}

/**
 * @param {*} r 
 * @returns {GroupDeviceSchema}
 */
function get_group_device_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        name: r.name,
        category: r.category,
        description: r.description,
        devices: r.devicesList.map((v) => {return base64_to_uuid_hex(v)})
    };
}

/**
 * @param {*} r 
 * @returns {GroupDeviceSchema[]}
 */
function get_group_device_schema_vec(r) {
    return r.map((v) => {return get_group_device_schema(v)});
}

/**
 * @param {*} r 
 * @returns {GroupGatewaySchema}
 */
function get_group_gateway_schema(r) {
    return {
        id: base64_to_uuid_hex(r.id),
        name: r.name,
        category: r.category,
        description: r.description,
        gateways: r.devicesList.map((v) => {return base64_to_uuid_hex(v)})
    };
}

/**
 * @param {*} r 
 * @returns {GroupGatewaySchema[]}
 */
function get_group_gateway_schema_vec(r) {
    return r.map((v) => {return get_group_gateway_schema(v)});
}

/**
 * @typedef {Object} GroupUpdate
 * @property {Uuid} id
 * @property {?string} name
 * @property {?string} category
 * @property {?string} description
 */

/**
 * @typedef {Object} GroupModel
 * @property {Uuid} id
 * @property {Uuid} model_id
 */

/**
 * @typedef {Object} GroupDevice
 * @property {Uuid} id
 * @property {Uuid} device_id
 */

/**
 * @typedef {Object} GroupGateway
 * @property {Uuid} id
 * @property {Uuid} gateway_id
 */


/**
 * Read a group model by uuid
 * @param {ServerConfig} server Server configuration
 * @param {GroupId} request group model uuid: id
 * @param {function(?grpc.web.RpcError, ?GroupModelSchema)} callback The callback function(error, response)
 */
async function read_group_model(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupId = new pb_group.GroupId();
    groupId.setId(uuid_hex_to_base64(request.id));
    await client.readGroupModel(groupId, metadata(server), (e, r) => {
        const response = r ? get_group_model_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read groups of model by name
 * @param {ServerConfig} server Server configuration
 * @param {GroupName} request group model name: name
 * @param {function(?grpc.web.RpcError, ?GroupModelSchema[])} callback The callback function(error, response)
 */
async function list_group_model_by_name(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupName = new pb_group.GroupName();
    groupName.setName(request.name);
    await client.listGroupModelByName(groupName, metadata(server), (e, r) => {
        const response = r ? get_group_model_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read groups of model by category
 * @param {ServerConfig} server Server configuration
 * @param {GroupCategory} request group model category: category
 * @param {function(?grpc.web.RpcError, ?GroupModelSchema[])} callback The callback function(error, response)
 */
async function list_group_model_by_category(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupCategory = new pb_group.GroupCategory();
    groupCategory.setCategory(request.category);
    await client.listGroupModelByCategory(groupCategory, metadata(server), (e, r) => {
        const response = r ? get_group_model_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read groups of model by name and category
 * @param {ServerConfig} server Server configuration
 * @param {GroupNameCategory} request group model name and category: name, category
 * @param {function(?grpc.web.RpcError, ?GroupModelSchema[])} callback The callback function(error, response)
 */
async function list_group_model_by_name_category(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupNameCategory = new pb_group.GroupNameCategory();
    groupNameCategory.setName(request.name);
    groupNameCategory.setCategory(request.category);
    await client.listGroupModelByNameCategory(groupNameCategory, metadata(server), (e, r) => {
        const response = r ? get_group_model_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Create a group model
 * @param {ServerConfig} server Server configuration
 * @param {GroupModelSchema} request group model schema: id, name, category, description
 * @param {function(?grpc.web.RpcError, ?GroupId)} callback The callback function(error, response)
 */
async function create_group_model(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupSchema = new pb_group.GroupModelSchema();
    groupSchema.setId(uuid_hex_to_base64(request.id));
    groupSchema.setName(request.name);
    groupSchema.setCategory(request.category);
    groupSchema.setDescription(request.description);
    await client.createGroupModel(groupSchema, metadata(server), (e, r) => {
        const response = r ? get_group_id(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * Update a group model
 * @param {ServerConfig} server Server configuration
 * @param {GroupUpdate} request group model update: id, name, category, description
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function update_group_model(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupUpdate = new pb_group.GroupUpdate();
    groupUpdate.setId(uuid_hex_to_base64(request.id));
    groupUpdate.setName(request.name);
    groupUpdate.setCategory(request.category);
    groupUpdate.setDescription(request.description);
    await client.updateGroupModel(groupUpdate, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Delete a group model
 * @param {ServerConfig} server Server configuration
 * @param {GroupId} request group model uuid: id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_group_model(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupId = new pb_group.GroupId();
    groupId.setId(uuid_hex_to_base64(request.id));
    await client.deleteGroupModel(groupId, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Add a member to a group model
 * @param {ServerConfig} server Server configuration
 * @param {GroupModel} request group model member: id, model_id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function add_group_model_member(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupModel = new pb_group.GroupModel();
    groupModel.setId(uuid_hex_to_base64(request.id));
    groupModel.setModelId(uuid_hex_to_base64(request.model_id));
    await client.addGroupModelMember(groupModel, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Remove a member to a group model
 * @param {ServerConfig} server Server configuration
 * @param {GroupModel} request group model member: id, model_id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function remove_group_model_member(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupModel = new pb_group.GroupModel();
    groupModel.setId(uuid_hex_to_base64(request.id));
    groupModel.setModelId(uuid_hex_to_base64(request.model_id));
    await client.removeGroupModelMember(groupModel, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Read a group device by uuid
 * @param {ServerConfig} server Server configuration
 * @param {GroupId} request group device uuid: id
 * @param {function(?grpc.web.RpcError, ?GroupDeviceSchema)} callback The callback function(error, response)
 */
async function read_group_device(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupId = new pb_group.GroupId();
    groupId.setId(uuid_hex_to_base64(request.id));
    await client.readGroupDevice(groupId, metadata(server), (e, r) => {
        const response = r ? get_group_device_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read groups of device by name
 * @param {ServerConfig} server Server configuration
 * @param {GroupName} request group device name: name
 * @param {function(?grpc.web.RpcError, ?GroupDeviceSchema[])} callback The callback function(error, response)
 */
async function list_group_device_by_name(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupName = new pb_group.GroupName();
    groupName.setName(request.name);
    await client.listGroupDeviceByName(groupName, metadata(server), (e, r) => {
        const response = r ? get_group_device_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read groups of device by category
 * @param {ServerConfig} server Server configuration
 * @param {GroupCategory} request group device category: category
 * @param {function(?grpc.web.RpcError, ?GroupDeviceSchema[])} callback The callback function(error, response)
 */
async function list_group_device_by_category(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupCategory = new pb_group.GroupCategory();
    groupCategory.setCategory(request.category);
    await client.listGroupDeviceByCategory(groupCategory, metadata(server), (e, r) => {
        const response = r ? get_group_device_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read groups of device by name and category
 * @param {ServerConfig} server Server configuration
 * @param {GroupNameCategory} request group device name and category: name, category
 * @param {function(?grpc.web.RpcError, ?GroupDeviceSchema[])} callback The callback function(error, response)
 */
async function list_group_device_by_name_category(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupNameCategory = new pb_group.GroupNameCategory();
    groupNameCategory.setName(request.name);
    groupNameCategory.setCategory(request.category);
    await client.listGroupDeviceByNameCategory(groupNameCategory, metadata(server), (e, r) => {
        const response = r ? get_group_device_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Create a group device
 * @param {ServerConfig} server Server configuration
 * @param {GroupDeviceSchema} request group device schema: id, name, category, description
 * @param {function(?grpc.web.RpcError, ?GroupId)} callback The callback function(error, response)
 */
async function create_group_device(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupSchema = new pb_group.GroupDeviceSchema();
    groupSchema.setId(uuid_hex_to_base64(request.id));
    groupSchema.setName(request.name);
    groupSchema.setCategory(request.category);
    groupSchema.setDescription(request.description);
    await client.createGroupDevice(groupSchema, metadata(server), (e, r) => {
        const response = r ? get_group_id(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * Update a group device
 * @param {ServerConfig} server Server configuration
 * @param {GroupUpdate} request group device update: id, name, category, description
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function update_group_device(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupUpdate = new pb_group.GroupUpdate();
    groupUpdate.setId(uuid_hex_to_base64(request.id));
    groupUpdate.setName(request.name);
    groupUpdate.setCategory(request.category);
    groupUpdate.setDescription(request.description);
    await client.updateGroupDevice(groupUpdate, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Delete a group device
 * @param {ServerConfig} server Server configuration
 * @param {GroupId} request group device uuid: id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_group_device(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupId = new pb_group.GroupId();
    groupId.setId(uuid_hex_to_base64(request.id));
    await client.deleteGroupDevice(groupId, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Add a member to a group device
 * @param {ServerConfig} server Server configuration
 * @param {GroupDevice} request group device member: id, device_id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function add_group_device_member(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupDevice = new pb_group.GroupDevice();
    groupDevice.setId(uuid_hex_to_base64(request.id));
    groupDevice.setDeviceId(uuid_hex_to_base64(request.device_id));
    await client.addGroupDeviceMember(groupDevice, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Remove a member to a group device
 * @param {ServerConfig} server Server configuration
 * @param {GroupDevice} request group device member: id, device_id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function remove_group_device_member(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupDevice = new pb_group.GroupDevice();
    groupDevice.setId(uuid_hex_to_base64(request.id));
    groupDevice.setDeviceId(uuid_hex_to_base64(request.device_id));
    await client.removeGroupDeviceMember(groupDevice, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Read a group gateway by uuid
 * @param {ServerConfig} server Server configuration
 * @param {GroupId} request group gateway uuid: id
 * @param {function(?grpc.web.RpcError, ?GroupGatewaySchema)} callback The callback function(error, response)
 */
async function read_group_gateway(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupId = new pb_group.GroupId();
    groupId.setId(uuid_hex_to_base64(request.id));
    await client.readGroupGateway(groupId, metadata(server), (e, r) => {
        const response = r ? get_group_gateway_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read groups of gateway by name
 * @param {ServerConfig} server Server configuration
 * @param {GroupName} request group gateway name: name
 * @param {function(?grpc.web.RpcError, ?GroupGatewaySchema[])} callback The callback function(error, response)
 */
async function list_group_gateway_by_name(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupName = new pb_group.GroupName();
    groupName.setName(request.name);
    await client.listGroupGatewayByName(groupName, metadata(server), (e, r) => {
        const response = r ? get_group_gateway_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read groups of gateway by category
 * @param {ServerConfig} server Server configuration
 * @param {GroupCategory} request group gateway category: category
 * @param {function(?grpc.web.RpcError, ?GroupGatewaySchema[])} callback The callback function(error, response)
 */
async function list_group_gateway_by_category(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupCategory = new pb_group.GroupCategory();
    groupCategory.setCategory(request.category);
    await client.listGroupGatewayByCategory(groupCategory, metadata(server), (e, r) => {
        const response = r ? get_group_gateway_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read groups of gateway by name and category
 * @param {ServerConfig} server Server configuration
 * @param {GroupNameCategory} request group gateway name and category: name, category
 * @param {function(?grpc.web.RpcError, ?GroupGatewaySchema[])} callback The callback function(error, response)
 */
async function list_group_gateway_by_name_category(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupNameCategory = new pb_group.GroupNameCategory();
    groupNameCategory.setName(request.name);
    groupNameCategory.setCategory(request.category);
    await client.listGroupGatewayByNameCategory(groupNameCategory, metadata(server), (e, r) => {
        const response = r ? get_group_gateway_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Create a group gateway
 * @param {ServerConfig} server Server configuration
 * @param {GroupGatewaySchema} request group gateway schema: id, name, category, description
 * @param {function(?grpc.web.RpcError, ?GroupId)} callback The callback function(error, response)
 */
async function create_group_gateway(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupSchema = new pb_group.GroupDeviceSchema();
    groupSchema.setId(uuid_hex_to_base64(request.id));
    groupSchema.setName(request.name);
    groupSchema.setCategory(request.category);
    groupSchema.setDescription(request.description);
    await client.createGroupGateway(groupSchema, metadata(server), (e, r) => {
        const response = r ? get_group_id(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * Update a group gateway
 * @param {ServerConfig} server Server configuration
 * @param {GroupUpdate} request group gateway update: id, name, category, description
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function update_group_gateway(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupUpdate = new pb_group.GroupUpdate();
    groupUpdate.setId(uuid_hex_to_base64(request.id));
    groupUpdate.setName(request.name);
    groupUpdate.setCategory(request.category);
    groupUpdate.setDescription(request.description);
    await client.updateGroupGateway(groupUpdate, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Delete a group gateway
 * @param {ServerConfig} server Server configuration
 * @param {GroupId} request group gateway uuid: id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_group_gateway(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupId = new pb_group.GroupId();
    groupId.setId(uuid_hex_to_base64(request.id));
    await client.deleteGroupGateway(groupId, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Add a member to a group gateway
 * @param {ServerConfig} server Server configuration
 * @param {GroupGateway} request group gateway member: id, gateway_id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function add_group_gateway_member(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupDevice = new pb_group.GroupDevice();
    groupDevice.setId(uuid_hex_to_base64(request.id));
    groupDevice.setDeviceId(uuid_hex_to_base64(request.gateway_id));
    await client.addGroupGatewayMember(groupDevice, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Remove a member to a group gateway
 * @param {ServerConfig} server Server configuration
 * @param {GroupGateway} request group gateway member: id, gateway_id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function remove_group_gateway_member(server, request, callback) {
    const client = new pb_group.GroupServiceClient(server.address, null, null);
    const groupDevice = new pb_group.GroupDevice();
    groupDevice.setId(uuid_hex_to_base64(request.id));
    groupDevice.setDeviceId(uuid_hex_to_base64(request.gateway_id));
    await client.removeGroupGatewayMember(groupDevice, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} DataId
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 * @property {Date} timestamp
 */

/**
 * @typedef {Object} DataTime
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 * @property {Date} timestamp
 */

/**
 * @typedef {Object} DataRange
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 * @property {Date} begin
 * @property {Date} end
 */

/**
 * @typedef {Object} DataNumber
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 * @property {Date} timestamp
 * @property {number} number
 */

/**
 * @typedef {Object} DataSchema
 * @property {Uuid} model_id
 * @property {Uuid} device_id
 * @property {Date} timestamp
 * @property {(number|bigint|string|boolean)[]} data
 */

/**
 * @param {*} r 
 * @returns {DataSchema}
 */
function get_data_schema(r) {
    return {
        device_id: base64_to_uuid_hex(r.deviceId),
        model_id: base64_to_uuid_hex(r.modelId),
        timestamp: new Date(r.timestamp / 1000),
        data: get_data_value(r.dataBytes, r.dataTypeList)
    };
}

/**
 * @param {*} r 
 * @returns {DataSchema[]}
 */
function get_data_schema_vec(r) {
    return r.map((v) => {return get_data_schema(v)});
}


/**
 * Read a data by id
 * @param {ServerConfig} server Server configuration
 * @param {DataId} request data id: device_id, model_id, timestamp
 * @param {function(?grpc.web.RpcError, ?DataSchema)} callback The callback function(error, response)
 */
async function read_data(server, request, callback) {
    const client = new pb_data.DataServiceClient(server.address, null, null);
    const dataId = new pb_data.DataId();
    dataId.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataId.setModelId(uuid_hex_to_base64(request.model_id));
    dataId.setTimestamp(request.timestamp.valueOf() * 1000);
    await client.readData(dataId, metadata(server), (e, r) => {
        const response = r ? get_data_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read multiple data by specific time
 * @param {ServerConfig} server Server configuration
 * @param {DataTime} request data time: device_id, model_id, timestamp
 * @param {function(?grpc.web.RpcError, ?DataSchema[])} callback The callback function(error, response)
 */
async function list_data_by_time(server, request, callback) {
    const client = new pb_data.DataServiceClient(server.address, null, null);
    const dataTime = new pb_data.DataTime();
    dataTime.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataTime.setModelId(uuid_hex_to_base64(request.model_id));
    dataTime.setTimestamp(request.timestamp.valueOf() * 1000);
    await client.listDataByTime(dataTime, metadata(server), (e, r) => {
        const response = r ? get_data_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read multiple data by last time
 * @param {ServerConfig} server Server configuration
 * @param {DataTime} request data time: device_id, model_id, timestamp
 * @param {function(?grpc.web.RpcError, ?DataSchema[])} callback The callback function(error, response)
 */
async function list_data_by_last_time(server, request, callback) {
    const client = new pb_data.DataServiceClient(server.address, null, null);
    const dataTime = new pb_data.DataTime();
    dataTime.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataTime.setModelId(uuid_hex_to_base64(request.model_id));
    dataTime.setTimestamp(request.timestamp.valueOf() * 1000);
    await client.listDataByLastTime(dataTime, metadata(server), (e, r) => {
        const response = r ? get_data_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read multiple data by range time
 * @param {ServerConfig} server Server configuration
 * @param {DataRange} request data range: device_id, model_id, begin, end
 * @param {function(?grpc.web.RpcError, ?DataSchema[])} callback The callback function(error, response)
 */
async function list_data_by_range_time(server, request, callback) {
    const client = new pb_data.DataServiceClient(server.address, null, null);
    const dataRange = new pb_data.DataRange();
    dataRange.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataRange.setModelId(uuid_hex_to_base64(request.model_id));
    dataRange.setBegin(request.begin.valueOf() * 1000);
    dataRange.setEnd(request.end.valueOf() * 1000);
    await client.listDataByRangeTime(dataRange, metadata(server), (e, r) => {
        const response = r ? get_data_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read multiple data by specific time and number before
 * @param {ServerConfig} server Server configuration
 * @param {DataNumber} request data time and number: device_id, model_id, timestamp, number
 * @param {function(?grpc.web.RpcError, ?DataSchema[])} callback The callback function(error, response)
 */
async function list_data_by_number_before(server, request, callback) {
    const client = new pb_data.DataServiceClient(server.address, null, null);
    const dataNumber = new pb_data.DataNumber();
    dataNumber.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataNumber.setModelId(uuid_hex_to_base64(request.model_id));
    dataNumber.setTimestamp(request.timestamp.valueOf() * 1000);
    dataNumber.setNumber(request.number);
    await client.listDataByNumberBefore(dataNumber, metadata(server), (e, r) => {
        const response = r ? get_data_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read multiple data by specific time and number after
 * @param {ServerConfig} server Server configuration
 * @param {DataNumber} request data time and number: device_id, model_id, timestamp, number
 * @param {function(?grpc.web.RpcError, ?DataSchema[])} callback The callback function(error, response)
 */
async function list_data_by_number_after(server, request, callback) {
    const client = new pb_data.DataServiceClient(server.address, null, null);
    const dataNumber = new pb_data.DataNumber();
    dataNumber.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataNumber.setModelId(uuid_hex_to_base64(request.model_id));
    dataNumber.setTimestamp(request.timestamp.valueOf() * 1000);
    dataNumber.setNumber(request.number);
    await client.listDataByNumberAfter(dataNumber, metadata(server), (e, r) => {
        const response = r ? get_data_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Create a data
 * @param {ServerConfig} server Server configuration
 * @param {DataSchema} request data schema: device_id, model_id, timestamp, data
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function create_data(server, request, callback) {
    const client = new pb_data.DataServiceClient(server.address, null, null);
    const dataSchema = new pb_data.DataSchema();
    dataSchema.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataSchema.setModelId(uuid_hex_to_base64(request.model_id));
    dataSchema.setTimestamp(request.timestamp.valueOf() * 1000);
    const value = set_data_value(request.data);
    dataSchema.setDataBytes(value.bytes);
    for (const type of value.types) {
        dataSchema.addDataType(type);
    }
    await client.createData(dataSchema, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Delete a data
 * @param {ServerConfig} server Server configuration
 * @param {DataId} request data id: device_id, model_id, timestamp
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_data(server, request, callback) {
    const client = new pb_data.DataServiceClient(server.address, null, null);
    const dataId = new pb_data.DataId();
    dataId.setDeviceId(uuid_hex_to_base64(request.device_id));
    dataId.setModelId(uuid_hex_to_base64(request.model_id));
    dataId.setTimestamp(request.timestamp.valueOf() * 1000);
    await client.deleteData(dataId, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} BufferId
 * @property {number} id
 */

/**
 * @param {*} r 
 * @returns {BufferId}
 */
function get_buffer_id(r) {
    return {
        id: r.id
    };
}

/**
 * @typedef {Object} BufferTime
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 * @property {Date} timestamp
 * @property {?number|string} status
 */

/**
 * @typedef {Object} BufferSelector
 * @property {?Uuid} device_id
 * @property {?Uuid} model_id
 * @property {?number|string} status
 */

/**
 * @typedef {Object} BuffersSelector
 * @property {?Uuid} device_id
 * @property {?Uuid} model_id
 * @property {?number|string} status
 * @property {number} number
 */

/**
 * @typedef {Object} BufferSchema
 * @property {number} id
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 * @property {Date} timestamp
 * @property {(number|bigint|string|boolean)[]} data
 * @property {number|string} status
 */

/**
 * @param {*} r 
 * @returns {BufferSchema}
 */
function get_buffer_schema(r) {
    return {
        id: r.id,
        device_id: base64_to_uuid_hex(r.deviceId),
        model_id: base64_to_uuid_hex(r.modelId),
        timestamp: new Date(r.timestamp / 1000),
        data: get_data_value(r.dataBytes, r.dataTypeList),
        status: get_buffer_status(r.status)
    };
}

/**
 * @param {*} r 
 * @returns {BufferSchema[]}
 */
function get_buffer_schema_vec(r) {
    return r.map((v) => {return get_buffer_schema(v)});
}

/**
 * @typedef {Object} BufferUpdate
 * @property {number} id
 * @property {?number|bigint|string|boolean} data
 * @property {?number|string} status
 */

/**
 * @param {number} status 
 * @returns {number|string}
 */
function get_buffer_status(status) {
    switch (status) {
        case 0: return "DEFAULT";
        case 1: return "ERROR";
        case 2: return "DELETE";
        case 3: return "HOLD";
        case 4: return "SEND_UPLINK";
        case 5: return "SEND_DOWNLINK";
        case 6: return "TRANSFER_LOCAL";
        case 7: return "TRANSFER_GATEWAY";
        case 8: return "TRANSFER_SERVER";
        case 9: return "BACKUP";
        case 10: return "RESTORE";
        case 11: return "ANALYSIS_1";
        case 12: return "ANALYSIS_2";
        case 13: return "ANALYSIS_3";
        case 14: return "ANALYSIS_4";
        case 15: return "ANALYSIS_5";
        case 16: return "ANALYSIS_6";
        case 17: return "ANALYSIS_7";
        case 18: return "ANALYSIS_8";
        case 19: return "ANALYSIS_9";
        case 20: return "ANALYSIS_10";
        case 21: return "EXTERNAL_OUTPUT";
        case 22: return "EXTERNAL_INPUT";
    }
    return status;
}

/**
 * @param {number|string} status 
 * @returns {number}
 */
function set_buffer_status(status) {
    if (typeof status == "number") {
        return status;
    }
    if (typeof status == "string") {
        status = status.replace(/[a-z][A-Z]/, s => `${s.charAt(0)}_${s.charAt(1)}`);
        switch (status.toUpperCase()) {
            case "DEFAULT": return 0;
            case "ERROR": return 1;
            case "DELETE": return 2;
            case "HOLD": return 3;
            case "SEND_UPLINK": return 4;
            case "SEND_DOWNLINK": return 5;
            case "TRANSFER_LOCAL": return 6;
            case "TRANSFER_GATEWAY": return 7;
            case "TRANSFER_SERVER": return 8;
            case "BACKUP": return 9;
            case "RESTORE": return 10;
            case "ANALYSIS_1": return 11;
            case "ANALYSIS_2": return 12;
            case "ANALYSIS_3": return 13;
            case "ANALYSIS_4": return 14;
            case "ANALYSIS_5": return 15;
            case "ANALYSIS_6": return 16;
            case "ANALYSIS_7": return 17;
            case "ANALYSIS_8": return 18;
            case "ANALYSIS_9": return 19;
            case "ANALYSIS_10": return 20;
            case "EXTERNAL_INPUT": return 21;
            case "EXTERNAL_OUTPUT": return 22;
        }
    }
    return 0;
}


/**
 * Read a data buffer by id
 * @param {ServerConfig} server Server configuration
 * @param {BufferId} request data buffer id: id
 * @param {function(?grpc.web.RpcError, ?BufferSchema)} callback The callback function(error, response)
 */
async function read_buffer(server, request, callback) {
    const client = new pb_buffer.BufferServiceClient(server.address, null, null);
    const bufferId = new pb_buffer.BufferId();
    bufferId.setId(request.id);
    await client.readBuffer(bufferId, metadata(server), (e, r) => {
        const response = r ? get_buffer_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read a data buffer by time
 * @param {ServerConfig} server Server configuration
 * @param {BufferTime} request data buffer time: device_id, model_id, timestamp, status
 * @param {function(?grpc.web.RpcError, ?BufferSchema)} callback The callback function(error, response)
 */
async function read_buffer_by_time(server, request, callback) {
    const client = new pb_buffer.BufferServiceClient(server.address, null, null);
    const bufferTime = new pb_buffer.BufferTime();
    bufferTime.setDeviceId(uuid_hex_to_base64(request.device_id));
    bufferTime.setModelId(uuid_hex_to_base64(request.model_id));
    bufferTime.setTimestamp(request.timestamp.valueOf() * 1000);
    bufferTime.setStatus(set_buffer_status(request.status));
    await client.readBufferByTime(bufferTime, metadata(server), (e, r) => {
        const response = r ? get_buffer_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read first of a data buffer
 * @param {ServerConfig} server Server configuration
 * @param {BufferSelector} request data buffer selector: device_id, model_id, status
 * @param {function(?grpc.web.RpcError, ?BufferSchema)} callback The callback function(error, response)
 */
async function read_buffer_first(server, request, callback) {
    const client = new pb_buffer.BufferServiceClient(server.address, null, null);
    const bufferSelector = new pb_buffer.BufferSelector();
    if (request.device_id) {
        bufferSelector.setDeviceId(uuid_hex_to_base64(request.device_id));
    }
    if (request.model_id) {
        bufferSelector.setModelId(uuid_hex_to_base64(request.model_id));
    }
    if (typeof request.status == "number" || typeof request.status == "string") {
        bufferSelector.setStatus(set_buffer_status(request.status));
    }
    await client.readBufferFirst(bufferSelector, metadata(server), (e, r) => {
        const response = r ? get_buffer_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read last of a data buffer
 * @param {ServerConfig} server Server configuration
 * @param {BufferSelector} request data buffer selector: device_id, model_id, status
 * @param {function(?grpc.web.RpcError, ?BufferSchema)} callback The callback function(error, response)
 */
async function read_buffer_last(server, request, callback) {
    const client = new pb_buffer.BufferServiceClient(server.address, null, null);
    const bufferSelector = new pb_buffer.BufferSelector();
    if (request.device_id) {
        bufferSelector.setDeviceId(uuid_hex_to_base64(request.device_id));
    }
    if (request.model_id) {
        bufferSelector.setModelId(uuid_hex_to_base64(request.model_id));
    }
    if (typeof request.status == "number" || typeof request.status == "string") {
        bufferSelector.setStatus(set_buffer_status(request.status));
    }
    await client.readBufferLast(bufferSelector, metadata(server), (e, r) => {
        const response = r ? get_buffer_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read first of data buffers
 * @param {ServerConfig} server Server configuration
 * @param {BuffersSelector} request data buffer selector: device_id, model_id, status, number
 * @param {function(?grpc.web.RpcError, ?BufferSchema[])} callback The callback function(error, response)
 */
async function list_buffer_first(server, request, callback) {
    const client = new pb_buffer.BufferServiceClient(server.address, null, null);
    const buffersSelector = new pb_buffer.BuffersSelector();
    if (request.device_id) {
        buffersSelector.setDeviceId(uuid_hex_to_base64(request.device_id));
    }
    if (request.model_id) {
        buffersSelector.setModelId(uuid_hex_to_base64(request.model_id));
    }
    if (typeof request.status == "number" || typeof request.status == "string") {
        buffersSelector.setStatus(set_buffer_status(request.status));
    }
    buffersSelector.setNumber(request.number);
    await client.listBufferFirst(buffersSelector, metadata(server), (e, r) => {
        const response = r ? get_buffer_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read last of data buffers
 * @param {ServerConfig} server Server configuration
 * @param {BuffersSelector} request data buffer selector: device_id, model_id, status, number
 * @param {function(?grpc.web.RpcError, ?BufferSchema[])} callback The callback function(error, response)
 */
async function list_buffer_last(server, request, callback) {
    const client = new pb_buffer.BufferServiceClient(server.address, null, null);
    const buffersSelector = new pb_buffer.BuffersSelector();
    if (request.device_id) {
        buffersSelector.setDeviceId(uuid_hex_to_base64(request.device_id));
    }
    if (request.model_id) {
        buffersSelector.setModelId(uuid_hex_to_base64(request.model_id));
    }
    if (typeof request.status == "number" || typeof request.status == "string") {
        buffersSelector.setStatus(set_buffer_status(request.status));
    }
    buffersSelector.setNumber(request.number);
    await client.listBufferLast(buffersSelector, metadata(server), (e, r) => {
        const response = r ? get_buffer_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Create a data buffer
 * @param {ServerConfig} server Server configuration
 * @param {BufferSchema} request data buffer schema: device_id, model_id, timestamp, data, status
 * @param {function(?grpc.web.RpcError, ?BufferId)} callback The callback function(error, response)
 */
async function create_buffer(server, request, callback) {
    const client = new pb_buffer.BufferServiceClient(server.address, null, null);
    const bufferSchema = new pb_buffer.BufferSchema();
    bufferSchema.setDeviceId(uuid_hex_to_base64(request.device_id));
    bufferSchema.setModelId(uuid_hex_to_base64(request.model_id));
    bufferSchema.setTimestamp(request.timestamp.valueOf() * 1000);
    const value = set_data_value(request.data);
    bufferSchema.setDataBytes(value.bytes);
    for (const type of value.types) {
        bufferSchema.addDataType(type);
    }
    bufferSchema.setStatus(set_buffer_status(request.status));
    await client.createBuffer(bufferSchema, metadata(server), (e, r) => {
        const response = r ? get_buffer_id(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * Update a data buffer
 * @param {ServerConfig} server Server configuration
 * @param {BufferUpdate} request data buffer update: id, data, status
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function update_buffer(server, request, callback) {
    const client = new pb_buffer.BufferServiceClient(server.address, null, null);
    const bufferUpdate = new pb_buffer.BufferUpdate();
    bufferUpdate.setId(request.id);
    const ty = typeof request.data;
    if (ty == "number" || ty == "string" || ty == "bigint" || ty == "boolean") {
        const value = set_data_value(request.data);
        bufferUpdate.setDataBytes(value.bytes);
        for (const type of value.types) {
            bufferUpdate.addDataType(type);
        }
    }
    bufferUpdate.setStatus(set_buffer_status(request.status));
    await client.updateBuffer(bufferUpdate, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Delete a data buffer
 * @param {ServerConfig} server Server configuration
 * @param {BufferId} request data buffer id: id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_buffer(server, request, callback) {
    const client = new pb_buffer.BufferServiceClient(server.address, null, null);
    const bufferId = new pb_buffer.BufferId();
    bufferId.setId(request.id);
    await client.deleteBuffer(bufferId, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} SliceId
 * @property {number} id
 */

/**
 * @param {*} r 
 * @returns {SliceId}
 */
function get_slice_id(r) {
    return {
        id: r.id    
    };
}

/**
 * @typedef {Object} SliceName
 * @property {string} name
 */

/**
 * @typedef {Object} SliceDevice
 * @property {Uuid} device_id
 */

/**
 * @typedef {Object} SliceModel
 * @property {Uuid} model_id
 */

/**
 * @typedef {Object} SliceDeviceModel
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 */

/**
 * @typedef {Object} SliceSchema
 * @property {number} id
 * @property {Uuid} device_id
 * @property {Uuid} model_id
 * @property {Date} timestamp_begin
 * @property {Date} timestamp_end
 * @property {string} name
 * @property {string} description
 */

/**
 * @param {*} r 
 * @returns {SliceSchema}
 */
function get_slice_schema(r) {
    return {
        id: r.id,
        device_id: base64_to_uuid_hex(r.deviceId),
        model_id: base64_to_uuid_hex(r.modelId),
        timestamp_begin: new Date(r.timestampBegin / 1000),
        timestamp_end: new Date(r.timestampEnd / 1000),
        name: r.name,
        description: r.description
    };
}

/**
 * @param {*} r 
 * @returns {SliceSchema[]}
 */
function get_slice_schema_vec(r) {
    return r.map((v) => {return get_slice_schema(v)});
}

/**
 * @typedef {Object} SliceUpdate
 * @property {number} id
 * @property {?Date} timestamp_begin
 * @property {?Date} timestamp_end
 * @property {?string} name
 * @property {?string} description
 */


/**
 * Read a data slice by id
 * @param {ServerConfig} server Server configuration
 * @param {SliceId} request data slice id: id
 * @param {function(?grpc.web.RpcError, ?SliceSchema)} callback The callback function(error, response)
 */
async function read_slice(server, request, callback) {
    const client = new pb_slice.SliceServiceClient(server.address, null, null);
    const sliceId = new pb_slice.SliceId();
    sliceId.setId(request.id);
    await client.readSlice(sliceId, metadata(server), (e, r) => {
        const response = r ? get_slice_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read data slices by name
 * @param {ServerConfig} server Server configuration
 * @param {SliceName} request data slice name: name
 * @param {function(?grpc.web.RpcError, ?SliceSchema[])} callback The callback function(error, response)
 */
async function list_slice_by_name(server, request, callback) {
    const client = new pb_slice.SliceServiceClient(server.address, null, null);
    const sliceName = new pb_slice.SliceName();
    sliceName.setName(request.name);
    await client.listSliceByName(sliceName, metadata(server), (e, r) => {
        const response = r ? get_slice_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read data slices by device
 * @param {ServerConfig} server Server configuration
 * @param {SliceDevice} request data slice device: device_id
 * @param {function(?grpc.web.RpcError, ?SliceSchema[])} callback The callback function(error, response)
 */
async function list_slice_by_device(server, request, callback) {
    const client = new pb_slice.SliceServiceClient(server.address, null, null);
    const sliceDevice = new pb_slice.SliceDevice();
    sliceDevice.setDeviceId(uuid_hex_to_base64(request.device_id));
    await client.listSliceByDevice(sliceDevice, metadata(server), (e, r) => {
        const response = r ? get_slice_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read data slices by model
 * @param {ServerConfig} server Server configuration
 * @param {SliceModel} request data slice model: model_id
 * @param {function(?grpc.web.RpcError, ?SliceSchema[])} callback The callback function(error, response)
 */
async function list_slice_by_model(server, request, callback) {
    const client = new pb_slice.SliceServiceClient(server.address, null, null);
    const sliceModel = new pb_slice.SliceModel();
    sliceModel.setModelId(uuid_hex_to_base64(request.model_id));
    await client.listSliceByModel(sliceModel, metadata(server), (e, r) => {
        const response = r ? get_slice_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read data slices by device and model
 * @param {ServerConfig} server Server configuration
 * @param {SliceDeviceModel} request data slice device and model: device_id, model_id
 * @param {function(?grpc.web.RpcError, ?SliceSchema[])} callback The callback function(error, response)
 */
async function list_slice_by_device_model(server, request, callback) {
    const client = new pb_slice.SliceServiceClient(server.address, null, null);
    const sliceDeviceModel = new pb_slice.SliceDeviceModel();
    sliceDeviceModel.setDeviceId(uuid_hex_to_base64(request.device_id));
    sliceDeviceModel.setModelId(uuid_hex_to_base64(request.model_id));
    await client.listSliceByDeviceModel(sliceDeviceModel, metadata(server), (e, r) => {
        const response = r ? get_slice_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Create a data slice
 * @param {ServerConfig} server Server configuration
 * @param {SliceSchema} request data slice schema: device_id, model_id, timestamp_begin, timestamp_end, name, description
 * @param {function(?grpc.web.RpcError, ?SliceId)} callback The callback function(error, response)
 */
async function create_slice(server, request, callback) {
    const client = new pb_slice.SliceServiceClient(server.address, null, null);
    const sliceSchema = new pb_slice.SliceSchema();
    sliceSchema.setDeviceId(uuid_hex_to_base64(request.device_id));
    sliceSchema.setModelId(uuid_hex_to_base64(request.model_id));
    sliceSchema.setTimestampBegin(request.timestamp_begin.valueOf() * 1000);
    sliceSchema.setTimestampEnd(request.timestamp_end.valueOf() * 1000);
    sliceSchema.setName(request.name);
    sliceSchema.setDescription(request.description);
    await client.createSlice(sliceSchema, metadata(server), (e, r) => {
        const response = r ? get_slice_id(r.toObject()) : null;
        callback(e, response);
    });
}

/**
 * Update a data slice
 * @param {ServerConfig} server Server configuration
 * @param {SliceUpdate} request data slice update: id, timestamp_begin, timestamp_end, name, description
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function update_slice(server, request, callback) {
    const client = new pb_slice.SliceServiceClient(server.address, null, null);
    const sliceUpdate = new pb_slice.SliceUpdate();
    sliceUpdate.setId(request.id);
    if (request.timestamp_begin instanceof Date) {
        sliceUpdate.setTimestampBegin(request.timestamp_begin.valueOf() * 1000);
    }
    if (request.timestamp_end instanceof Date) {
        sliceUpdate.setTimestampEnd(request.timestamp_end.valueOf() * 1000);
    }
    sliceUpdate.setName(request.name);
    sliceUpdate.setDescription(request.description);
    await client.updateSlice(sliceUpdate, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Delete a data slice
 * @param {ServerConfig} server Server configuration
 * @param {SliceId} request data slice id: id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_slice(server, request, callback) {
    const client = new pb_slice.SliceServiceClient(server.address, null, null);
    const sliceId = new pb_slice.SliceId();
    sliceId.setId(request.id);
    await client.deleteSlice(sliceId, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * @typedef {(string|Uint8Array)} Uuid
 */

/**
 * @typedef {Object} ServerConfig
 * @property {string} address
 * @property {?string} token
 */

/**
 * @typedef {Object} LogId
 * @property {Date} timestamp
 * @property {Uuid} device_id
 */

/**
 * @typedef {Object} LogTime
 * @property {Date} timestamp
 * @property {?Uuid} device_id
 * @property {?number|string} status
 */

/**
 * @typedef {Object} LogRange
 * @property {Date} begin
 * @property {Date} end
 * @property {?Uuid} device_id
 * @property {?number|string} status
 */

/**
 * @typedef {Object} LogSchema
 * @property {Date} timestamp
 * @property {Uuid} device_id
 * @property {number|string} status
 * @property {number|string} value
 */

/**
 * @param {*} r 
 * @returns {LogSchema}
 */
function get_log_schema(r) {
    return {
        timestamp: new Date(r.timestamp / 1000),
        device_id: base64_to_uuid_hex(r.deviceId),
        status: get_log_status(r.status),
        value: get_config_value(r.logBytes, r.logType)
    };
}

/**
 * @param {*} r 
 * @returns {LogSchema[]}
 */
function get_log_schema_vec(r) {
    return r.map((v) => {return get_log_schema(v)});
}

/**
 * @typedef {Object} LogUpdate
 * @property {Date} timestamp
 * @property {Uuid} device_id
 * @property {?number|string} status
 * @property {?number|string} value
 */

/**
 * @param {number} status 
 * @returns {number|string}
 */
function get_log_status(status) {
    switch (status) {
        case 0: return "DEFAULT";
        case 1: return "SUCCESS";
        case 2: return "ERROR_SEND";
        case 3: return "ERROR_TRANSFER";
        case 4: return "ERROR_ANALYSIS";
        case 5: return "ERROR_NETWORK";
        case 6: return "FAIL_READ";
        case 7: return "FAIL_CREATE";
        case 8: return "FAIL_UPDATE";
        case 9: return "FAIL_DELETE";
        case 10: return "INVALID_TOKEN";
        case 11: return "INVALID_REQUEST";
        case 12: return "UNKNOWN_ERROR";
        case 13: return "UNKNOWN_STATUS";
    }
    return status;
}

/**
 * @param {number|string} status 
 * @returns {number}
 */
function set_log_status(status) {
    if (typeof status == "number") {
        return status;
    }
    if (typeof status == "string") {
        status = status.replace(/[a-z][A-Z]/, s => `${s.charAt(0)}_${s.charAt(1)}`);
        switch (status.toUpperCase()) {
            case "DEFAULT": return 0;
            case "SUCCESS": return 1;
            case "ERROR_SEND": return 2;
            case "ERROR_TRANSFER": return 3;
            case "ERROR_ANALYSIS": return 4;
            case "ERROR_NETWORK": return 5;
            case "FAIL_READ": return 6;
            case "FAIL_CREATE": return 7;
            case "FAIL_UPDATE": return 8;
            case "FAIL_DELETE": return 9;
            case "INVALID_TOKEN": return 10;
            case "INVALID_REQUEST": return 11;
            case "UNKNOWN_ERROR": return 12;
            case "UNKNOWN_STATUS": return 13;
        }
    }
    return 0;
}


/**
 * Read a system log by id
 * @param {ServerConfig} server Server configuration
 * @param {LogId} request system log id: timestamp, device_id
 * @param {function(?grpc.web.RpcError, ?LogSchema)} callback The callback function(error, response)
 */
async function read_log(server, request, callback) {
    const client = new pb_log.LogServiceClient(server.address, null, null);
    const logId = new pb_log.LogId();
    logId.setTimestamp(request.timestamp.valueOf() * 1000);
    logId.setDeviceId(uuid_hex_to_base64(request.device_id));
    await client.readLog(logId, metadata(server), (e, r) => {
        const response = r ? get_log_schema(r.toObject().result) : null;
        callback(e, response);
    });
}

/**
 * Read system logs by time
 * @param {ServerConfig} server Server configuration
 * @param {LogTime} request system log time: timestamp, device_id, status
 * @param {function(?grpc.web.RpcError, ?LogSchema[])} callback The callback function(error, response)
 */
async function list_log_by_time(server, request, callback) {
    const client = new pb_log.LogServiceClient(server.address, null, null);
    const logTime = new pb_log.LogTime();
    logTime.setTimestamp(request.timestamp.valueOf() * 1000);
    if (request.device_id) {
        logTime.setDeviceId(uuid_hex_to_base64(request.device_id));
    }
    if (typeof request.status == "number" || typeof request.status == "string") {
        logTime.setStatus(request.status);
    }
    await client.listLogByTime(logTime, metadata(server), (e, r) => {
        const response = r ? get_log_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read system logs by last time
 * @param {ServerConfig} server Server configuration
 * @param {LogTime} request system log last time: timestamp, device_id, status
 * @param {function(?grpc.web.RpcError, ?LogSchema[])} callback The callback function(error, response)
 */
async function list_log_by_last_time(server, request, callback) {
    const client = new pb_log.LogServiceClient(server.address, null, null);
    const logTime = new pb_log.LogTime();
    logTime.setTimestamp(request.timestamp.valueOf() * 1000);
    if (request.device_id) {
        logTime.setDeviceId(uuid_hex_to_base64(request.device_id));
    }
    if (typeof request.status == "number" || typeof request.status == "string") {
        logTime.setStatus(request.status);
    }
    await client.listLogByLastTime(logTime, metadata(server), (e, r) => {
        const response = r ? get_log_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Read system logs by range time
 * @param {ServerConfig} server Server configuration
 * @param {LogRange} request system log time: begin, end, device_id, status
 * @param {function(?grpc.web.RpcError, ?LogSchema[])} callback The callback function(error, response)
 */
async function list_log_by_range_time(server, request, callback) {
    const client = new pb_log.LogServiceClient(server.address, null, null);
    const logRange = new pb_log.LogRange();
    logRange.setBegin(request.begin.valueOf() * 1000);
    logRange.setEnd(request.end.valueOf() * 1000);
    if (request.device_id) {
        logRange.setDeviceId(uuid_hex_to_base64(request.device_id));
    }
    if (typeof request.status == "number" || typeof request.status == "string") {
        logRange.setStatus(request.status);
    }
    await client.listLogByRangeTime(logRange, metadata(server), (e, r) => {
        const response = r ? get_log_schema_vec(r.toObject().resultsList) : null;
        callback(e, response);
    });
}

/**
 * Create a system log
 * @param {ServerConfig} server Server configuration
 * @param {LogSchema} request system log schema: timestamp, device_id, status, value
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function create_log(server, request, callback) {
    const client = new pb_log.LogServiceClient(server.address, null, null);
    const logSchema = new pb_log.LogSchema();
    logSchema.setTimestamp(request.timestamp.valueOf() * 1000);
    logSchema.setDeviceId(uuid_hex_to_base64(request.device_id));
    logSchema.setStatus(set_log_status(request.status));
    const value = set_config_value(request.value);
    logSchema.setLogBytes(value.bytes);
    logSchema.setLogType(value.type);
    await client.createLog(logSchema, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Update a system log
 * @param {ServerConfig} server Server configuration
 * @param {LogUpdate} request system log id: timestamp, device_id, status, value
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function update_log(server, request, callback) {
    const client = new pb_log.LogServiceClient(server.address, null, null);
    const logUpdate = new pb_log.LogUpdate();
    logUpdate.setTimestamp(request.timestamp.valueOf() * 1000);
    logUpdate.setDeviceId(uuid_hex_to_base64(request.device_id));
    if (typeof request.status == "number" || typeof request.status == "string") {
        logUpdate.setStatus(set_log_status(request.status));
    }
    const value = set_config_value(request.value);
    logUpdate.setLogBytes(value.bytes);
    logUpdate.setLogType(value.type);
    await client.updateLog(logUpdate, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

/**
 * Delete a system log
 * @param {ServerConfig} server Server configuration
 * @param {LogId} request system log id: timestamp, device_id
 * @param {function(?grpc.web.RpcError, ?{})} callback The callback function(error, response)
 */
async function delete_log(server, request, callback) {
    const client = new pb_log.LogServiceClient(server.address, null, null);
    const logId = new pb_log.LogId();
    logId.setTimestamp(request.timestamp.valueOf() * 1000);
    logId.setDeviceId(uuid_hex_to_base64(request.device_id));
    await client.deleteLog(logId, metadata(server), (e, r) => {
        const response = r ? r.toObject() : null;
        callback(e, response);
    });
}

var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    add_group_device_member: add_group_device_member,
    add_group_gateway_member: add_group_gateway_member,
    add_group_model_member: add_group_model_member,
    add_type_model: add_type_model,
    create_buffer: create_buffer,
    create_data: create_data,
    create_device: create_device,
    create_device_config: create_device_config,
    create_gateway: create_gateway,
    create_gateway_config: create_gateway_config,
    create_group_device: create_group_device,
    create_group_gateway: create_group_gateway,
    create_group_model: create_group_model,
    create_log: create_log,
    create_model: create_model,
    create_model_config: create_model_config,
    create_slice: create_slice,
    create_type: create_type,
    delete_buffer: delete_buffer,
    delete_data: delete_data,
    delete_device: delete_device,
    delete_device_config: delete_device_config,
    delete_gateway: delete_gateway,
    delete_gateway_config: delete_gateway_config,
    delete_group_device: delete_group_device,
    delete_group_gateway: delete_group_gateway,
    delete_group_model: delete_group_model,
    delete_log: delete_log,
    delete_model: delete_model,
    delete_model_config: delete_model_config,
    delete_slice: delete_slice,
    delete_type: delete_type,
    list_buffer_first: list_buffer_first,
    list_buffer_last: list_buffer_last,
    list_data_by_last_time: list_data_by_last_time,
    list_data_by_number_after: list_data_by_number_after,
    list_data_by_number_before: list_data_by_number_before,
    list_data_by_range_time: list_data_by_range_time,
    list_data_by_time: list_data_by_time,
    list_device_by_gateway: list_device_by_gateway,
    list_device_by_gateway_name: list_device_by_gateway_name,
    list_device_by_gateway_type: list_device_by_gateway_type,
    list_device_by_name: list_device_by_name,
    list_device_by_type: list_device_by_type,
    list_device_config_by_device: list_device_config_by_device,
    list_gateway_by_name: list_gateway_by_name,
    list_gateway_by_type: list_gateway_by_type,
    list_gateway_config_by_gateway: list_gateway_config_by_gateway,
    list_group_device_by_category: list_group_device_by_category,
    list_group_device_by_name: list_group_device_by_name,
    list_group_device_by_name_category: list_group_device_by_name_category,
    list_group_gateway_by_category: list_group_gateway_by_category,
    list_group_gateway_by_name: list_group_gateway_by_name,
    list_group_gateway_by_name_category: list_group_gateway_by_name_category,
    list_group_model_by_category: list_group_model_by_category,
    list_group_model_by_name: list_group_model_by_name,
    list_group_model_by_name_category: list_group_model_by_name_category,
    list_log_by_last_time: list_log_by_last_time,
    list_log_by_range_time: list_log_by_range_time,
    list_log_by_time: list_log_by_time,
    list_model_by_category: list_model_by_category,
    list_model_by_name: list_model_by_name,
    list_model_by_name_category: list_model_by_name_category,
    list_model_by_type: list_model_by_type,
    list_model_config_by_model: list_model_config_by_model,
    list_slice_by_device: list_slice_by_device,
    list_slice_by_device_model: list_slice_by_device_model,
    list_slice_by_model: list_slice_by_model,
    list_slice_by_name: list_slice_by_name,
    list_type_by_name: list_type_by_name,
    read_buffer: read_buffer,
    read_buffer_by_time: read_buffer_by_time,
    read_buffer_first: read_buffer_first,
    read_buffer_last: read_buffer_last,
    read_data: read_data,
    read_device: read_device,
    read_device_by_sn: read_device_by_sn,
    read_device_config: read_device_config,
    read_gateway: read_gateway,
    read_gateway_by_sn: read_gateway_by_sn,
    read_gateway_config: read_gateway_config,
    read_group_device: read_group_device,
    read_group_gateway: read_group_gateway,
    read_group_model: read_group_model,
    read_log: read_log,
    read_model: read_model,
    read_model_config: read_model_config,
    read_slice: read_slice,
    read_type: read_type,
    remove_group_device_member: remove_group_device_member,
    remove_group_gateway_member: remove_group_gateway_member,
    remove_group_model_member: remove_group_model_member,
    remove_type_model: remove_type_model,
    update_buffer: update_buffer,
    update_device: update_device,
    update_device_config: update_device_config,
    update_gateway: update_gateway,
    update_gateway_config: update_gateway_config,
    update_group_device: update_group_device,
    update_group_gateway: update_group_gateway,
    update_group_model: update_group_model,
    update_log: update_log,
    update_model: update_model,
    update_model_config: update_model_config,
    update_slice: update_slice,
    update_type: update_type
});

export { add_group_device_member, add_group_gateway_member, add_group_model_member, add_role_access, add_type_model, add_user_role, index$1 as auth, create_access_token, create_api, create_auth_token, create_buffer, create_data, create_device, create_device_config, create_gateway, create_gateway_config, create_group_device, create_group_gateway, create_group_model, create_log, create_model, create_model_config, create_procedure, create_role, create_slice, create_type, create_user, delete_access_token, delete_api, delete_auth_token, delete_buffer, delete_data, delete_device, delete_device_config, delete_gateway, delete_gateway_config, delete_group_device, delete_group_gateway, delete_group_model, delete_log, delete_model, delete_model_config, delete_procedure, delete_role, delete_slice, delete_token_by_user, delete_type, delete_user, list_api_by_category, list_auth_token, list_buffer_first, list_buffer_last, list_data_by_last_time, list_data_by_number_after, list_data_by_number_before, list_data_by_range_time, list_data_by_time, list_device_by_gateway, list_device_by_gateway_name, list_device_by_gateway_type, list_device_by_name, list_device_by_type, list_device_config_by_device, list_gateway_by_name, list_gateway_by_type, list_gateway_config_by_gateway, list_group_device_by_category, list_group_device_by_name, list_group_device_by_name_category, list_group_gateway_by_category, list_group_gateway_by_name, list_group_gateway_by_name_category, list_group_model_by_category, list_group_model_by_name, list_group_model_by_name_category, list_log_by_last_time, list_log_by_range_time, list_log_by_time, list_model_by_category, list_model_by_name, list_model_by_name_category, list_model_by_type, list_model_config_by_model, list_procedure_by_api, list_role_by_api, list_role_by_user, list_slice_by_device, list_slice_by_device_model, list_slice_by_model, list_slice_by_name, list_token_by_user, list_type_by_name, list_user_by_role, read_access_token, read_api, read_api_by_name, read_buffer, read_buffer_by_time, read_buffer_first, read_buffer_last, read_data, read_device, read_device_by_sn, read_device_config, read_gateway, read_gateway_by_sn, read_gateway_config, read_group_device, read_group_gateway, read_group_model, read_log, read_model, read_model_config, read_procedure, read_procedure_by_name, read_role, read_role_by_name, read_slice, read_type, read_user, read_user_by_name, remove_group_device_member, remove_group_gateway_member, remove_group_model_member, remove_role_access, remove_type_model, remove_user_role, index as resource, update_access_token, update_api, update_auth_token, update_buffer, update_device, update_device_config, update_gateway, update_gateway_config, update_group_device, update_group_gateway, update_group_model, update_log, update_model, update_model_config, update_procedure, update_role, update_slice, update_type, update_user, user_login, user_login_key, user_logout, user_refresh, utility };
